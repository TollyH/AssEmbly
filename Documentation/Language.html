<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Language</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="assembly-language-reference">AssEmbly Language Reference</h1>
<p>Applies to versions: <code>1.1.0</code> - <code>1.1.1</code></p>
<p>Last revised: 2023-08-26</p>
<h2 id="introduction">Introduction</h2>
<p>AssEmbly is a mock processor architecture and assembly language
written in C# and running on .NET. It is designed to simplify the
process of learning and writing in assembly language, while still
following the same basic concepts and constraints seen in mainstream
architectures such as x86.</p>
<p>AssEmbly was designed and implemented in its entirety by <a
href="https://github.com/TollyH">Tolly Hill</a>.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#assembly-language-reference">AssEmbly Language
Reference</a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#technical-information">Technical Information</a></li>
<li><a href="#basic-syntax">Basic Syntax</a>
<ul>
<li><a href="#mnemonics-and-operands">Mnemonics and Operands</a></li>
<li><a href="#comments">Comments</a></li>
<li><a href="#labels">Labels</a></li>
</ul></li>
<li><a href="#operand-types">Operand Types</a>
<ul>
<li><a href="#register">Register</a></li>
<li><a href="#literal">Literal</a></li>
<li><a href="#address">Address</a></li>
<li><a href="#pointer">Pointer</a></li>
</ul></li>
<li><a href="#registers">Registers</a>
<ul>
<li><a href="#register-table">Register Table</a></li>
<li><a href="#rpo--program-offset"><code>rpo</code> — Program
Offset</a></li>
<li><a href="#rsf--status-flags"><code>rsf</code> — Status
Flags</a></li>
<li><a href="#rrv--return-value"><code>rrv</code> — Return
Value</a></li>
<li><a href="#rfp--fast-pass-parameter"><code>rfp</code> — Fast Pass
Parameter</a></li>
<li><a href="#rso--stack-offset"><code>rso</code> — Stack
Offset</a></li>
<li><a href="#rsb--stack-base"><code>rsb</code> — Stack Base</a></li>
<li><a href="#rg0---rg9--general-purpose"><code>rg0</code> -
<code>rg9</code> — General Purpose</a></li>
</ul></li>
<li><a href="#moving-data">Moving Data</a>
<ul>
<li><a href="#moving-with-literals">Moving with Literals</a></li>
<li><a href="#moving-with-registers">Moving with Registers</a></li>
<li><a href="#moving-with-memory">Moving with Memory</a></li>
</ul></li>
<li><a href="#maths-and-bitwise-operations">Maths and Bitwise
Operations</a>
<ul>
<li><a href="#addition-and-multiplication">Addition and
Multiplication</a></li>
<li><a href="#subtraction">Subtraction</a></li>
<li><a href="#division">Division</a></li>
<li><a href="#shifting">Shifting</a></li>
<li><a href="#bitwise">Bitwise</a></li>
<li><a href="#random-number-generation">Random Number
Generation</a></li>
<li><a href="#lack-of-signed-numbers-and-workarounds">Lack of Signed
Numbers and Workarounds</a></li>
</ul></li>
<li><a href="#jumping">Jumping</a></li>
<li><a href="#comparing-testing-and-branching">Comparing, Testing, and
Branching</a>
<ul>
<li><a href="#comparing-numbers">Comparing Numbers</a></li>
<li><a href="#testing-bits">Testing Bits</a></li>
<li><a href="#checking-for-a-carry-or-for-zero">Checking For a Carry or
For Zero</a></li>
</ul></li>
<li><a href="#assembler-directives">Assembler Directives</a>
<ul>
<li><a href="#pad--byte-padding"><code>PAD</code> — Byte
Padding</a></li>
<li><a href="#dat--byte-insertion"><code>DAT</code> — Byte Insertion</a>
<ul>
<li><a href="#escape-sequences">Escape Sequences</a></li>
</ul></li>
<li><a href="#num--number-insertion"><code>NUM</code> — Number
Insertion</a></li>
<li><a href="#mac--macro-definition"><code>MAC</code> — Macro
Definition</a></li>
<li><a href="#imp--file-importing"><code>IMP</code> — File
Importing</a></li>
<li><a
href="#analyzer--toggling-assembler-warnings"><code>ANALYZER</code> —
Toggling Assembler Warnings</a></li>
</ul></li>
<li><a href="#console-input-and-output">Console Input and
Output</a></li>
<li><a href="#file-handling">File Handling</a>
<ul>
<li><a href="#opening-and-closing">Opening and Closing</a></li>
<li><a href="#reading-and-writing">Reading and Writing</a></li>
<li><a href="#other-operations">Other Operations</a></li>
</ul></li>
<li><a href="#the-stack">The Stack</a>
<ul>
<li><a href="#using-the-stack-to-preserve-registers">Using the Stack to
Preserve Registers</a></li>
</ul></li>
<li><a href="#subroutines">Subroutines</a>
<ul>
<li><a href="#fast-calling">Fast Calling</a></li>
<li><a href="#return-values">Return Values</a></li>
<li><a href="#subroutines-and-the-stack">Subroutines and the
Stack</a></li>
<li><a href="#passing-multiple-parameters">Passing Multiple
Parameters</a></li>
</ul></li>
<li><a href="#text-encoding">Text Encoding</a></li>
<li><a href="#full-instruction-reference">Full Instruction
Reference</a></li>
<li><a href="#ascii-table">ASCII Table</a></li>
</ul></li>
</ul>
<h2 id="technical-information">Technical Information</h2>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 72%" />
</colgroup>
<tbody>
<tr class="odd">
<td>Bits</td>
<td>64 (registers, operands &amp; addresses)</td>
</tr>
<tr class="even">
<td>Word Size</td>
<td>8 bytes (64-bits – called a Quad Word for consistency with x86)</td>
</tr>
<tr class="odd">
<td>Minimum Addressable Unit</td>
<td>Byte (8-bits)</td>
</tr>
<tr class="even">
<td>Register Count</td>
<td>16 (10 general purpose)</td>
</tr>
<tr class="odd">
<td>Architecture Type</td>
<td>Register–memory</td>
</tr>
<tr class="even">
<td>Endianness</td>
<td>Little</td>
</tr>
<tr class="odd">
<td>Branching</td>
<td>Condition code (status register)</td>
</tr>
<tr class="even">
<td>Opcode Size</td>
<td>1 byte (fixed)</td>
</tr>
<tr class="odd">
<td>Operand Size</td>
<td>1 byte (registers, pointers) / 8 bytes (literals,
addresses/labels)</td>
</tr>
<tr class="even">
<td>Instruction Size</td>
<td>1 byte – 17 bytes (practical) / unlimited (theoretical)</td>
</tr>
<tr class="odd">
<td>Instruction Count</td>
<td>165 opcodes (48 unique operations)</td>
</tr>
<tr class="even">
<td>Text Encoding</td>
<td>UTF-8</td>
</tr>
</tbody>
</table>
<h2 id="basic-syntax">Basic Syntax</h2>
<h3 id="mnemonics-and-operands">Mnemonics and Operands</h3>
<p>All AssEmbly instructions are written on a separate line, starting
with a <strong>mnemonic</strong> — a 3-letter code that tells the
<strong>assembler</strong> exactly what operation needs to be performed
— followed by any and all <strong>operands</strong> for the instruction.
The assembler is the program that takes human readable assembly programs
and turns them into raw numbers — bytes — that can be read by the
processor. This process is called <strong>assembly</strong> or
<strong>assembling</strong>. An operand can be thought of like a
parameter to a function in a high-level language — data that is given to
the processor to read and/or operate on. Mnemonics are separated from
operands with spaces, and operands are separated with commas.</p>
<p>A simple example:</p>
<pre class="text"><code>MVQ rg0, 10</code></pre>
<pre class="text"><code>  MVQ        rg0,      10
  ↑          ↑         ↑
  Mnemonic   Operand   Operand
|----------Instruction----------|</code></pre>
<p>You can have as many spaces as you like between commas and
mnemonics/operands. There do not need to be any around commas, but there
must be at least one between mnemonics and operands. Mnemonics and
operands <strong>cannot</strong> be separated with commas.</p>
<p>Some instructions, like <code>CFL</code>, don’t need any operands. In
these cases, simply have the mnemonic alone on the line.</p>
<p>Mnemonics correspond to and are assembled down to
<strong>opcodes</strong>, numbers (in the case of AssEmbly, single
bytes), that the processor reads to know what instruction to perform and
what types of operands it needs to read.</p>
<p>The processor will begin executing from the <strong>first
line</strong> in the file downwards. Programs should <em>always</em> end
in a <code>HLT</code> instruction (with no operands) to stop the
processor.</p>
<p>For the most part, if an instruction modifies or stores a value
somewhere, the <strong>first</strong> operand will be used as the
<strong>destination</strong>.</p>
<h3 id="comments">Comments</h3>
<p>If you wish to insert text into a program without it being considered
by the assembler as part of the program, you can use a semicolon
(<code>;</code>). Any character after a semicolon will be ignored by the
assembler until the end of the line. You can have a line be entirely a
comment without any instruction if you wish.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 10  ; This text will be ignored
; As will this text
DCR rg0  ; &quot;DCR rg0&quot; will assemble as normal
; Another Comment ; HLT - This is still a comment and will not insert a HLT instruction!</code></pre>
<h3 id="labels">Labels</h3>
<p>Labels mark a position in the file for the program to move
(<strong>jump</strong>) to or reference from elsewhere. They can be
given any name you like (names are <strong>case sensitive</strong>), but
they must be unique per-program and can only contain letters, numbers,
and underscores. Label names <strong>may not</strong> begin with a
number, however. A definition for a label is marked by beginning a line
with a colon — the entire rest of the line will then be read as the new
label name (excluding comments).</p>
<p>For example:</p>
<pre class="text"><code>:AREA_1  ; This comment is valid and will not be read as part of the label
MVQ rg0, 10  ; :AREA_1 now points here

:Area2
DCR rg0  ; :Area2 now points here
HLT</code></pre>
<p>Labels will point to whatever is directly below them, <strong>unless
that is a comment</strong>. Comments are not assembled and so cannot be
pointed to.</p>
<p>For example:</p>
<pre class="text"><code>:NOT_COMMENT  ; Comment 1
; Comment 2
; Comment 3
WCC 10</code></pre>
<p>Here <code>:NOT_COMMENT</code> will point to <code>WCC</code>, as it
is the first thing that will be assembled after the definition was
written.</p>
<p>Labels can also be placed at the very end of a file to point to the
first byte in memory that is not part of the program.</p>
<p>For example, in the small file:</p>
<pre class="text"><code>MVQ rg0, 5
MVQ rg1, 10
:END</code></pre>
<p><code>:END</code> here will have a value of <code>34</code> when
referenced, as each instruction prior will take up <code>17</code> bytes
(more on this later).</p>
<h2 id="operand-types">Operand Types</h2>
<p>There are four different types of operand that an instruction may be
able to take. If an instruction supports multiple different possible
combinations of operands, the assembler will automatically determine
their types, you do not need to change the mnemonic at all.</p>
<h3 id="register">Register</h3>
<p>Registers are named, single-number stores separate from the
processor’s main memory. Most operations must be performed on them,
instead of in locations in memory. They are referenced by using their
name (currently always 3 letters — the first one being <code>r</code>,
for example <code>rg0</code>). They always occupy a single byte of
memory after being assembled.</p>
<p>The first operand in this instruction is a register:</p>
<pre class="text"><code>MVQ rg0, 10</code></pre>
<h3 id="literal">Literal</h3>
<p>Literals are numeric values that are directly written in an assembly
file and <strong>do not change</strong>. Their value is read literally
instead of being subject to special consideration, hence the name. They
always occupy 8 bytes (64-bits) of memory after assembly and can be
written in base 10 (denary/decimal), base 2 (binary), or base 16
(hexadecimal). To write in binary, place the characters <code>0b</code>
before the number, or to write in hexadecimal, place <code>0x</code>
before the number.</p>
<p>The second operand in each of these instructions is a literal that
will each represent the same number (ten) after assembly:</p>
<pre class="text"><code>MVQ rg0, 10  ; Base 10
MVQ rg0, 0b1010  ; Base 2
MVQ rg0, 0xA  ; Base 16</code></pre>
<p>When writing literals, you can place an underscore anywhere within
the number value to separate the digits. Underscores cannot be the first
character of the number.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 0x1_000_000  ; This is valid, will be assembled as 0x1000000 (16777216)
MVQ rg0, 0x10_0__000_0  ; This is still valid, underscores don&#39;t have to be uniform

MVQ rg0, 0x_1_000_000  ; This is not valid
MVQ rg0, 0_x1_000_000  ; This is also not valid
MVQ rg0, _0x1_000_000  ; Nor is this</code></pre>
<h3 id="address">Address</h3>
<p>An address is a value that is interpreted as a location to be read
from, written to, or jumped to in a processor’s main memory. In
AssEmbly, an address is always specified by using a
<strong>label</strong>. Once a label has been defined as seen earlier,
they can be referenced by prefixing their name with a colon
(<code>:</code>), similarly to how they are defined — only now it will
be in the place of an operand. Like literals, they always occupy 8 bytes
(64-bits) of memory after assembly.</p>
<p>Consider the following example:</p>
<pre class="text"><code>:AREA_1
WCC 10
MVQ rg0, :AREA_1  ; Move whatever is stored at :AREA_1 in memory to rg0</code></pre>
<p>Here <code>:AREA_1</code> will point to the <strong>first
byte</strong> (i.e. the <strong>opcode</strong>) of the <strong>directly
subsequent assemble-able line</strong> — in this case <code>WCC</code>.
The second operand to <code>MVQ</code> will become the address that
<code>WCC</code> is stored at in memory, <code>0</code> if it is the
first instruction in the file. As <code>MVQ</code> is the instruction to
move to a destination from a source, <code>rg0</code> will contain
<code>0xCD</code> after the instruction executes (<code>0xCD</code>
being the opcode for <code>WCC &lt;Literal&gt;</code>).</p>
<p>Another example, assuming these are the very first lines in a
file:</p>
<pre class="text"><code>WCC 10
:AREA_1
WCX :AREA_1  ; Will write &quot;CA&quot; to the console</code></pre>
<p><code>:AREA_1</code> will have a value of <code>9</code>, as
<code>WCC 10</code> occupies <code>9</code> bytes. Note that
<code>CA</code> (the opcode for <code>WCX &lt;Address&gt;</code>) will
be written to the console, <em>not</em> <code>9</code>, as the processor
is accessing the byte in memory <em>at</em> the address — <em>not</em>
the address itself.</p>
<p>If, when writing an instruction, you want to utilise the address
<em>itself</em>, rather than the value in memory at that address, insert
an ampersand (<code>&amp;</code>) after the colon, before the label
name.</p>
<p>For example:</p>
<pre class="text"><code>:AREA_1
WCC 10
MVQ rg0, :&amp;AREA_1  ; Move 0 (the address itself) to rg0
WCX :&amp;AREA_1  ; Will write &quot;0&quot; to the console</code></pre>
<h3 id="pointer">Pointer</h3>
<p>So what if you’ve copied an address to a register? You now want to
treat the value of a register as if it were an address in memory, not a
number. This can be achieved with a <strong>pointer</strong>. Simply
prefix a register name with an asterisk (<code>*</code>) to treat the
register contents as a location to store to, read from, or jump to —
instead of a number to operate on. Just like registers, they will occupy
a single byte in memory after assembly.</p>
<p>For example:</p>
<pre class="text"><code>:AREA_1
WCC 10
MVQ rg0, :&amp;AREA_1  ; Move 0 (the address itself) to rg0
MVQ rg1, *rg0  ; Move the item in memory (0xCD) at the address (0) in rg0 to rg1</code></pre>
<p><code>rg1</code> will contain <code>0xCD</code> after the third
instruction finishes.</p>
<h2 id="registers">Registers</h2>
<p>As with most modern architectures, operations in AssEmbly are almost
always performed on <strong>registers</strong>. Each register contains a
64-bit number and has a unique, pre-assigned name. They are stored
separately from the processor’s memory, therefore cannot be referenced
by an address, only by name. There are 16 of them in AssEmbly, 10 of
which are <em>general purpose</em>, meaning they are free to be used for
whatever you wish. The remaining six have special purposes within the
architecture, so should be used with care.</p>
<p>Please be aware that to understand the full operation and purpose for
some registers, knowledge explained later on in the manual may be
required.</p>
<h3 id="register-table">Register Table</h3>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 6%" />
<col style="width: 9%" />
<col style="width: 17%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="header">
<th>Byte</th>
<th>Symbol</th>
<th>Writeable</th>
<th>Full Name</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0x00</td>
<td>rpo</td>
<td>No</td>
<td>Program Offset</td>
<td>Stores the memory address of the current location in memory being
executed</td>
</tr>
<tr class="even">
<td>0x01</td>
<td>rso</td>
<td>Yes</td>
<td>Stack Offset</td>
<td>Stores the memory address of the highest non-popped item on the
stack</td>
</tr>
<tr class="odd">
<td>0x02</td>
<td>rsb</td>
<td>Yes</td>
<td>Stack Base</td>
<td>Stores the memory address of the bottom of the current stack
frame</td>
</tr>
<tr class="even">
<td>0x03</td>
<td>rsf</td>
<td>Yes</td>
<td>Status Flags</td>
<td>Stores bits representing the status of certain instructions</td>
</tr>
<tr class="odd">
<td>0x04</td>
<td>rrv</td>
<td>Yes</td>
<td>Return Value</td>
<td>Stores the return value of the last executed subroutine</td>
</tr>
<tr class="even">
<td>0x05</td>
<td>rfp</td>
<td>Yes</td>
<td>Fast Pass Parameter</td>
<td>Stores a single parameter passed to a subroutine</td>
</tr>
<tr class="odd">
<td>0x06</td>
<td>rg0</td>
<td>Yes</td>
<td>General 0</td>
<td><em>General purpose</em></td>
</tr>
<tr class="even">
<td>0x07</td>
<td>rg1</td>
<td>Yes</td>
<td>General 1</td>
<td><em>General purpose</em></td>
</tr>
<tr class="odd">
<td>0x08</td>
<td>rg2</td>
<td>Yes</td>
<td>General 2</td>
<td><em>General purpose</em></td>
</tr>
<tr class="even">
<td>0x09</td>
<td>rg3</td>
<td>Yes</td>
<td>General 3</td>
<td><em>General purpose</em></td>
</tr>
<tr class="odd">
<td>0x0A</td>
<td>rg4</td>
<td>Yes</td>
<td>General 4</td>
<td><em>General purpose</em></td>
</tr>
<tr class="even">
<td>0x0B</td>
<td>rg5</td>
<td>Yes</td>
<td>General 5</td>
<td><em>General purpose</em></td>
</tr>
<tr class="odd">
<td>0x0C</td>
<td>rg6</td>
<td>Yes</td>
<td>General 6</td>
<td><em>General purpose</em></td>
</tr>
<tr class="even">
<td>0x0D</td>
<td>rg7</td>
<td>Yes</td>
<td>General 7</td>
<td><em>General purpose</em></td>
</tr>
<tr class="odd">
<td>0x0E</td>
<td>rg8</td>
<td>Yes</td>
<td>General 8</td>
<td><em>General purpose</em></td>
</tr>
<tr class="even">
<td>0x0F</td>
<td>rg9</td>
<td>Yes</td>
<td>General 9</td>
<td><em>General purpose</em></td>
</tr>
</tbody>
</table>
<h3 id="rpo-program-offset"><code>rpo</code> — Program Offset</h3>
<p>Stores the memory address of the current location in memory being
executed. For safety, it cannot be directly written to. To change where
you are in a program, use a <strong>jump instruction</strong> (explained
later on).</p>
<p>For example, in the short program (assuming the first instruction is
the first in a file):</p>
<pre class="text"><code>MVQ rg0, 10
DCR rg0</code></pre>
<p>When the program starts, <code>rpo</code> will have a value of
<code>0</code> — the address of the first item in memory. After the
first instruction has finished executing, <code>rpo</code> will have a
value of <code>10</code>: its previous value <code>0</code>, plus
<code>1</code> byte for the mnemonic’s opcode, <code>1</code> byte for
the register operand, and <code>8</code> bytes for the literal operand.
<code>rpo</code> is now pointing to the opcode of the next instruction
(<code>DCR</code>).</p>
<p><strong>Note:</strong> <code>rpo</code> is incremented by 1
<strong><em>before</em></strong> an instruction begins execution,
therefore when used as an operand in an instruction, it will point to
the address of the <strong>first operand</strong>, <strong>not to the
address of the opcode</strong>. It will not be incremented again until
<em>after</em> the instruction has completed.</p>
<p>For example, in the instruction:</p>
<pre class="text"><code>MVQ rg0, rpo</code></pre>
<p>Before execution of the instruction begins, <code>rpo</code> will
point to the opcode corresponding to <code>MVQ</code> with a register
and literal. Once the processor reads this, it increments
<code>rpo</code> by <code>1</code>. <code>rpo</code> now points to the
first operand: <code>rg0</code>. This value will be retained until after
the instruction has completed, when <code>rpo</code> will be increased
by <code>2</code> (<code>1</code> for each register operand). This means
there was an increase of <code>3</code> overall when including the
initial increment by <code>1</code> for the opcode.</p>
<h3 id="rsf-status-flags"><code>rsf</code> — Status Flags</h3>
<p>The status flags register is used to mark some information about
previously executed instructions. While it stores a 64-bit number just
like every other register, its value should instead be treated
bit-by-bit rather than as one number.</p>
<p>Currently, the <strong>lowest 3</strong> bits of the 64-bit value
have a special use — the remaining 61 will not be automatically modified
as of current, though it is recommended that you do not use them for
anything else in case this changes in the future.</p>
<p>The 3 bits currently in use are:</p>
<pre class="text"><code>0b00...0000000FCZ

... = 52 omitted bits
F = File end flag
C = Carry flag
Z = Zero flag</code></pre>
<p>Each bit of this number can be considered as a <code>true</code>
(<code>1</code>) or <code>false</code> (<code>0</code>) value as to
whether the flag is “set” or not.</p>
<p>The file end flag is set to <code>1</code> by the <code>RFC</code>
operation if the byte that has just been read from the currently open
file was the last byte in that file. It is reset to <code>0</code> only
upon opening a file again.</p>
<p>The carry flag is set to <code>1</code> after a mathematical or
bitwise operation if the result of that operation caused the destination
register to go below <code>0</code> and wrap around to the upper limit,
go above the limit of a 64-bit integer and wrap around to <code>0</code>
(more info in the section on maths), otherwise it is proactively set to
<code>0</code>.</p>
<p>The zero flag is set to <code>1</code> after a mathematical or
bitwise operation if the result of that operation caused the destination
register to become equal to <code>0</code>, otherwise it is proactively
set to <code>0</code>.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 0  ; Set rg0 to 0
; The zero flag has NOT been set here, moving is not a mathematical or bitwise operation
SUB rg0, 1  ; Subtract 1 from rg0
; rg0 will now equal the 64-bit integer limit, as it went below 0
; The second bit (carry flag) in rsf is now 1
; The first bit (zero flag) has not changed from 0
ADD rg0, 1  ; Add 1 back to rg0
; rg0 will now once again equal 0, as it went over the 64-bit integer limit
; The second bit (carry flag) in rsf is still 1
; The first bit (zero flag) has now been changed to 1
ADD rg0, 1
; rg0 is now 1, no limits were exceeded
; The second bit (carry flag) in rsf has been set back to 0
; The first bit (zero flag) in rsf has been set back to 0</code></pre>
<p>More information on using these flags can be found in the section on
comparison and testing.</p>
<h3 id="rrv-return-value"><code>rrv</code> — Return Value</h3>
<p>Stores the return value of the last executed subroutine. Note that if
a subroutine doesn’t return a value, <code>rrv</code> will remain
unaffected.</p>
<p>For example:</p>
<pre class="text"><code>:SUBROUTINE_ONE
...
...
...
RET 4  ; Return, setting rrv to the literal 4

:SUBROUTINE_TWO
...
...
...
RET  ; Return, leaving rrv unaffected

CAL :SUBROUTINE_ONE
; rrv is now 4
CAL :SUBROUTINE_TWO
; rrv is still 4</code></pre>
<p>More information can be found in the section on subroutines.</p>
<h3 id="rfp-fast-pass-parameter"><code>rfp</code> — Fast Pass
Parameter</h3>
<p>Stores a single parameter passed to a subroutine. If such a parameter
is not provided, <code>rfp</code> remains unaffected.</p>
<p>For example:</p>
<pre class="text"><code>:SUBROUTINE_ONE
ADD rfp, 1
RET rfp

:SUBROUTINE_TWO
ADD rfp, 2
RET rfp

CAL :SUBROUTINE_ONE, 4  ; This will implicitly set rfp to 4
; rrv is now 5
CAL :SUBROUTINE_TWO, 6  ; This will implicitly set rfp to 6
; rrv is now 8
CAL :SUBROUTINE_TWO  ; rfp will remain 6 here
; rrv is now 10</code></pre>
<p>Implicitly setting <code>rfp</code> like this with the
<code>CAL</code> instruction is called <strong>fast passing</strong> or
<strong>fast calling</strong>, hence the name fast pass parameter.</p>
<p>Note that in practice, if a subroutine is designed to take a fast
pass parameter, you should <strong>always</strong> explicitly provide
it, even if you think <code>rfp</code> will already have the value you
want. Similarly, you should not use <code>rfp</code> in a subroutine if
it has not been explicitly set in its calls.</p>
<p>More information can be found in the section on subroutines.</p>
<h3 id="rso-stack-offset"><code>rso</code> — Stack Offset</h3>
<p>Stores the memory address of the highest non-popped item on the stack
(note that the stack fills from the end of memory backwards). If nothing
is left on the stack in the current subroutine, it will be equal to
<code>rsb</code>, and if nothing is left on the stack at all, it will
still be equal to <code>rsb</code>, with both being equal to one over
the highest possible address in memory (so will result in an error if
that address is read from).</p>
<p>More information can be found in the dedicated sections on the stack
and subroutines.</p>
<p>A simple example, assuming memory is 2046 bytes in size (making 2045
the highest address):</p>
<pre class="text"><code>WCN rso  ; Outputs &quot;2046&quot;
PSH 5  ; Push the literal 5 to the stack
WCN rso  ; Outputs &quot;2038&quot; (stack values are 8 bytes)
POP rg0  ; Pop the just-pushed 5 into rg0
WCN rso  ; Outputs &quot;2046&quot;</code></pre>
<h3 id="rsb-stack-base"><code>rsb</code> — Stack Base</h3>
<p>Stores the memory address of the bottom of the current stack frame.
<code>rsb</code> will only ever change when subroutines are being
utilised — see the dedicated sections on the stack and subroutines for
more info.</p>
<p>Note that <code>rsb</code> does not contain the address of the first
item pushed to the stack, rather the address that all pushed items will
be on top of.</p>
<h3 id="rg0---rg9-general-purpose"><code>rg0</code> - <code>rg9</code> —
General Purpose</h3>
<p>These 10 registers have no special purpose. They will never be
changed unless you explicitly change them with either a move operation,
or another operation that stores to registers. These will be used most
of the time to store and operate on values, as using memory or the stack
to do so is inefficient (and in many cases impossible without copying to
a register first), so should only be done when you run out of free
registers.</p>
<h2 id="moving-data">Moving Data</h2>
<p>There are four different instructions that are used to move data
around without altering it in AssEmbly, each one moving a different
number of bytes. <code>MVB</code> moves a single byte, <code>MVW</code>
moves two (a.k.a. a word, 16-bits), <code>MVD</code> moves four (a.k.a.
a double word, 32-bits), and <code>MVQ</code> moves eight (a.k.a. a quad
word, 64-bits, a full number in AssEmbly).</p>
<p>Data can either be moved between two registers, from a register to a
memory location, or from a memory location to a register. You cannot
move data between two memory locations, you must use a register as a
midpoint instead. To move data to or from a memory location, you can use
either a label or a pointer.</p>
<p>The move instructions are also how the value of a register or memory
location is set to a literal value. In a sense, they can be considered
the equivalent of the <code>=</code> assignment operator in higher level
languages.</p>
<p>When using move instructions, the destination always comes first. The
destination cannot be a literal.</p>
<h3 id="moving-with-literals">Moving with Literals</h3>
<p>An example of setting registers to the maximum literal values for
each instruction:</p>
<pre class="text"><code>MVQ rg0, 18446744073709551615  ; 64-bit integer limit
MVD rg1, 4294967295  ; 32-bit integer limit
MVW rg2, 65535  ; 16-bit integer limit
MVB rg3, 255  ; 8-bit integer limit</code></pre>
<p>Or labels and pointers:</p>
<pre class="text"><code>MVQ *rg0, 18446744073709551615  ; 64-bit integer limit
MVD *rg1, 4294967295  ; 32-bit integer limit
MVW :AREA_1, 65535  ; 16-bit integer limit
MVB :AREA_2, 255  ; 8-bit integer limit</code></pre>
<p>Note that providing a literal over the limit for a given instruction
will not result in an error. Instead, the <strong>upper</strong> bits
that do not fit in the specified size will be truncated. All 64-bits
will still be assembled into the binary (literals are
<strong>always</strong> assembled to 8 bytes).</p>
<p>For example:</p>
<pre class="text"><code>MVB rg0, 9874</code></pre>
<p><code>MVB</code> can only take a single byte, or 8 bits, but in
binary <code>9874</code> is <code>10011010010010</code>, requiring 14
bits at minimum to store. The lower 8 bits will be kept:
<code>10010010</code> — the remaining 6 (<code>100110</code>) will be
discarded. After this instruction has executed, <code>rg0</code> will
have a value of <code>146</code>.</p>
<h3 id="moving-with-registers">Moving with Registers</h3>
<p>When moving to and from a register, <code>MVQ</code> will update or
read all of its bits (remember that registers are 64-bit). If any of the
smaller move instructions are used, the <strong>lower</strong> bits of
the register will be used, with the remaining upper bits of a
destination register all being set to <code>0</code>.</p>
<p>For example, assume that before the <code>MVD</code> instruction,
<code>rg1</code> has a value of
<code>14,879,176,506,051,693,048</code>:</p>
<pre class="text"><code>MVW rg1, 65535</code></pre>
<p><code>14,879,176,506,051,693,048</code> in binary is
<code>1100111001111101011101000011001011110001100011001000100111111000</code>,
a full 64-bits, and <code>65535</code> is <code>1111111111111111</code>,
requiring only 16 bits. <code>MVW</code> will only consider these 16
bits (if there were more they would have been truncated, see above
section). Instead of altering only the lowest 16 bits of
<code>rg1</code>, <code>MVW</code> will instead set all the remaining 48
bits to <code>0</code>, resulting in a final value of
<code>0000000000000000000000000000000000000000000000001111111111111111</code>
— <code>65535</code> perfectly.</p>
<p>Similarly to literals, if a source register contains a number greater
than what a move instruction can handle, the upper bits will be
disregarded.</p>
<h3 id="moving-with-memory">Moving with Memory</h3>
<p>Unlike with registers, using different sizes of move instruction
<em>will</em> affect how any bytes are read from memory. Bytes are read
from or written to <strong>starting</strong> at the address in the given
label or pointer, and only the required number for the given instruction
are read or written (1 for <code>MVB</code>, 2 for <code>MVW</code>, 4
for <code>MVD</code>, 8 for <code>MVQ</code>). The instructions will
<em>always</em> write these numbers of bytes, if a number to be moved
takes up less, it will be padded with <code>0</code>s.</p>
<p>Numbers are stored in memory in little endian encoding, meaning that
the smallest byte is stored first, up to the largest. For example, the
32-bit number <code>2,356,895,874</code> is represented in hexadecimal
as <code>0x8C7B6082</code>, which can be broken down into 4 bytes:
<code>8C</code>, <code>7B</code>, <code>60</code>, and <code>82</code>.
When stored in memory, this order will be <em>reversed</em>, as
follows:</p>
<pre class="text"><code>| Address | 00 | 01 | 02 | 03 |
|  Value  | 82 | 60 | 7B | 8C |</code></pre>
<p>This allows you to read a number with a smaller move instruction than
what it was written with, whilst maintaining the same upper-bit
truncating behaviour seen with literals and registers.</p>
<p>An example with a 64-bit number, <code>35,312,134,238,538,232</code>
(<code>0x007D7432F18C89F8</code>):</p>
<pre class="text"><code>| Address | 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 |
|  Value  | F8 | 89 | 8C | F1 | 32 | 74 | 7D | 00 |</code></pre>
<p>Be aware that moving directly between two memory locations is not
allowed. To move from one location in memory to another, use a register
as a midpoint, like so:</p>
<pre class="text"><code>MVQ rg0, :MEMORY_SOURCE
MVQ :MEMORY_DESTINATION, rg0</code></pre>
<p>This also applies to pointers as well as labels (<code>rg1</code>
contains the source address, <code>rg2</code> the destination):</p>
<pre class="text"><code>MVQ rg0, *rg1
MVQ *rg2, rg0</code></pre>
<p>When using any move instruction larger than <code>MVB</code>, be
careful to ensure that not only the starting point is within the bounds
of available memory, but also all of the subsequent bytes. For example,
if you have <code>2046</code> bytes of available memory (making
<code>2045</code> the maximum address), you cannot use <code>MVQ</code>
on the starting address <code>2043</code>, as that requires at least 8
bytes.</p>
<h2 id="maths-and-bitwise-operations">Maths and Bitwise Operations</h2>
<p>AssEmbly supports ten different mathematical operations and five
different bitwise operations (one being the random number generator).
Each one operates <strong>in-place</strong>, meaning the first operand
for the operation is also used as the destination for the resulting
value to be stored to. Destinations, and thus the first operand, must
always be a <strong>register</strong>.</p>
<p>Mathematical and bitwise operations are always done with 64-bits,
therefore if an address (i.e. a label or pointer) is used as the second
operand, 4-bytes will be read starting at that address for the operation
in little endian encoding (see the “moving with memory” section above
for more info on little endian).</p>
<h3 id="addition-and-multiplication">Addition and Multiplication</h3>
<p>Examples of addition and multiplication:</p>
<pre class="text"><code>MVQ rg0, 55  ; Set the value of rg0 to 55
ADD rg0, 45  ; Add 45 to the value of rg0, storing in rg0
; rg0 is now 100
MUL rg0, 3  ; Multiply the value of rg0 by 3, storing in rg0
; rg0 is now 300
MVQ rg1, rg0
MUL rg1, rg0  ; Multiply the value of rg1 by the value of rg0, storing in rg1
; rg1 is now 90000</code></pre>
<p>Be aware that because there is a limit of 64-bits for mathematical
operations, if an addition or multiplication operation results in this
limit (<code>18446744073709551615</code>) being exceeded, the carry
status flag will be set to <code>1</code>, and the result will be
wrapped around back to <code>0</code>, plus however much the limit was
exceeded by.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 18446744073709551615  ; Set rg0 to the 64-bit limit
ADD rg0, 10  ; Add 10 to rg0
; rg0 is now 10

MVQ rg0, 18446744073709551590  ; Set rg0 to the 64-bit limit take 25
ADD rg0, 50  ; Add 50 to rg0
; rg0 is now 24</code></pre>
<p>In the specific case of adding <code>1</code> to a register, the
<code>ICR</code> (increment) operation can be used instead.</p>
<pre class="text"><code>MVQ rg0, 5
ICR rg0
; rg0 is now 6</code></pre>
<h3 id="subtraction">Subtraction</h3>
<p>An example of subtraction:</p>
<pre class="text"><code>MVQ rg0, 55  ; Set the value of rg0 to 55
SUB rg0, 45  ; Subtract 45 from the value of rg0, storing in rg0
; rg0 is now 10
MVQ rg1, rg0
SUB rg1, rg0  ; Subtract the value of rg0 from rg1, storing in rg1
; rg1 is now 0</code></pre>
<p>Numbers in AssEmbly are <strong>unsigned</strong>, meaning that
negative numbers cannot be natively represented (more on how to work
around this later). If a subtraction causes the result to go below 0,
the carry status flag will be set to <code>1</code>, and the result will
be wrapped around up to the upper limit
<code>18446744073709551615</code>, minus however much the limit was
exceeded by.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 0  ; Set rg0 to 0
SUB rg0, 1  ; Subtract 1 from rg0
; rg0 is now 18446744073709551615

MVQ rg0, 25  ; Set rg0 to 25
SUB rg0, 50  ; Subtract 50 from rg0
; rg0 is now 18446744073709551591</code></pre>
<p>In the specific case of subtracting <code>1</code> from a register,
the <code>DCR</code> (decrement) operation can be used instead.</p>
<pre class="text"><code>MVQ rg0, 5
DCR rg0
; rg0 is now 4</code></pre>
<h3 id="division">Division</h3>
<p>There are three types of division in AssEmbly: integer division
(<code>DIV</code>), division with remainder (<code>DVR</code>), and
remainder only (<code>REM</code>).</p>
<p>Integer division divides the first operand by the second, discards
the remainder, then stores the result in the first operand. For
example:</p>
<pre class="text"><code>MVQ rg0, 12  ; Set rg0 to 12
DIV rg0, 4  ; Divide the value in rg0 by 4, storing the result in rg0
; rg0 is now 3

MVQ rg1, 23  ; Set rg1 to 23
DIV rg1, 3  ; Divide the value in rg1 by 3, storing the result in rg1
; rg1 is now 7 (the remainder of 2 is discarded)</code></pre>
<p>Division with remainder, unlike most other operations, takes three
operands, the first two being destination registers, and the third being
the divisor. Like with the other operations, the first operand is used
as the dividend and the result for the integer part of the division. The
value of the second operand is not considered, the second operand simply
being the register to store the remainder of the division.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 12  ; Set rg0 to 12
DVR rg0, rg1, 4  ; Divide the value in rg0 by 4, storing the integer result in rg0, and remainder in rg1
; rg0 is now 3, rg1 is now 0

MVQ rg2, 23  ; Set rg2 to 23
DVR rg2, rg3, 3  ; Divide the value in rg2 by 3, storing the integer result in rg2, and remainder in rg3
; rg2 is now 7, rg3 is now 2</code></pre>
<p>Remainder only division is similar to integer division in that it
only keeps one of the results, but this time the dividend (first
operand) is overwritten by the remainder, and the integer result is
discarded:</p>
<pre class="text"><code>MVQ rg0, 12  ; Set rg0 to 12
REM rg0, 4  ; Divide the value in rg0 by 4, storing the remainder in rg0
; rg0 is now 0

MVQ rg1, 23  ; Set rg1 to 23
REM rg1, 3  ; Divide the value in rg1 by 3, storing the remainder in rg1
; rg1 is now 2 (the integer result of 7 is discarded)</code></pre>
<h3 id="shifting">Shifting</h3>
<p>Shifting is the process of moving the bits in a binary number either
up (left — <code>SHL</code>) or down (right — <code>SHR</code>) a
certain number of places.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 0b11010
; rg0:
; |  Bit  | ... | 64 | 32 | 16 | 8  | 4  | 2  | 1  |
; | Value | ... | 0  | 0  | 1  | 1  | 0  | 1  | 0  |

SHL rg0, 2
; rg0:
; |  Bit  | ... | 64 | 32 | 16 | 8  | 4  | 2  | 1  |
; | Value | ... | 1  | 1  | 0  | 1  | 0  | 0  | 0  |</code></pre>
<p>The bits were shifted 2 places to the left, and new bits on the right
were set to 0.</p>
<p>Here’s one for shifting right:</p>
<pre class="text"><code>MVQ rg0, 0b11010
; rg0:
; |  Bit  | ... | 64 | 32 | 16 | 8  | 4  | 2  | 1  |
; | Value | ... | 0  | 0  | 1  | 1  | 0  | 1  | 0  |

SHR rg0, 2
; rg0:
; |  Bit  | ... | 64 | 32 | 16 | 8  | 4  | 2  | 1  |
; | Value | ... | 0  | 0  | 0  | 0  | 1  | 1  | 0  |</code></pre>
<p>The bits were shifted 2 places to the right, and new bits on the left
were set to 0.</p>
<p>If, like with the right shift example above, a shift causes at least
one <code>1</code> bit to go off the edge (either below the first bit or
above the 64th), the carry flag will be set to <code>1</code>, otherwise
it will be set to <code>0</code>.</p>
<h3 id="bitwise">Bitwise</h3>
<p>Bitwise operations consider each bit of the operands individually
instead of as a whole number. There are three operations that take two
operands (<code>AND</code>, <code>ORR</code>, and <code>XOR</code>), and
one that takes only one (<code>NOT</code>).</p>
<p>Here are tables of how each two-operand operation will affect each
bit</p>
<p>Bitwise And (<code>AND</code>):</p>
<pre class="text"><code>    +---+---+
    | 0 | 1 |
+---+---+---+
| 0 | 0 | 0 |
+---+---+---+
| 1 | 0 | 1 |
+---+---+---+</code></pre>
<p>The <code>AND</code> operation will only set a bit to <code>1</code>
if the bit in both operands is <code>1</code>. For example:</p>
<pre class="text"><code>MVQ rg0, 0b00101
AND rg0, 0b10100
; rg0 now has a value of 0b00100</code></pre>
<p>Bitwise Or (<code>ORR</code>):</p>
<pre class="text"><code>    +---+---+
    | 0 | 1 |
+---+---+---+
| 0 | 0 | 1 |
+---+---+---+
| 1 | 1 | 1 |
+---+---+---+</code></pre>
<p>The <code>ORR</code> operation will set a bit to <code>1</code> if
the bit in either operand is <code>1</code>. For example:</p>
<pre class="text"><code>MVQ rg0, 0b00101
ORR rg0, 0b10100
; rg0 now has a value of 0b10101</code></pre>
<p>Bitwise Exclusive Or (<code>XOR</code>):</p>
<pre class="text"><code>    +---+---+
    | 0 | 1 |
+---+---+---+
| 0 | 0 | 1 |
+---+---+---+
| 1 | 1 | 0 |
+---+---+---+</code></pre>
<p>The <code>XOR</code> operation will set a bit to <code>1</code> if
the bit in one, but not both, operands is <code>1</code>. For
example:</p>
<pre class="text"><code>MVQ rg0, 0b00101
XOR rg0, 0b10100
; rg0 now has a value of 0b10001</code></pre>
<p>The <code>NOT</code> operation only takes a single operand, which
must be a register. It simply “flips” the value of each bit
(i.e. <code>1</code> becomes <code>0</code>, <code>0</code> becomes
<code>1</code>).</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 0b00101
NOT rg0
; rg0 now has a value of 0b11010</code></pre>
<h3 id="random-number-generation">Random Number Generation</h3>
<p>The random number instruction (<code>RNG</code>) takes a single
operand: the register to store the result in. The instruction always
randomises all 64-bits of a register, meaning the result could be
anywhere between 0 and 18446744073709551615.</p>
<p>Remainder only division (<code>REM</code>) by a value one higher than
the desired maximum can be used to limit the random number to a maximum
value, like so:</p>
<pre class="text"><code>RNG rg0  ; rg0 could now be any value between 0 and 18446744073709551615
REM rg0, 5  ; rg0 is now constrained between 0 and 4 depending on its initial value</code></pre>
<p>To set a minimum value also, simply add a constant value to the
result of the <code>REM</code> operation:</p>
<pre class="text"><code>RNG rg0  ; rg0 could now be any value between 0 and 18446744073709551615
REM rg0, 5  ; rg0 is now constrained between 0 and 4 depending on its initial value
ADD rg0, 5  ; rg0 is now constrained between 5 and 9</code></pre>
<h3 id="lack-of-signed-numbers-and-workarounds">Lack of Signed Numbers
and Workarounds</h3>
<p>AssEmbly can only store and operate on <strong>unsigned</strong>
integers, meaning it has no native support for negative numbers.</p>
<p>In some scenarios, this won’t make a difference. For example, if a
negative number is simply a midpoint for an addition/subtraction with a
positive overall answer, you can continue to use the wrapped-around
value without error:</p>
<pre class="text"><code>MVQ rg0, 5
SUB rg0, 10
; Expected value is -5, rg0 is actually 18446744073709551611
MVQ rg1, 25
ADD rg1, rg0
; rg1 is still 20 now as expected, even though rg0 doesn&#39;t have the value we expect</code></pre>
<p>If a result of a subtraction has wrapped around (which can be checked
using the carry flag), the absolute result (the non-negative result) can
be found by performing a bitwise not on and incrementing the result by
1, like so:</p>
<pre class="text"><code>MVQ rg0, 5
SUB rg0, 10
NOT rg0
ICR rg0
; rg0 is now 5, carry bit is set</code></pre>
<p>Using the carry flag, this operation can be done conditionally (more
in the section on branching), as it should not be done on positive
results:</p>
<pre class="text"><code>MVQ rg0, 5
SUB rg0, rg1  ; Assume rg1 has a value that could cause rg0 to be negative or positive
JNC :NOT_NEGATIVE  ; Jump to label if carry flag is unset
NOT rg0  ; These will only run if rg0 wrapped (setting carry flag)
ICR rg0
:NOT_NEGATIVE
; rg0 is now the absolute result</code></pre>
<h2 id="jumping">Jumping</h2>
<p>Jumping is the processes of changing where the processor is currently
executing in a program (represented with the <code>rpo</code> register).
Jumps can be used to make loops, execute code if only a certain
condition is met, or to reuse code, such as with subroutines. After a
jump, the processor will continue to execute instructions from the new
location, it will not automatically return to where it was before.</p>
<p>Jumps are usually made to labels, like so:</p>
<pre class="text"><code>MVQ rg0, 0  ; Set rg0 to 0
:ADD_LOOP  ; Create a label to the following instruction (ADD)
ADD rg0, 5  ; Add 5 to the current value of rg0
JMP :ADD_LOOP  ; Go back to ADD_LOOP and continue executing from there</code></pre>
<p>This program will set rg0 to 0, then infinitely keep adding 5 to the
register by jumping back to the <code>ADD_LOOP</code> label. To only
jump some of the time, for example to create a conditional loop, see the
following section on branching.</p>
<p>Here is another example of a jump:</p>
<pre class="text"><code>MVQ rg0, 0
ADD rg0, 5
JMP :SKIP
ADD rg0, 5  ; This won&#39;t be executed
ADD rg0, 5  ; This won&#39;t be executed
:SKIP
; rg0 is 5 here</code></pre>
<p><code>rg0</code> only ends up being 5 at the end of this example, as
jumping to the <code>SKIP</code> label prevented the two other
<code>ADD</code> instructions from being reached.</p>
<p>Jumps can also be made to pointers, though it is important that you
are sure that the pointer will contain the address of a valid opcode
before jumping there.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, :&amp;MY_CODE  ; Move the literal address of MY_CODE to rg0
JMP *rg0  ; Jump to that address
MVQ rg0, 5  ; This won&#39;t be executed
:MY_CODE
MVQ rg0, 17
; rg0 will be 17, not 5</code></pre>
<h2 id="comparing-testing-and-branching">Comparing, Testing, and
Branching</h2>
<p>Branching is similar to jumping in that it changes where in the
program execution is currently taking place, however a condition is
first checked before performing the jump. If the condition is not met,
the program will continue execution as normal without jumping
anywhere.</p>
<p>The conditional jump instructions are as follows:</p>
<pre class="text"><code>+----------+----------------------------------+
| Mnemonic | Meaning                          |
+----------+----------------------------------+
| JEQ      | Jump if Equal                    |
| JNE      | Jump if not Equal                |
| JLT      | Jump if Less Than                |
| JLE      | Jump if Less Than or Equal To    |
| JGT      | Jump if Greater Than             |
| JGE      | Jump if Greater Than or Equal To |
+----------+----------------------------------+
| JZO      | Jump if Zero (=JEQ)              |
| JNZ      | Jump if not Zero (=JNE)          |
| JCA      | Jump if Carry (=JLT)             |
| JNC      | Jump if no Carry (=JGE)          |
+----------+----------------------------------+</code></pre>
<p>The top section of instructions should be performed following a
<code>CMP</code> instruction (explained in the section on comparing).
The bottom section are aliases of four of the mnemonics in the top
section (i.e. they share the same opcode) designed for use after
mathematical operations or for bit testing (explained more in the
relevant sections).</p>
<h3 id="comparing-numbers">Comparing Numbers</h3>
<p>One of the most common types of branch is checking how two numbers
relate to each other. This can be achieved with the <code>CMP</code>
instruction. It takes two operands (the first of which must be a
register — it won’t be modified), and compares them for use with a
conditional jump instruction immediately afterwards.</p>
<p>For example:</p>
<pre class="text"><code>RNG rg0  ; Set rg0 to a random number
CMP rg0, 1000  ; Compare rg0 to 1000
JGT :GREATER  ; Jump straight to GREATER if rg0 is greater than 1000
ADD rg0, 1000  ; This will execute only if rg0 is less than or equal to 1000
:GREATER
SUB rg0, 1000  ; This will execute in either situation</code></pre>
<p>Be aware that the <code>GREATER</code> label will still be reached if
<code>rg0</code> is less than or equal to <code>1000</code> here, the
<code>ADD</code> instruction will just be executed first.</p>
<p>To have the contents of the <code>GREATER</code> label execute
<strong>only</strong> if <code>rg0</code> is greater than
<code>1000</code>, include an unconditional jump like so:</p>
<pre class="text"><code>RNG rg0  ; Set rg0 to a random number
CMP rg0, 1000  ; Compare rg0 to 1000
JGT :GREATER  ; Jump straight to GREATER if rg0 is greater than 1000
ADD rg0, 1000  ; This will execute only if rg0 is less than or equal to 1000
JMP :END  ; Jump straight to END to prevent GREATER section being executed
:GREATER
SUB rg0, 1000  ; This will execute only if rg0 is greater than 1000
:END</code></pre>
<p>The <code>CMP</code> instruction works by subtracting the second
operand from the first, but not storing the result anywhere. This
operation still updates the status flags (<code>rsf</code>) however, and
these can be used to check how the numbers relate. For example, if the
second operand is greater than the first, you can guarantee that the
operation will set the carry flag, as it would cause the result to be
negative. This means to check if the first is greater than or equal to
the second, you can simply check if the carry flag was unset. To check
if the values were equal, the zero flag can be checked, as if the two
operands of a subtraction are equal, the result will always be zero.</p>
<p>A full list of what each conditional jump instruction is checking for
in terms of the status flags can be found in the full instruction
reference.</p>
<h3 id="testing-bits">Testing Bits</h3>
<p>To test if a single bit of a number is set or not, the
<code>TST</code> instruction can be used. Just like <code>CMP</code>, it
takes two operands, the first of which being a register. The second
should usually be a binary literal with only a single bit (the one to
check) set as 1. It should then be followed by either <code>JZO</code>
(jump if zero), or <code>JNZ</code> (jump if not zero). An example of
where this may be used is checking if the third bit of <code>rsf</code>
is set (the file end flag), as there isn’t a built-in conditional jump
that checks this flag.</p>
<p>This would be done like so:</p>
<pre class="text"><code>:READ
RFC rg0  ; Read the next byte from the open file to rg0
TST rsf, 0b100  ; Check if the third bit is set
JZO :READ  ; If it isn&#39;t set (i.e. it is equal to 0), jump back to READ</code></pre>
<p>This program will keep looping until the third bit of
<code>rsf</code> becomes <code>1</code>. meaning that the end of the
file has been reached.</p>
<p>Similarly to <code>CMP</code>, <code>TST</code> works by performing a
bitwise and on the two operands, discarding the result, but still
updating the status flags. A bitwise and will ensure that only the bit
you want to check remains as <code>1</code>, but only if it started as
<code>1</code>. If a bit is not one that you are checking, or it wasn’t
<code>1</code> to start with, it will end up as <code>0</code>. If the
resulting number isn’t zero, leaving the zero flag unset, the bit
must’ve been <code>1</code>, and vice versa.</p>
<h3 id="checking-for-a-carry-or-for-zero">Checking For a Carry or For
Zero</h3>
<p>As shown in the section on working around unsigned numbers, the carry
flags and zero flags can also be checked following a mathematical
operation.</p>
<p>To repeat that example:</p>
<pre class="text"><code>MVQ rg0, 5
SUB rg0, rg1  ; Assume rg1 has a value that could cause rg0 to be negative or positive
JNC :NOT_NEGATIVE  ; Jump to label if carry flag is unset
NOT rg0  ; This will only run if rg0 wrapped (setting carry flag)
ICR rg0
:NOT_NEGATIVE
; rg0 is now the absolute result</code></pre>
<p><code>JNC</code> here is checking if the carry flag is set or not
following the subtraction. The jump will only occur if the carry flag is
<code>0</code> (unset), otherwise, as with the other jump types,
execution will continue as normal. <code>JCA</code> can be used to
perform the inverse, jump only if the carry flag is set.</p>
<p>The zero flag checks can also be used following a mathematical
operation like so:</p>
<pre class="text"><code>SUB rg0, 7  ; Subtract 7 from rg0
JNZ :NOT_ZERO  ; Jump straight to NOT_ZERO if rg0 didn&#39;t become 0
ADD rg0, 1  ; Only execute this if rg0 became 0 because of the SUB operation
:NOT_ZERO</code></pre>
<p>The <code>ADD</code> instruction here will only execute if the
subtraction by 7 caused <code>rg0</code> to become exactly equal to
<code>0</code>.</p>
<h2 id="assembler-directives">Assembler Directives</h2>
<p>Assembler directives follow the same format as standard instructions,
however instead of being assembled to an opcode for the processor to
execute, they tell the assembler itself to do something to modify either
the final binary file or the lines of the source file as its being
assembled.</p>
<h3 id="pad-byte-padding"><code>PAD</code> — Byte Padding</h3>
<p>The <code>PAD</code> directive tells the assembler to insert a
certain number of <code>0</code> bytes wherever the directive is placed
in the file. This is most often used just after a label definition to
allocate a certain amount of guaranteed free and available memory to
store data.</p>
<p>For example, consider the following program:</p>
<pre class="text"><code>MVQ rg0, :&amp;PADDING  ; Store the address of the padding in rg0
JMP :PROGRAM  ; Jump to the next part of the program, skipping over the padding

:PADDING
PAD 16  ; Insert 16 empty bytes

:PROGRAM
MVQ *rg0, 765  ; Set the first 8 bytes of the padding to represent 765
ADD rg0, 8  ; Add 8 to rg0, it now points to the next number</code></pre>
<p>This program would assemble to the following bytes:</p>
<pre class="text"><code>99 06 13 00 00 00 00 00 00 00 02 23 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 9F 06 FD 02 00 00 00 00 00 00 11 06 08 00 00 00 00 00 00 00</code></pre>
<p>Which can be broken down to:</p>
<pre class="text"><code>Address | Bytes
--------+----------------------------------------------------
 0x00   | 99             | 06  | 13 00 00 00 00 00 00 00
        | MVQ (reg, lit) | rg0 | :PADDING (address 0x13)
--------+----------------------------------------------------
 0x0A   | 02  | 23 00 00 00 00 00 00 00
        | JMP | :PROGRAM (address 0x23)
--------+----------------------------------------------------
 0x13   | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
        | PAD 16
--------+----------------------------------------------------
 0x23   | 9F             | 06   | FD 02 00 00 00 00 00 00
        | MVQ (ptr, lit) | *rg0 | 765 (0x2FD)
--------+----------------------------------------------------
 0x2D   | 11  | 06  | 08 00 00 00 00 00 00 00
        | ADD | rg0 | 8</code></pre>
<p>Note that usually, to reduce the number of jumps required,
<code>PAD</code>s would be placed after all program instructions. It was
put in the middle of the program here for demonstration purposes.</p>
<h3 id="dat-byte-insertion"><code>DAT</code> — Byte Insertion</h3>
<p>The <code>DAT</code> directive inserts either a single byte, or a
string of UTF-8 character bytes, into a program wherever the directive
is located. As with <code>PAD</code>, it can be directly preceded by a
label definition to point to the byte or string of bytes. If not being
used with a string, <code>DAT</code> can only insert single bytes at
once, meaning the maximum value is 255. It is also not suitable for
inserting numbers to be used in 64-bit expecting operations (such as
maths and bitwise), see the following section on the <code>NUM</code>
directive for inserting 64-bit numbers.</p>
<p>An example of single byte insertion:</p>
<pre class="text"><code>MVB rg0, :BYTE  ; MVB must be used, as DAT will not insert a full 64-bit number
; rg0 is now 54
HLT  ; Stop the program executing into the DAT insertion (important!)

:BYTE
DAT 54  ; Insert a single 54 byte (0x36)</code></pre>
<p>This program assembles into the following bytes:</p>
<pre class="text"><code>82 06 0B 00 00 00 00 00 00 00 00 36</code></pre>
<p>Which can be broken down to:</p>
<pre class="text"><code>Address | Bytes
--------+----------------------------------------------------
 0x00   | 82             | 06  | 0B 00 00 00 00 00 00 00
        | MVB (reg, adr) | rg0 | :BYTE (address 0x0B)
--------+----------------------------------------------------
 0x0A   | 00
        | HLT
--------+----------------------------------------------------
 0x0B   | 36
        | DAT 54</code></pre>
<p>Or an example of using a string:</p>
<pre class="text"><code>MVQ rg0, :&amp;STRING  ; Move literal address of string to rg0
:STRING_LOOP
MVB rg1, *rg0  ; Move contents of address stored in rg0 to rg1
CMP rg1, 0  ; Check if rg1 is 0
JEQ :END  ; If it is, stop program
ICR rg0  ; Otherwise, increment source address by 1
WCC rg1  ; Write the read character to the console
JMP :STRING_LOOP  ; Loop back to print next character

:END
HLT  ; End execution to stop processor running into string data

:STRING
DAT &quot;Hello!\0&quot;  ; Store a string of character bytes after program data.
; Note that the string ends with &#39;\0&#39; (a 0 or &quot;null&quot; byte)</code></pre>
<p>This program will loop through the string, placing the byte value of
each character in <code>rg0</code> and writing it to the console, until
it reaches the 0 byte, when it will then stop to avoid looping
infinitely. While not a strict requirement, terminating a string with a
0 byte like this should always be done to give an easy way of knowing
when the end of a string has been reached. Placing a <code>DAT 0</code>
directive on the line after the string insertion will also achieve this
0 termination, and will result in the exact same bytes being assembled,
however using the <code>\0</code> escape sequence is more compact.
Escape sequences are explained after this example.</p>
<p>The example program assembles down to the following bytes:</p>
<pre class="text"><code>99 06 2E 00 00 00 00 00 00 00 83 07 06 75 07 00 00 00 00 00 00 00 00 04 2D 00 00 00 00 00 00 00 14 06 CC 07 02 0A 00 00 00 00 00 00 00 00 48 65 6C 6C 6F 21 00</code></pre>
<p>Which can be broken down to:</p>
<pre class="text"><code>Address | Bytes
--------+----------------------------------------------------
 0x00   | 99             | 06  | 2E 00 00 00 00 00 00 00
        | MVQ (reg, lit) | rg0 | :STRING (address 0x2E)
--------+----------------------------------------------------
 0x0A   | 83             | 07  | 06
        | MVB (reg, ptr) | rg1 | *rg0
--------+----------------------------------------------------
 0x0D   | 75             | 07  | 00 00 00 00 00 00 00 00
        | CMP (reg, lit) | rg1 | 0
--------+----------------------------------------------------
 0x17   | 04        | 2D 00 00 00 00 00 00 00
        | JEQ (adr) | :END (address 0x2D)
--------+----------------------------------------------------
 0x20   | 14        | 06
        | ICR (reg) | rg0
--------+----------------------------------------------------
 0x22   | CC        | 07
        | WCC (reg) | rg1
--------+----------------------------------------------------
 0x24   | 02        | 0A 00 00 00 00 00 00 00
        | JMP (adr) | :STRING_LOOP (address 0x0A)
--------+----------------------------------------------------
 0x2D   | 00
        | HLT
--------+----------------------------------------------------
 0x2E   | 48 65 6C 6C 6F 21 00
        | DAT &quot;Hello!\0&quot;</code></pre>
<h4 id="escape-sequences">Escape Sequences</h4>
<p>There are some sequences of characters that have special meanings
when found inside a string. Each of these begins with a backslash
(<code>\</code>) character and are used to insert characters into the
string that couldn’t be inserted normally. Every supported sequence is
as follows:</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 13%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th>Escape sequence</th>
<th>Character name</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>\"</code></td>
<td>Double quote</td>
<td>Used to insert a double quote into the string without causing the
string to end.</td>
</tr>
<tr class="even">
<td><code>\\</code></td>
<td>Backslash</td>
<td>In order for a string to contain a backslash, you must escape it so
it isn’t treated as the start of an escape sequence.</td>
</tr>
<tr class="odd">
<td><code>\0</code></td>
<td>Null</td>
<td>ASCII 0x00. Should be used to terminate every string.</td>
</tr>
<tr class="even">
<td><code>\a</code></td>
<td>Alert</td>
<td>ASCII 0x07.</td>
</tr>
<tr class="odd">
<td><code>\b</code></td>
<td>Backspace</td>
<td>ASCII 0x08.</td>
</tr>
<tr class="even">
<td><code>\f</code></td>
<td>Form feed</td>
<td>ASCII 0x0C.</td>
</tr>
<tr class="odd">
<td><code>\n</code></td>
<td>Newline</td>
<td>ASCII 0x0A. Will cause the string to move onto a new console/file
line when printed. Should be preceded by <code>\r</code> on
Windows.</td>
</tr>
<tr class="even">
<td><code>\r</code></td>
<td>Carriage return</td>
<td>ASCII 0x0D.</td>
</tr>
<tr class="odd">
<td><code>\t</code></td>
<td>Horizontal tab</td>
<td>ASCII 0x09.</td>
</tr>
<tr class="even">
<td><code>\v</code></td>
<td>Vertical tab</td>
<td>ASCII 0x0B.</td>
</tr>
<tr class="odd">
<td><code>\u....</code></td>
<td>Unicode codepoint (16-bit)</td>
<td>Inserts the unicode character with a codepoint represented by 4
hexadecimal digits in the range <code>0x0000</code> to
<code>0xFFFF</code>.</td>
</tr>
<tr class="even">
<td><code>\U........</code></td>
<td>Unicode codepoint (32-bit)</td>
<td>Inserts the unicode character with a codepoint represented by 8
hexadecimal digits in the range <code>0x00000000</code> to
<code>0x0010FFFF</code>, excluding <code>0x0000d800</code> to
<code>0x0000dfff</code>.</td>
</tr>
<tr class="odd">
<td><code>\'</code></td>
<td>Single quote</td>
<td>Included for future expansion. Not currently required - simply type
a <code>'</code> character instead.</td>
</tr>
</tbody>
</table>
<h3 id="num-number-insertion"><code>NUM</code> — Number Insertion</h3>
<p>The <code>NUM</code> directive is similar to <code>DAT</code>, except
it always inserts 8 bytes exactly, so can be used to represent 64-bit
numbers for use in instructions which always work on 64-bit values, like
maths and bitwise operations. <code>NUM</code> cannot be used to insert
strings, only single 64-bit integers.</p>
<p>An example:</p>
<pre class="text"><code>MVQ rg0, 115  ; Initialise rg0 to 15
ADD rg0, :NUMBER  ; Add the number stored in memory to rg0
; rg0 is now 100130
HLT  ; End execution to stop processor running into number data

:NUMBER
NUM 100_015  ; Insert the number 100015 with 8 bytes</code></pre>
<p>Which will produce the following bytes:</p>
<pre class="text"><code>99 06 73 00 00 00 00 00 00 00 12 06 15 00 00 00 00 00 00 00 00 AF 86 01 00 00 00 00 00</code></pre>
<p>Breaking down into:</p>
<pre class="text"><code>Address | Bytes
--------+----------------------------------------------------
 0x00   | 99             | 06  | 73 00 00 00 00 00 00 00
        | MVQ (reg, lit) | rg0 | 115 (0x73)
--------+----------------------------------------------------
 0x0A   | 12             | 06  | 15 00 00 00 00 00 00 00
        | ADD (reg, adr) | rg0 | :NUMBER (address 0x15)
--------+----------------------------------------------------
 0x14   | 00
        | HLT
--------+----------------------------------------------------
 0x15   | AF 86 01 00 00 00 00 00
        | NUM 100_015 (0x186AF)</code></pre>
<p>As with other operations in AssEmbly, <code>NUM</code> stores numbers
in memory using little endian encoding. See the section on moving with
memory for more info on how this encoding works.</p>
<h3 id="mac-macro-definition"><code>MAC</code> — Macro Definition</h3>
<p>The <code>MAC</code> directive defines a <strong>macro</strong>, a
piece of text that the assembler will replace with another on every line
where the text is present. The directive takes the text to replace as
the first operand, then the text for it to be replaced with as the
second. Macros only take effect on lines after the one where they are
defined, and they can be overwritten to change the replacement text by
defining a new macro with the same name as a previous one. Unlike other
instructions, the operands to the <code>MAC</code> directive don’t have
to be a standard valid format of operand, both will automatically be
interpreted as literal text.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, Number  ; Results in an error

MAC Number, 345
MVQ rg0, Number
; rg0 is now 345

MAC Number, 678
MVQ rg1, Number
; rg1 is now 678

MAC Inst, ICR rg1
Inst
; rg1 is now 679</code></pre>
<p>The first line here results in an error, as a macro with a name of
<code>Number</code> hasn’t been defined yet (macros don’t apply
retroactively). <code>MVQ rg0, Number</code> gets replaced with
<code>MVQ rg0, 345</code>, setting <code>rg0</code> to <code>345</code>.
<code>MVQ rg1, Number</code> gets replaced with
<code>MVQ rg1, 678</code>, as the <code>Number</code> macro was
redefined on the line before, setting <code>rg1</code> to
<code>678</code>. <code>Inst</code> gets replaced with
<code>ICR rg1</code>, incrementing <code>rg1</code> by <code>1</code>,
therefore setting it to <code>679</code> (macros can contain spaces and
can be used to give another name to mnemonics).</p>
<p>Note that macros cannot contain commas or unclosed quotes
(<code>"</code>), and surrounding whitespace will be ignored. They are
case sensitive, and macros with the same name but different
capitalisation can exist simultaneously.</p>
<h3 id="imp-file-importing"><code>IMP</code> — File Importing</h3>
<p>The <code>IMP</code> directive inserts the contents of another file
wherever the directive is placed. It allows a program to be split across
multiple files, as well as allowing code to be reused across multiple
source files without having to copy the code into each file. The
directive takes a single string operand (which must be enclosed in
quotes), which can either be a full path
(i.e. <code>Drive:\Folder\Folder\file.asm</code>) or a path relative to
the directory of the source file being assembled
(i.e. <code>file.asm</code>, <code>Folder\file.asm</code>, or
<code>..\Folder\file.asm</code>).</p>
<p>For example, suppose you had two files in the same folder, one called
<code>program.asm</code>, and one called <code>numbers.asm</code>.</p>
<p>Contents of <code>program.asm</code>:</p>
<pre class="text"><code>MVQ rg0, :NUMBER_ONE
MVQ rg1, :NUMBER_TWO
HLT  ; Prevent program executing into number data

IMP &quot;numbers.asm&quot;</code></pre>
<p>Contents of <code>numbers.asm</code>:</p>
<pre class="text"><code>:NUMBER_ONE
NUM 123

:NUMBER_TWO
NUM 456</code></pre>
<p>When <code>program.asm</code> is assembled, the assembler will open
and include the lines in <code>numbers.asm</code> once it reaches the
<code>IMP</code> directive, resulting in the file looking like so:</p>
<pre class="text"><code>MVQ rg0, :NUMBER_ONE
MVQ rg1, :NUMBER_TWO
HLT  ; Prevent program executing into number data

IMP &quot;numbers.asm&quot;
:NUMBER_ONE
NUM 123

:NUMBER_TWO
NUM 456</code></pre>
<p>Meaning that <code>rg0</code> will finish with a value of
<code>123</code>, and <code>rg1</code> will finish with a value of
<code>456</code>.</p>
<p>The <code>IMP</code> directive simply inserts the text contents of a
file into the current file for assembly. This means that any label names
in files being imported will be usable in the main file, though imposes
the added restriction that label names must be unique across the main
file and all its imported files.</p>
<p>Files given to the <code>IMP</code> directive <strong>must</strong>
be AssEmbly source files, not already assembled binaries. It is
recommended, though not a strict requirement, that import statements are
placed at the end of a file, as that will make it easier to ensure that
the imported contents of a file aren’t executed by mistake as part of
the main program.</p>
<p>Care should be taken to ensure that a file does not end up depending
on itself, even if it is through other files, as this will result in an
infinite loop of imports (also known as a circular dependency). The
AssEmbly assembler will detect these and throw an error should one
occur.</p>
<p>An example of a circular dependency:</p>
<p><code>file_one.asm</code>:</p>
<pre class="text"><code>IMP &quot;file_two.asm&quot;</code></pre>
<p><code>file_two.asm</code>:</p>
<pre class="text"><code>IMP &quot;file_three.asm&quot;</code></pre>
<p><code>file_three.asm</code>:</p>
<pre class="text"><code>IMP &quot;file_one.asm&quot;</code></pre>
<p>Attempting to assemble any of these three files would result in the
assembler throwing an error, as each file ends up depending on itself as
it resolves its import.</p>
<h3 id="analyzer-toggling-assembler-warnings"><code>ANALYZER</code> —
Toggling Assembler Warnings</h3>
<p>The AssEmbly assembler checks for common issues with your source code
when you assemble it in order to alert you of potential issues and
improvements that can be made. There may be some situations, however,
where you want to suppress these issues from being detected. This can be
done within the source code using the <code>ANALYZER</code> directive.
The directive takes three operands: the severity of the warning (either
<code>error</code>, <code>warning</code>, or <code>suggestion</code>);
the numerical code for the warning (this is a 4-digit number printed
alongside the message); and whether to enable (<code>1</code>), disable
(<code>0</code>) or restore the warning to its state as it was at the
beginning of assembly (<code>r</code>).</p>
<p>After using the directive, its effect remains active until assembly
ends, or the same warning is toggled again with the directive further on
in the code.</p>
<p>For example:</p>
<pre class="text"><code>CMP rg0, 0  ; generates suggestion 0005

ANALYZER suggestion, 0005, 0
CMP rg0, 0  ; generates no suggestion
CMP rg0, 0  ; still generates no suggestion
ANALYZER suggestion, 0005, 1  ; &#39;r&#39; would also work if the suggestion isn&#39;t disabled via a CLI argument

CMP rg0, 0  ; generates suggestion 0005 again</code></pre>
<p>Be aware that some analyzers do not run until the end of the assembly
process and so cannot be re-enabled without inadvertently causing the
warning to re-appear. This can be overcome by placing the disabling
<code>ANALYZER</code> directive at the end of the base file for any
analyzers where this behaviour is an issue, or by simply not re-enabling
the analyzer.</p>
<h2 id="console-input-and-output">Console Input and Output</h2>
<p>AssEmbly has native support for reading and writing from the console.
There are four types of write that can be performed: 64-bit number in
decimal; byte in decimal; byte in hexadecimal; and a raw byte
(character). There is only a single type of read: a single raw byte.
There is no native support for reading numbers in any base, nor is there
support for reading or writing multiple numbers/bytes at once.</p>
<p>Writing can be done from registers, literals, labels, and pointers;
reading must be done to a register. As with the move instructions, if a
byte write instruction is used on a register or literal, only the lowest
byte will be considered. If one is used on a label or a pointer, only a
single byte of memory will be read, as an opposed to the 8 bytes that
are read when writing a 64-bit number.</p>
<p>An example of each type of write:</p>
<pre class="text"><code>MVQ rg0, 0xFF0062

WCN rg0  ; Write a 64-bit number to the console in decimal
; &quot;16711778&quot; (0xFF0062) is written to the console

WCC 10  ; Write a newline character

WCB rg0  ; Write a single byte to the console in decimal
; &quot;98&quot; (0x62) is written to the console

WCC 10  ; Write a newline character

WCX rg0  ; Write a single byte to the console in hexadecimal
; &quot;62&quot; is written to the console

WCC 10  ; Write a newline character

WCC rg0  ; Write a single byte to the console as a character
; &quot;b&quot; (0x62) is written to the console

WCC 10  ; Write a newline character</code></pre>
<p>Keep in mind that newlines are not automatically written after each
write instruction, you will need to manually write the raw byte
<code>10</code> (a newline character) to start writing on a new line.
See the ASCII table at the end of the document for other common
character codes.</p>
<p>An example of reading a byte:</p>
<pre class="text"><code>RCC rg0  ; Read a byte from the console and save the byte code to rg0</code></pre>
<p>When an <code>RCC</code> instruction is reached, the program will
pause execution and wait for the user to input a character to the
console. Once a character has been inputted, the corresponding byte
value of the character will be copied to the given register. In this
example, if the user types a lowercase “b”, <code>0x62</code> would be
copied to <code>rg0</code>.</p>
<p>Be aware that if the user types a character that requires multiple
bytes to represent in UTF-8, <code>RCC</code> will still only retrieve a
single byte. You will have to use <code>RCC</code> multiple times to get
all of the bytes needed to represent the character. <code>WCC</code>
will also only write a single byte at a time, though as long as the
console has UTF-8 support, simply writing each UTF-8 byte one after the
other will result in the correct character being displayed.</p>
<p>Note that the user does not need to press enter after inputting a
character, execution will resume immediately after a single character is
typed. If you wish to wait for the user to press enter, compare the
inputted character to <code>10</code> (the code for a newline
character). The example program <code>input.ext.asm</code> contains a
subroutine which does this. The user pressing the enter key will always
give a single <code>10</code> byte, regardless of platform.</p>
<h2 id="file-handling">File Handling</h2>
<p>As well as interfacing with the console, AssEmbly also has native
support for handling files.</p>
<h3 id="opening-and-closing">Opening and Closing</h3>
<p>Files must be explicitly opened with the <code>OFL</code> instruction
before they can read or written to, and only one file can be open at a
time. You should close the currently open file with the <code>CFL</code>
instruction when you have finished operating on it.</p>
<p>Filepaths given to <code>OFL</code> to be opened should be strings of
UTF-8 character bytes in memory, ending with at least one <code>0</code>
byte. An example static filepath definition is as follows:</p>
<pre class="text"><code>:FILE_PATH
DAT &quot;file.txt\0&quot;</code></pre>
<p>This would normally be placed after all program code and a
<code>HLT</code> instruction to prevent it accidentally being executed
as if it were part of the program. The file can be opened with the
following line anywhere in the program:</p>
<pre class="text"><code>OFL :FILE_PATH
...
CFL</code></pre>
<p>You could also use a pointer if you wish:</p>
<pre class="text"><code>MVQ rg0, :&amp;FILE_PATH
OFL *rg0
...
CFL</code></pre>
<p><code>CFL</code> will close whatever file is currently open, so does
not require any operands. If a file at the specified path does not exist
when it is opened, an empty one will be created.</p>
<h3 id="reading-and-writing">Reading and Writing</h3>
<p>Reading and writing from files is almost identical to how it is done
from the console. Registers, literals, labels, and pointers can all be
written, and reading must be done to a register. When using byte writing
instructions, only the lower byte of registers and literals is
considered, and only a single byte of memory is read for labels and
pointers. An open file can be both read from and written to while it is
open, though changes written to the file will not be reflected in either
the current AssEmbly program or other applications until the file is
closed. If a file already has data in it when it is written to, the new
data will be <strong>appended to the end</strong>.</p>
<p>An example of writing to a file:</p>
<pre class="text"><code>MVQ rg0, 0xFF0062
OFL :FILE_PATH  ; Open file with the 0-terminated string at :FILE_PATH

WFN rg0  ; Write a 64-bit number to the file in decimal
; &quot;16711778&quot; (0xFF0062) is appended to the file

WFC 10  ; Write a newline character

WFB rg0  ; Write a single byte to the file in decimal
; &quot;98&quot; (0x62) is appended to the file

WFC 10  ; Write a newline character

WFX rg0  ; Write a single byte to the file in hexadecimal
; &quot;62&quot; is appended to the file

WFC 10  ; Write a newline character

WFC rg0  ; Write a single byte to the file as a character
; &quot;b&quot; (0x62) is appended to the file

WFC 10  ; Write a newline character
CFL  ; Close the file, saving newly written contents

HLT  ; Prevent executing into string data

:FILE_PATH
DAT &quot;file.txt\0&quot;</code></pre>
<p>Executing this program will create a file called
<code>file.txt</code> with the following contents:</p>
<pre class="text"><code>16711778
98
62
b
</code></pre>
<p>File contents can be read with the <code>RFC</code> instruction,
taking a single register as an operand. The next unread byte from the
file will be stored in the specified register. Text files are not
treated specially, <code>RFC</code> will simply retrieve the characters
1 byte at a time as they are encoded in the file. If the end of the file
has been reached after reading, the file end flag will be set to
<code>1</code>. The only way to reset the current reading position in a
file is to close and reopen the file.</p>
<p>To read all bytes until the end of a file, you will need to
continually read single bytes from the file, testing the file end flag
after every read, stopping as soon as it becomes set. The example
program <code>read_file.asm</code> has an example of this, as well as
this example from the bit testing section:</p>
<pre class="text"><code>:READ
RFC rg0  ; Read the next byte from the open file to rg0
TST rsf, 0b100  ; Check if the third bit is set
JZO :READ  ; If it isn&#39;t set (i.e. it is equal to 0), jump back to READ</code></pre>
<h3 id="other-operations">Other Operations</h3>
<p>As well as reading and writing, there are also instructions for
checking whether a file exists (<code>FEX</code>), getting the size of a
file (<code>FSZ</code>), and deleting a file (<code>DFL</code>). They
all take a path in the same way <code>OFL</code> does. <code>DFL</code>
has no effect other than deleting the file. <code>FEX</code> and
<code>FSZ</code> first take a register operand to store their result in,
then the path to the file as the second operand. <code>FEX</code> stores
<code>1</code> in the register if the file exists, <code>0</code> if
not. <code>FSZ</code> stores the total size of the file in bytes.</p>
<h2 id="the-stack">The Stack</h2>
<p>The stack is a section of memory most often used in conjunction with
subroutines, explained in the subsequent section. It starts at the very
end of available memory, and dynamically grows backwards as more items
are added (<strong>pushed</strong>) to it. The stack contains
exclusively 64-bit (8 byte) values. Registers, literals, labels, and
pointers can all be given as operands to the push (<code>PSH</code>)
instruction.</p>
<p>Once items have been pushed to the stack, they can be removed
(<strong>popped</strong>), starting at the most recently pushed item. As
with most other instructions with a destination, items from the stack
must be popped into registers with the <code>POP</code> instruction.
Once an item is removed from the stack, the effective size of the stack
shrinks back down, and the popped item will no longer be considered part
of the stack until and unless it is pushed again.</p>
<p>The <code>rso</code> register contains the address of the first byte
of the top item in the stack. Its value will get <strong>lower</strong>
as items are <strong>pushed</strong>, and <strong>greater</strong> as
items are <strong>popped</strong>. More info on the <code>rso</code>
register’s behaviour can be found in the registers section.</p>
<p>Take this visual example, assuming memory is 2046 bytes in size
(making 2045 the maximum address):</p>
<pre class="text"><code>; rso = 2046
; | Addresses |    2022..2029    |    2030..2037    |    2038..2045    ||
; |   Value   | ???????????????? | ???????????????? | ???????????????? ||

PSH 0xDEADBEEF  ; Push 0xDEADBEEF (3735928559) to the stack

; rso = 2038
; | Addresses |    2022..2029    |    2030..2037    ||    2038..2045    |
; |   Value   | ???????????????? | ???????????????? || 00000000EFBEADDE |

PSH 0xCAFEB0BA  ; Push 0xCAFEB0BA (3405689018) to the stack

; rso = 2030
; | Addresses |    2022..2029    ||    2030..2037    |    2038..2045    |
; |   Value   | ???????????????? || 00000000BAB0FECA | 00000000EFBEADDE |

PSH 0xD00D2BAD  ; Push 0xD00D2BAD (3490524077) to the stack

; rso = 2022
; | Addresses ||    2022..2029    |    2030..2037    |    2038..2045    |
; |   Value   || 00000000AD2B0DD0 | 00000000BAB0FECA | 00000000EFBEADDE |

POP rg0  ; Pop the most recent non-popped item from the stack into rg0

; rso = 2030
; | Addresses |    2022..2029    ||    2030..2037    |    2038..2045    |
; |   Value   | ???????????????? || 00000000BAB0FECA | 00000000EFBEADDE |
; rg0 = 0xD00D2BAD

POP rg0  ; Pop the most recent non-popped item from the stack into rg0

; rso = 2038
; | Addresses |    2022..2029    |    2030..2037    ||    2038..2045    |
; |   Value   | ???????????????? | ???????????????? || 00000000EFBEADDE |
; rg0 = 0xCAFEB0BA</code></pre>
<h3 id="using-the-stack-to-preserve-registers">Using the Stack to
Preserve Registers</h3>
<p>A common use of the stack is to store the value of a register, use
the register for a purpose that differs from its original one, then
restore the register to the stored value. This is particularly useful in
sections of reusable code (such as subroutines) where you cannot
guarantee whether a register will be in use or not.</p>
<p>An example of this is as follows:</p>
<pre class="text"><code>MVQ rg0, 45
ADD rg0, 20
; rg0 is 65

PSH rg0  ; Push the current value of rg0 to the stack
MVQ rg0, 200
MUL rg0, 10
; rg0 is 2000

POP rg0  ; Pop the old rg0 back into rg0
; rg0 is back to 65</code></pre>
<h2 id="subroutines">Subroutines</h2>
<p>A subroutine is a section of a program that can be specially jumped
to (<strong>called</strong>) from multiple different points in a
program. They differ from a standard jump in that the position in the
program that a subroutine is called from is stored automatically, so can
be <strong>returned</strong> to at any point with ease. This makes
reusing the same section of code across different parts of a program, or
even across different programs, much easier.</p>
<p>Subroutines are defined with a label as with any other form of jump
destination — to call one, use the <code>CAL</code> instruction with
either the label or a pointer to that label. Once you are within a
subroutine, you can return to the calling location with the
<code>RET</code> instruction, no operands required.</p>
<p>An example of a simple subroutine:</p>
<pre class="text"><code>MVQ rg0, 5
CAL :ADD_TO_RG0
; rg0 is now 15

MVQ rg1, :&amp;ADD_TO_RG0
MVQ rg0, 46
CAL *rg1
; rg0 is now 56

HLT

:ADD_TO_RG0
ADD rg0, 10
RET</code></pre>
<p>Specifically, <code>RET</code> will cause <code>rpo</code> to be
updated to the address storing the opcode directly after the
<code>CAL</code> instruction that was used to call the subroutine.
Unless they are halting the program, subroutines should always exit with
a <code>RET</code> instruction and nothing else.</p>
<h3 id="fast-calling">Fast Calling</h3>
<p>The <code>CAL</code> instruction can also take an optional second
operand: a value to pass to the subroutine. This is called <strong>fast
calling</strong> or <strong>fast passing</strong>; the passed value gets
stored in <code>rfp</code> and can be any one of a register, literal,
label, or pointer. More info on the behaviour of the register itself and
how it should be used can be found in its part of the registers section.
Parameters are always 64-bit values, so when passing a label or a
register, 8 bytes of memory will always be read.</p>
<p>An example of subroutines utilising fast calling:</p>
<pre class="text"><code>:SUBROUTINE_ONE
ADD rfp, 1
MVQ rg0, rfp
RET

:SUBROUTINE_TWO
ADD rfp, 2
MVQ rg0, rfp
RET

CAL :SUBROUTINE_ONE, 4  ; This will implicitly set rfp to 4
; rg0 is now 5
CAL :SUBROUTINE_TWO, 6  ; This will implicitly set rfp to 6
; rg0 is now 8</code></pre>
<h3 id="return-values">Return Values</h3>
<p>The <code>RET</code> instruction can also take an optional operand to
return a value. Return values can be registers, literals, labels, or
pointers, and are stored in <code>rrv</code>. As with fast pass
parameters, return values are always 64-bits/8 bytes. The exact
behaviour and usage of the register can be found in its part of the
registers section.</p>
<p>Here is the above example for fast calling adapted to use return
values:</p>
<pre class="text"><code>:SUBROUTINE_ONE
ADD rfp, 1
RET rfp  ; Return, setting rrv to the value of rfp

:SUBROUTINE_TWO
ADD rfp, 2
RET rfp  ; Return, setting rrv to the value of rfp

CAL :SUBROUTINE_ONE, 4
; rrv is now 5
CAL :SUBROUTINE_TWO, 6
; rrv is now 8</code></pre>
<h3 id="subroutines-and-the-stack">Subroutines and the Stack</h3>
<p>In order to store the address to return to when using subroutines,
the stack is utilised. Every time the <code>CAL</code> instruction is
used, the address of the next opcode, the current value of
<code>rsb</code>, and the current value of <code>rso</code> are pushed
to the stack in that order. <code>rsb</code> and <code>rso</code> will
then be updated to the new address of the top of the stack (the address
where <code>rso</code> was pushed to). <code>rsb</code> will continue to
point here (the <strong>base</strong>) until another subroutine is
called or the subroutine is returned from. <code>rso</code> will
continue to update as normal as items are popped to and pushed from the
stack, always pointing to the top of it. The area from the current
<strong>base</strong> (<code>rsb</code>) to the top of the stack
(<code>rso</code>) is called the current <strong>stack frame</strong>.
Multiple stack frames can be stacked on top of each other if a
subroutine is called from another subroutine.</p>
<p>When returning from a subroutine, the opposite is performed.
<code>rso</code>, <code>rsb</code>, and <code>rpo</code> are popped off
the top of the stack, thereby continuing execution as it was before the
subroutine was called. It is important that all values apart from these
three are popped off the stack prior to using the <code>RET</code>
instruction (you can ensure this by moving the value of <code>rsb</code>
into <code>rso</code>).</p>
<p>If you utilise registers in a subroutine, you should use the stack to
ensure that the value of each modified register is returned to its
initial value before returning from the subroutine. See the above
section on using the stack to preserve registers for info on how to do
this.</p>
<h3 id="passing-multiple-parameters">Passing Multiple Parameters</h3>
<p>The <code>CAL</code> instruction can only take a single parameter,
however there may be situations where multiple values need to be passed
to a subroutine; it is best to use the stack in situations such as
these. Before calling the subroutine, push any values you want to act as
parameters to the subroutine, to the stack. Once the subroutine has been
called, you can use <code>rsb</code> to calculate the address that each
parameter will be stored at. To access the first parameter (the last one
pushed before calling), you need to account for the three automatically
pushed values first. These, along with every other value in the stack,
are all 8 bytes long, so adding <code>24</code> (<code>8 * 3</code>) to
<code>rsb</code> will get you the address of this parameter (you should
do this in another register, <code>rsb</code> should be left
unmodified). To access any subsequent parameters, simply add another
<code>8</code> on top of this.</p>
<p>For example:</p>
<pre class="text"><code>PSH 4  ; Parameter D
PSH 3  ; Parameter C
PSH 2  ; Parameter B
CAL :SUBROUTINE, 1  ; Parameter A (rfp)
; rrv is now 10

:SUBROUTINE
PSH rg0  ; Preserve the value of rg0

MVQ rg0, rsb
ADD rg0, 24  ; Parameter B
ADD rfp, *rg0
; rfp is now 3
ADD rg0, 8  ; Parameter C
ADD rfp, *rg0
; rfp is now 6
ADD rg0, 8  ; Parameter D
ADD rfp, *rg0
; rfp is now 10

POP rg0  ; Restore rg0 to its original value
RET rfp</code></pre>
<h2 id="text-encoding">Text Encoding</h2>
<p>All text in AssEmbly (input from/output to the console; strings
inserted by <code>DAT</code>; strings given to <code>OFL</code>,
<code>DFL</code>, <code>FEX</code>, etc) is encoded in UTF-8. This means
that all characters that are a part of the ASCII character set only take
up a single byte, though some characters may take as many as 4 bytes to
store fully.</p>
<p>Be aware that when working with characters that require multiple
bytes, instructions like <code>RCC</code>, <code>RFC</code>,
<code>WCC</code>, and <code>WFC</code> still only work on single bytes
at a time. As long as you read/write all of the UTF-8 bytes in the
correct order, they should be stored and displayed correctly.</p>
<p>Text bytes read from files <strong>will not</strong> be automatically
converted to UTF-8 if the file was saved with another encoding.</p>
<h2 id="full-instruction-reference">Full Instruction Reference</h2>
<table style="width:100%;">
<colgroup>
<col style="width: 6%" />
<col style="width: 23%" />
<col style="width: 13%" />
<col style="width: 52%" />
<col style="width: 3%" />
</colgroup>
<thead>
<tr class="header">
<th>Mnemonic</th>
<th>Full Name</th>
<th>Operands</th>
<th>Function</th>
<th>Opcode</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Control</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>HLT</code></td>
<td>Halt</td>
<td>-</td>
<td>Stops the processor from executing the program</td>
<td><code>0x00</code></td>
</tr>
<tr class="odd">
<td><code>NOP</code></td>
<td>No Operation</td>
<td>-</td>
<td>Do nothing</td>
<td><code>0x01</code></td>
</tr>
<tr class="even">
<td><strong>Jumping</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>JMP</code></td>
<td>Jump</td>
<td>Address</td>
<td>Jump unconditionally to an address in a label</td>
<td><code>0x02</code></td>
</tr>
<tr class="even">
<td><code>JMP</code></td>
<td>Jump</td>
<td>Pointer</td>
<td>Jump unconditionally to an address in a register</td>
<td><code>0x03</code></td>
</tr>
<tr class="odd">
<td><code>JEQ</code> / <code>JZO</code></td>
<td>Jump if Equal / Jump if Zero</td>
<td>Address</td>
<td>Jump to an address in a label only if the zero status flag is
set</td>
<td><code>0x04</code></td>
</tr>
<tr class="even">
<td><code>JEQ</code> / <code>JZO</code></td>
<td>Jump if Equal / Jump if Zero</td>
<td>Pointer</td>
<td>Jump to an address in a register only if the zero status flag is
set</td>
<td><code>0x05</code></td>
</tr>
<tr class="odd">
<td><code>JNE</code> / <code>JNZ</code></td>
<td>Jump if not Equal / Jump if not Zero</td>
<td>Address</td>
<td>Jump to an address in a label only if the zero status flag is
unset</td>
<td><code>0x06</code></td>
</tr>
<tr class="even">
<td><code>JNE</code> / <code>JNZ</code></td>
<td>Jump if not Equal / Jump if not Zero</td>
<td>Pointer</td>
<td>Jump to an address in a register only if the zero status flag is
unset</td>
<td><code>0x07</code></td>
</tr>
<tr class="odd">
<td><code>JLT</code> / <code>JCA</code></td>
<td>Jump if Less Than / Jump if Carry</td>
<td>Address</td>
<td>Jump to an address in a label only if the carry status flag is
set</td>
<td><code>0x08</code></td>
</tr>
<tr class="even">
<td><code>JLT</code> / <code>JCA</code></td>
<td>Jump if Less Than / Jump if Carry</td>
<td>Pointer</td>
<td>Jump to an address in a register only if the carry status flag is
set</td>
<td><code>0x09</code></td>
</tr>
<tr class="odd">
<td><code>JLE</code></td>
<td>Jump if Less Than or Equal To</td>
<td>Address</td>
<td>Jump to an address in a label only if either the carry or zero flags
are set</td>
<td><code>0x0A</code></td>
</tr>
<tr class="even">
<td><code>JLE</code></td>
<td>Jump if Less Than or Equal To</td>
<td>Pointer</td>
<td>Jump to an address in a register only if either the carry or zero
flags are set</td>
<td><code>0x0B</code></td>
</tr>
<tr class="odd">
<td><code>JGT</code></td>
<td>Jump if Greater Than</td>
<td>Address</td>
<td>Jump to an address in a label only if both the carry and zero flags
are unset</td>
<td><code>0x0C</code></td>
</tr>
<tr class="even">
<td><code>JGT</code></td>
<td>Jump if Greater Than</td>
<td>Pointer</td>
<td>Jump to an address in a register only if both the carry and zero
flags are unset</td>
<td><code>0x0D</code></td>
</tr>
<tr class="odd">
<td><code>JGE</code> / <code>JNC</code></td>
<td>Jump if Greater Than or Equal To / Jump if no Carry</td>
<td>Address</td>
<td>Jump to an address in a label only if the carry status flag is
unset</td>
<td><code>0x0E</code></td>
</tr>
<tr class="even">
<td><code>JGE</code> / <code>JNC</code></td>
<td>Jump if Greater Than or Equal To / Jump if no Carry</td>
<td>Pointer</td>
<td>Jump to an address in a register only if the carry status flag is
unset</td>
<td><code>0x0F</code></td>
</tr>
<tr class="odd">
<td><strong>Math</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>ADD</code></td>
<td>Add</td>
<td>Register, Register</td>
<td>Add the contents of one register to another</td>
<td><code>0x10</code></td>
</tr>
<tr class="odd">
<td><code>ADD</code></td>
<td>Add</td>
<td>Register, Literal</td>
<td>Add a literal value to the contents of a register</td>
<td><code>0x11</code></td>
</tr>
<tr class="even">
<td><code>ADD</code></td>
<td>Add</td>
<td>Register, Address</td>
<td>Add the contents of memory at an address in a label to a
register</td>
<td><code>0x12</code></td>
</tr>
<tr class="odd">
<td><code>ADD</code></td>
<td>Add</td>
<td>Register, Pointer</td>
<td>Add the contents of memory at an address in a register to a
register</td>
<td><code>0x13</code></td>
</tr>
<tr class="even">
<td><code>ICR</code></td>
<td>Increment</td>
<td>Register</td>
<td>Increment the contents of a register by 1</td>
<td><code>0x14</code></td>
</tr>
<tr class="odd">
<td><code>SUB</code></td>
<td>Subtract</td>
<td>Register, Register</td>
<td>Subtract the contents of one register from another</td>
<td><code>0x20</code></td>
</tr>
<tr class="even">
<td><code>SUB</code></td>
<td>Subtract</td>
<td>Register, Literal</td>
<td>Subtract a literal value from the contents of a register</td>
<td><code>0x21</code></td>
</tr>
<tr class="odd">
<td><code>SUB</code></td>
<td>Subtract</td>
<td>Register, Address</td>
<td>Subtract the contents of memory at an address in a label from a
register</td>
<td><code>0x22</code></td>
</tr>
<tr class="even">
<td><code>SUB</code></td>
<td>Subtract</td>
<td>Register, Pointer</td>
<td>Subtract the contents of memory at an address in a register from a
register</td>
<td><code>0x23</code></td>
</tr>
<tr class="odd">
<td><code>DCR</code></td>
<td>Decrement</td>
<td>Register</td>
<td>Decrement the contents of a register by 1</td>
<td><code>0x24</code></td>
</tr>
<tr class="even">
<td><code>MUL</code></td>
<td>Multiply</td>
<td>Register, Register</td>
<td>Multiply the contents of one register by another</td>
<td><code>0x30</code></td>
</tr>
<tr class="odd">
<td><code>MUL</code></td>
<td>Multiply</td>
<td>Register, Literal</td>
<td>Multiply the contents of a register by a literal value</td>
<td><code>0x31</code></td>
</tr>
<tr class="even">
<td><code>MUL</code></td>
<td>Multiply</td>
<td>Register, Address</td>
<td>Multiply a register by the contents of memory at an address in a
label</td>
<td><code>0x32</code></td>
</tr>
<tr class="odd">
<td><code>MUL</code></td>
<td>Multiply</td>
<td>Register, Pointer</td>
<td>Multiply a register by the contents of memory at an address in a
register</td>
<td><code>0x33</code></td>
</tr>
<tr class="even">
<td><code>DIV</code></td>
<td>Integer Divide</td>
<td>Register, Register</td>
<td>Divide the contents of one register by another, discarding the
remainder</td>
<td><code>0x40</code></td>
</tr>
<tr class="odd">
<td><code>DIV</code></td>
<td>Integer Divide</td>
<td>Register, Literal</td>
<td>Divide the contents of a register by a literal value, discarding the
remainder</td>
<td><code>0x41</code></td>
</tr>
<tr class="even">
<td><code>DIV</code></td>
<td>Integer Divide</td>
<td>Register, Address</td>
<td>Divide a register by the contents of memory at an address in a
label, discarding the remainder</td>
<td><code>0x42</code></td>
</tr>
<tr class="odd">
<td><code>DIV</code></td>
<td>Integer Divide</td>
<td>Register, Pointer</td>
<td>Divide a register by the contents of memory at an address in a
register, discarding the remainder</td>
<td><code>0x43</code></td>
</tr>
<tr class="even">
<td><code>DVR</code></td>
<td>Divide With Remainder</td>
<td>Register, Register, Register</td>
<td>Divide the contents of one register by another, storing the
remainder</td>
<td><code>0x44</code></td>
</tr>
<tr class="odd">
<td><code>DVR</code></td>
<td>Divide With Remainder</td>
<td>Register, Register, Literal</td>
<td>Divide the contents of a register by a literal value, storing the
remainder</td>
<td><code>0x45</code></td>
</tr>
<tr class="even">
<td><code>DVR</code></td>
<td>Divide With Remainder</td>
<td>Register, Register, Address</td>
<td>Divide a register by the contents of memory at an address in a
label, storing the remainder</td>
<td><code>0x46</code></td>
</tr>
<tr class="odd">
<td><code>DVR</code></td>
<td>Divide With Remainder</td>
<td>Register, Register, Pointer</td>
<td>Divide a register by the contents of memory at an address in a
register, storing the remainder</td>
<td><code>0x47</code></td>
</tr>
<tr class="even">
<td><code>REM</code></td>
<td>Remainder Only</td>
<td>Register, Register</td>
<td>Divide the contents of one register by another, storing only the
remainder</td>
<td><code>0x48</code></td>
</tr>
<tr class="odd">
<td><code>REM</code></td>
<td>Remainder Only</td>
<td>Register, Literal</td>
<td>Divide the contents of a register by a literal value, storing only
the remainder</td>
<td><code>0x49</code></td>
</tr>
<tr class="even">
<td><code>REM</code></td>
<td>Remainder Only</td>
<td>Register, Address</td>
<td>Divide a register by the contents of memory at an address in a
label, storing only the remainder</td>
<td><code>0x4A</code></td>
</tr>
<tr class="odd">
<td><code>REM</code></td>
<td>Remainder Only</td>
<td>Register, Pointer</td>
<td>Divide a register by the contents of memory at an address in a
register, storing only the remainder</td>
<td><code>0x4B</code></td>
</tr>
<tr class="even">
<td><code>SHL</code></td>
<td>Shift Left</td>
<td>Register, Register</td>
<td>Shift the bits of one register left by another register</td>
<td><code>0x50</code></td>
</tr>
<tr class="odd">
<td><code>SHL</code></td>
<td>Shift Left</td>
<td>Register, Literal</td>
<td>Shift the bits of a register left by a literal value</td>
<td><code>0x51</code></td>
</tr>
<tr class="even">
<td><code>SHL</code></td>
<td>Shift Left</td>
<td>Register, Address</td>
<td>Shift the bits of a register left by the contents of memory at an
address in a label</td>
<td><code>0x52</code></td>
</tr>
<tr class="odd">
<td><code>SHL</code></td>
<td>Shift Left</td>
<td>Register, Pointer</td>
<td>Shift the bits of a register left by the contents of memory at an
address in a register</td>
<td><code>0x53</code></td>
</tr>
<tr class="even">
<td><code>SHR</code></td>
<td>Shift Right</td>
<td>Register, Register</td>
<td>Shift the bits of one register right by another register</td>
<td><code>0x54</code></td>
</tr>
<tr class="odd">
<td><code>SHR</code></td>
<td>Shift Right</td>
<td>Register, Literal</td>
<td>Shift the bits of a register right by a literal value</td>
<td><code>0x55</code></td>
</tr>
<tr class="even">
<td><code>SHR</code></td>
<td>Shift Right</td>
<td>Register, Address</td>
<td>Shift the bits of a register right by the contents of memory at an
address in a label</td>
<td><code>0x56</code></td>
</tr>
<tr class="odd">
<td><code>SHR</code></td>
<td>Shift Right</td>
<td>Register, Pointer</td>
<td>Shift the bits of a register right by the contents of memory at an
address in a register</td>
<td><code>0x57</code></td>
</tr>
<tr class="even">
<td><strong>Bitwise</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>AND</code></td>
<td>Bitwise And</td>
<td>Register, Register</td>
<td>Bitwise and one register by another</td>
<td><code>0x60</code></td>
</tr>
<tr class="even">
<td><code>AND</code></td>
<td>Bitwise And</td>
<td>Register, Literal</td>
<td>Bitwise and a register by a literal value</td>
<td><code>0x61</code></td>
</tr>
<tr class="odd">
<td><code>AND</code></td>
<td>Bitwise And</td>
<td>Register, Address</td>
<td>Bitwise and a register by the contents of memory at an address in a
label</td>
<td><code>0x62</code></td>
</tr>
<tr class="even">
<td><code>AND</code></td>
<td>Bitwise And</td>
<td>Register, Pointer</td>
<td>Bitwise and a register by the contents of memory at an address in a
register</td>
<td><code>0x63</code></td>
</tr>
<tr class="odd">
<td><code>ORR</code></td>
<td>Bitwise Or</td>
<td>Register, Register</td>
<td>Bitwise or one register by another</td>
<td><code>0x64</code></td>
</tr>
<tr class="even">
<td><code>ORR</code></td>
<td>Bitwise Or</td>
<td>Register, Literal</td>
<td>Bitwise or a register by a literal value</td>
<td><code>0x65</code></td>
</tr>
<tr class="odd">
<td><code>ORR</code></td>
<td>Bitwise Or</td>
<td>Register, Address</td>
<td>Bitwise or a register by the contents of memory at an address in a
label</td>
<td><code>0x66</code></td>
</tr>
<tr class="even">
<td><code>ORR</code></td>
<td>Bitwise Or</td>
<td>Register, Pointer</td>
<td>Bitwise or a register by the contents of memory at an address in a
register</td>
<td><code>0x67</code></td>
</tr>
<tr class="odd">
<td><code>XOR</code></td>
<td>Bitwise Exclusive Or</td>
<td>Register, Register</td>
<td>Bitwise exclusive or one register by another</td>
<td><code>0x68</code></td>
</tr>
<tr class="even">
<td><code>XOR</code></td>
<td>Bitwise Exclusive Or</td>
<td>Register, Literal</td>
<td>Bitwise exclusive or a register by a literal value</td>
<td><code>0x69</code></td>
</tr>
<tr class="odd">
<td><code>XOR</code></td>
<td>Bitwise Exclusive Or</td>
<td>Register, Address</td>
<td>Bitwise exclusive or a register by the contents of memory at an
address in a label</td>
<td><code>0x6A</code></td>
</tr>
<tr class="even">
<td><code>XOR</code></td>
<td>Bitwise Exclusive Or</td>
<td>Register, Pointer</td>
<td>Bitwise exclusive or a register by the contents of memory at an
address in a register</td>
<td><code>0x6B</code></td>
</tr>
<tr class="odd">
<td><code>NOT</code></td>
<td>Bitwise Not</td>
<td>Register</td>
<td>Invert each bit of a register</td>
<td><code>0x6C</code></td>
</tr>
<tr class="even">
<td><code>RNG</code></td>
<td>Random Number Generator</td>
<td>Register</td>
<td>Randomise each bit of a register</td>
<td><code>0x6D</code></td>
</tr>
<tr class="odd">
<td><strong>Comparison</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>TST</code></td>
<td>Test</td>
<td>Register, Register</td>
<td>Bitwise and two registers, discarding the result whilst still
updating status flags</td>
<td><code>0x70</code></td>
</tr>
<tr class="odd">
<td><code>TST</code></td>
<td>Test</td>
<td>Register, Literal</td>
<td>Bitwise and a register and a literal value, discarding the result
whilst still updating status flags</td>
<td><code>0x71</code></td>
</tr>
<tr class="even">
<td><code>TST</code></td>
<td>Test</td>
<td>Register, Address</td>
<td>Bitwise and a register and the contents of memory at an address in a
label, discarding the result</td>
<td><code>0x72</code></td>
</tr>
<tr class="odd">
<td><code>TST</code></td>
<td>Test</td>
<td>Register, Pointer</td>
<td>Bitwise and a register and the contents of memory at an address in a
register, discarding the result</td>
<td><code>0x73</code></td>
</tr>
<tr class="even">
<td><code>CMP</code></td>
<td>Compare</td>
<td>Register, Register</td>
<td>Subtract a register from another, discarding the result whilst still
updating status flags</td>
<td><code>0x74</code></td>
</tr>
<tr class="odd">
<td><code>CMP</code></td>
<td>Compare</td>
<td>Register, Literal</td>
<td>Subtract a literal value from a register, discarding the result
whilst still updating status flags</td>
<td><code>0x75</code></td>
</tr>
<tr class="even">
<td><code>CMP</code></td>
<td>Compare</td>
<td>Register, Address</td>
<td>Subtract the contents of memory at an address in a label from a
register, discarding the result</td>
<td><code>0x76</code></td>
</tr>
<tr class="odd">
<td><code>CMP</code></td>
<td>Compare</td>
<td>Register, Pointer</td>
<td>Subtract the contents of memory at an address in a register from a
register, discarding the result</td>
<td><code>0x77</code></td>
</tr>
<tr class="even">
<td><strong>Data Moving</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>MVB</code></td>
<td>Move Byte</td>
<td>Register, Register</td>
<td>Move the lower 8-bits of one register to another</td>
<td><code>0x80</code></td>
</tr>
<tr class="even">
<td><code>MVB</code></td>
<td>Move Byte</td>
<td>Register, Literal</td>
<td>Move the lower 8-bits of a literal value to a register</td>
<td><code>0x81</code></td>
</tr>
<tr class="odd">
<td><code>MVB</code></td>
<td>Move Byte</td>
<td>Register, Address</td>
<td>Move 8-bits of the contents of memory starting at an address in a
label to a register</td>
<td><code>0x82</code></td>
</tr>
<tr class="even">
<td><code>MVB</code></td>
<td>Move Byte</td>
<td>Register, Pointer</td>
<td>Move 8-bits of the contents of memory starting at an address in a
register to a register</td>
<td><code>0x83</code></td>
</tr>
<tr class="odd">
<td><code>MVB</code></td>
<td>Move Byte</td>
<td>Address, Register</td>
<td>Move the lower 8-bits of a register to the contents of memory at an
address in a label</td>
<td><code>0x84</code></td>
</tr>
<tr class="even">
<td><code>MVB</code></td>
<td>Move Byte</td>
<td>Address, Literal</td>
<td>Move the lower 8-bits of a literal to the contents of memory at an
address in a label</td>
<td><code>0x85</code></td>
</tr>
<tr class="odd">
<td><code>MVB</code></td>
<td>Move Byte</td>
<td>Pointer, Register</td>
<td>Move the lower 8-bits of a register to the contents of memory at an
address in a register</td>
<td><code>0x86</code></td>
</tr>
<tr class="even">
<td><code>MVB</code></td>
<td>Move Byte</td>
<td>Pointer, Literal</td>
<td>Move the lower 8-bits of a literal to the contents of memory at an
address in a register</td>
<td><code>0x87</code></td>
</tr>
<tr class="odd">
<td><code>MVW</code></td>
<td>Move Word</td>
<td>Register, Register</td>
<td>Move the lower 16-bits (2 bytes) of one register to another</td>
<td><code>0x88</code></td>
</tr>
<tr class="even">
<td><code>MVW</code></td>
<td>Move Word</td>
<td>Register, Literal</td>
<td>Move the lower 16-bits (2 bytes) of a literal value to a
register</td>
<td><code>0x89</code></td>
</tr>
<tr class="odd">
<td><code>MVW</code></td>
<td>Move Word</td>
<td>Register, Address</td>
<td>Move 16-bits (2 bytes) of the contents of memory starting at an
address in a label to a register</td>
<td><code>0x8A</code></td>
</tr>
<tr class="even">
<td><code>MVW</code></td>
<td>Move Word</td>
<td>Register, Pointer</td>
<td>Move 16-bits (2 bytes) of the contents of memory starting at an
address in a register to a register</td>
<td><code>0x8B</code></td>
</tr>
<tr class="odd">
<td><code>MVW</code></td>
<td>Move Word</td>
<td>Address, Register</td>
<td>Move the lower 16-bits (2 bytes) of a register to the contents of
memory at an address in a label</td>
<td><code>0x8C</code></td>
</tr>
<tr class="even">
<td><code>MVW</code></td>
<td>Move Word</td>
<td>Address, Literal</td>
<td>Move the lower 16-bits (2 bytes) of a literal to the contents of
memory at an address in a label</td>
<td><code>0x8D</code></td>
</tr>
<tr class="odd">
<td><code>MVW</code></td>
<td>Move Word</td>
<td>Pointer, Register</td>
<td>Move the lower 16-bits (2 bytes) of a register to the contents of
memory at an address in a register</td>
<td><code>0x8E</code></td>
</tr>
<tr class="even">
<td><code>MVW</code></td>
<td>Move Word</td>
<td>Pointer, Literal</td>
<td>Move the lower 16-bits (2 bytes) of a literal to the contents of
memory at an address in a register</td>
<td><code>0x8F</code></td>
</tr>
<tr class="odd">
<td><code>MVD</code></td>
<td>Move Double Word</td>
<td>Register, Register</td>
<td>Move the lower 32-bits (4 bytes) of one register to another</td>
<td><code>0x90</code></td>
</tr>
<tr class="even">
<td><code>MVD</code></td>
<td>Move Double Word</td>
<td>Register, Literal</td>
<td>Move the lower 32-bits (4 bytes) of a literal value to a
register</td>
<td><code>0x91</code></td>
</tr>
<tr class="odd">
<td><code>MVD</code></td>
<td>Move Double Word</td>
<td>Register, Address</td>
<td>Move 32-bits (4 bytes) of the contents of memory starting at an
address in a label to a register</td>
<td><code>0x92</code></td>
</tr>
<tr class="even">
<td><code>MVD</code></td>
<td>Move Double Word</td>
<td>Register, Pointer</td>
<td>Move 32-bits (4 bytes) of the contents of memory starting at an
address in a register to a register</td>
<td><code>0x93</code></td>
</tr>
<tr class="odd">
<td><code>MVD</code></td>
<td>Move Double Word</td>
<td>Address, Register</td>
<td>Move the lower 32-bits (4 bytes) of a register to the contents of
memory at an address in a label</td>
<td><code>0x94</code></td>
</tr>
<tr class="even">
<td><code>MVD</code></td>
<td>Move Double Word</td>
<td>Address, Literal</td>
<td>Move the lower 32-bits (4 bytes) of a literal to the contents of
memory at an address in a label</td>
<td><code>0x95</code></td>
</tr>
<tr class="odd">
<td><code>MVD</code></td>
<td>Move Double Word</td>
<td>Pointer, Register</td>
<td>Move the lower 32-bits (4 bytes) of a register to the contents of
memory at an address in a register</td>
<td><code>0x96</code></td>
</tr>
<tr class="even">
<td><code>MVD</code></td>
<td>Move Double Word</td>
<td>Pointer, Literal</td>
<td>Move the lower 32-bits (4 bytes) of a literal to the contents of
memory at an address in a register</td>
<td><code>0x97</code></td>
</tr>
<tr class="odd">
<td><code>MVQ</code></td>
<td>Move Quad Word</td>
<td>Register, Register</td>
<td>Move all 64-bits (8 bytes) of one register to another</td>
<td><code>0x98</code></td>
</tr>
<tr class="even">
<td><code>MVQ</code></td>
<td>Move Quad Word</td>
<td>Register, Literal</td>
<td>Move all 64-bits (8 bytes) of a literal value to a register</td>
<td><code>0x99</code></td>
</tr>
<tr class="odd">
<td><code>MVQ</code></td>
<td>Move Quad Word</td>
<td>Register, Address</td>
<td>Move 64-bits (8 bytes) of the contents of memory starting at an
address in a label to a register</td>
<td><code>0x9A</code></td>
</tr>
<tr class="even">
<td><code>MVQ</code></td>
<td>Move Quad Word</td>
<td>Register, Pointer</td>
<td>Move 64-bits (8 bytes) of the contents of memory starting at an
address in a register to a register</td>
<td><code>0x9B</code></td>
</tr>
<tr class="odd">
<td><code>MVQ</code></td>
<td>Move Quad Word</td>
<td>Address, Register</td>
<td>Move all 64-bits (8 bytes) of a register to the contents of memory
at an address in a label</td>
<td><code>0x9C</code></td>
</tr>
<tr class="even">
<td><code>MVQ</code></td>
<td>Move Quad Word</td>
<td>Address, Literal</td>
<td>Move all 64-bits (8 bytes) of a literal to the contents of memory at
an address in a label</td>
<td><code>0x9D</code></td>
</tr>
<tr class="odd">
<td><code>MVQ</code></td>
<td>Move Quad Word</td>
<td>Pointer, Register</td>
<td>Move all 64-bits (8 bytes) of a register to the contents of memory
at an address in a register</td>
<td><code>0x9E</code></td>
</tr>
<tr class="even">
<td><code>MVQ</code></td>
<td>Move Quad Word</td>
<td>Pointer, Literal</td>
<td>Move all 64-bits (8 bytes) of a literal to the contents of memory at
an address in a register</td>
<td><code>0x9F</code></td>
</tr>
<tr class="odd">
<td><strong>Stack</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>PSH</code></td>
<td>Push to Stack</td>
<td>Register</td>
<td>Insert the value in a register to the top of the stack</td>
<td><code>0xA0</code></td>
</tr>
<tr class="odd">
<td><code>PSH</code></td>
<td>Push to Stack</td>
<td>Literal</td>
<td>Insert a literal value to the top of the stack</td>
<td><code>0xA1</code></td>
</tr>
<tr class="even">
<td><code>PSH</code></td>
<td>Push to Stack</td>
<td>Address</td>
<td>Insert the contents of memory at an address in a label to the top of
the stack</td>
<td><code>0xA2</code></td>
</tr>
<tr class="odd">
<td><code>PSH</code></td>
<td>Push to Stack</td>
<td>Pointer</td>
<td>Insert the contents of memory at an address in a register to the top
of the stack</td>
<td><code>0xA3</code></td>
</tr>
<tr class="even">
<td><code>POP</code></td>
<td>Pop from Stack</td>
<td>Register</td>
<td>Remove the value from the top of the stack and store it in a
register</td>
<td><code>0xA4</code></td>
</tr>
<tr class="odd">
<td><strong>Subroutines</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Address</td>
<td>Call the subroutine at an address in a label, pushing
<code>rpo</code>, <code>rsb</code>, and <code>rso</code> to the
stack</td>
<td><code>0xB0</code></td>
</tr>
<tr class="odd">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Pointer</td>
<td>Call the subroutine at an address in a register, pushing
<code>rpo</code>, <code>rsb</code>, and <code>rso</code> to the
stack</td>
<td><code>0xB1</code></td>
</tr>
<tr class="even">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Address, Register</td>
<td>Call the subroutine at an address in a label, moving the value in a
register to <code>rfp</code></td>
<td><code>0xB2</code></td>
</tr>
<tr class="odd">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Address, Literal</td>
<td>Call the subroutine at an address in a label, moving a literal value
to <code>rfp</code></td>
<td><code>0xB3</code></td>
</tr>
<tr class="even">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Address, Address</td>
<td>Call the subroutine at an address in a label, moving the contents of
memory at an address in a label to <code>rfp</code></td>
<td><code>0xB4</code></td>
</tr>
<tr class="odd">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Address, Pointer</td>
<td>Call the subroutine at an address in a label, moving the contents of
memory at an address in a register to <code>rfp</code></td>
<td><code>0xB5</code></td>
</tr>
<tr class="even">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Pointer, Register</td>
<td>Call the subroutine at an address in a register, moving the value in
a register to <code>rfp</code></td>
<td><code>0xB6</code></td>
</tr>
<tr class="odd">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Pointer, Literal</td>
<td>Call the subroutine at an address in a register, moving a literal
value to <code>rfp</code></td>
<td><code>0xB7</code></td>
</tr>
<tr class="even">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Pointer, Address</td>
<td>Call the subroutine at an address in a register, moving the contents
of memory at an address in a label to <code>rfp</code></td>
<td><code>0xB8</code></td>
</tr>
<tr class="odd">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Pointer, Pointer</td>
<td>Call the subroutine at an address in a register, moving the contents
of memory at an address in a register to <code>rfp</code></td>
<td><code>0xB9</code></td>
</tr>
<tr class="even">
<td><code>RET</code></td>
<td>Return from Subroutine</td>
<td>-</td>
<td>Pop the previous states of <code>rso</code>, <code>rsb</code>. and
<code>rpo</code> off the stack</td>
<td><code>0xBA</code></td>
</tr>
<tr class="odd">
<td><code>RET</code></td>
<td>Return from Subroutine</td>
<td>Register</td>
<td>Pop the previous states of <code>rso</code>, <code>rsb</code>. and
<code>rpo</code> off the stack, moving the value in a register to
<code>rrv</code></td>
<td><code>0xBB</code></td>
</tr>
<tr class="even">
<td><code>RET</code></td>
<td>Return from Subroutine</td>
<td>Literal</td>
<td>Pop the previous states of <code>rso</code>, <code>rsb</code>. and
<code>rpo</code> off the stack, moving a literal value to
<code>rrv</code></td>
<td><code>0xBC</code></td>
</tr>
<tr class="odd">
<td><code>RET</code></td>
<td>Return from Subroutine</td>
<td>Address</td>
<td>Pop the previous states off the stack, moving the contents of memory
at an address in a label to <code>rrv</code></td>
<td><code>0xBD</code></td>
</tr>
<tr class="even">
<td><code>RET</code></td>
<td>Return from Subroutine</td>
<td>Pointer</td>
<td>Pop the previous states off the stack, moving the contents of memory
at an address in a register to <code>rrv</code></td>
<td><code>0xBE</code></td>
</tr>
<tr class="odd">
<td><strong>Console Writing</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>WCN</code></td>
<td>Write Number to Console</td>
<td>Register</td>
<td>Write a register value as a decimal number to the console</td>
<td><code>0xC0</code></td>
</tr>
<tr class="odd">
<td><code>WCN</code></td>
<td>Write Number to Console</td>
<td>Literal</td>
<td>Write a literal value as a decimal number to the console</td>
<td><code>0xC1</code></td>
</tr>
<tr class="even">
<td><code>WCN</code></td>
<td>Write Number to Console</td>
<td>Address</td>
<td>Write 64-bits (4 bytes) of memory starting at the address in a label
as a decimal number to the console</td>
<td><code>0xC2</code></td>
</tr>
<tr class="odd">
<td><code>WCN</code></td>
<td>Write Number to Console</td>
<td>Pointer</td>
<td>Write 64-bits (4 bytes) of memory starting at the address in a
register as a decimal number to the console</td>
<td><code>0xC3</code></td>
</tr>
<tr class="even">
<td><code>WCB</code></td>
<td>Write Numeric Byte to Console</td>
<td>Register</td>
<td>Write the lower 8-bits of a register value as a decimal number to
the console</td>
<td><code>0xC4</code></td>
</tr>
<tr class="odd">
<td><code>WCB</code></td>
<td>Write Numeric Byte to Console</td>
<td>Literal</td>
<td>Write the lower 8-bits of a literal value as a decimal number to the
console</td>
<td><code>0xC5</code></td>
</tr>
<tr class="even">
<td><code>WCB</code></td>
<td>Write Numeric Byte to Console</td>
<td>Address</td>
<td>Write contents of memory at the address in a label as a decimal
number to the console</td>
<td><code>0xC6</code></td>
</tr>
<tr class="odd">
<td><code>WCB</code></td>
<td>Write Numeric Byte to Console</td>
<td>Pointer</td>
<td>Write contents of memory at the address in a register as a decimal
number to the console</td>
<td><code>0xC7</code></td>
</tr>
<tr class="even">
<td><code>WCX</code></td>
<td>Write Hexadecimal to Console</td>
<td>Register</td>
<td>Write the lower 8-bits of a register value as a hexadecimal number
to the console</td>
<td><code>0xC8</code></td>
</tr>
<tr class="odd">
<td><code>WCX</code></td>
<td>Write Hexadecimal to Console</td>
<td>Literal</td>
<td>Write the lower 8-bits of a literal value as a hexadecimal number to
the console</td>
<td><code>0xC9</code></td>
</tr>
<tr class="even">
<td><code>WCX</code></td>
<td>Write Hexadecimal to Console</td>
<td>Address</td>
<td>Write contents of memory at the address in a label as a hexadecimal
number to the console</td>
<td><code>0xCA</code></td>
</tr>
<tr class="odd">
<td><code>WCX</code></td>
<td>Write Hexadecimal to Console</td>
<td>Pointer</td>
<td>Write contents of memory at the address in a register as a
hexadecimal number to the console</td>
<td><code>0xCB</code></td>
</tr>
<tr class="even">
<td><code>WCC</code></td>
<td>Write Raw Byte to Console</td>
<td>Register</td>
<td>Write the lower 8-bits of a register value as a raw byte to the
console</td>
<td><code>0xCC</code></td>
</tr>
<tr class="odd">
<td><code>WCC</code></td>
<td>Write Raw Byte to Console</td>
<td>Literal</td>
<td>Write the lower 8-bits of a literal value as a raw byte to the
console</td>
<td><code>0xCD</code></td>
</tr>
<tr class="even">
<td><code>WCC</code></td>
<td>Write Raw Byte to Console</td>
<td>Address</td>
<td>Write contents of memory at the address in a label as a raw byte to
the console</td>
<td><code>0xCE</code></td>
</tr>
<tr class="odd">
<td><code>WCC</code></td>
<td>Write Raw Byte to Console</td>
<td>Pointer</td>
<td>Write contents of memory at the address in a register as a raw byte
to the console</td>
<td><code>0xCF</code></td>
</tr>
<tr class="even">
<td><strong>File Writing</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>WFN</code></td>
<td>Write Number to File</td>
<td>Register</td>
<td>Write a register value as a decimal number to the opened file</td>
<td><code>0xD0</code></td>
</tr>
<tr class="even">
<td><code>WFN</code></td>
<td>Write Number to File</td>
<td>Literal</td>
<td>Write a literal value as a decimal number to the opened file</td>
<td><code>0xD1</code></td>
</tr>
<tr class="odd">
<td><code>WFN</code></td>
<td>Write Number to File</td>
<td>Address</td>
<td>Write 64-bits (4 bytes) of memory starting at the address in a label
as a decimal number to the opened file</td>
<td><code>0xD2</code></td>
</tr>
<tr class="even">
<td><code>WFN</code></td>
<td>Write Number to File</td>
<td>Pointer</td>
<td>Write 64-bits (4 bytes) of memory starting at the address in a
register as a decimal number to the opened file</td>
<td><code>0xD3</code></td>
</tr>
<tr class="odd">
<td><code>WFB</code></td>
<td>Write Numeric Byte to File</td>
<td>Register</td>
<td>Write the lower 8-bits of a register value as a decimal number to
the opened file</td>
<td><code>0xD4</code></td>
</tr>
<tr class="even">
<td><code>WFB</code></td>
<td>Write Numeric Byte to File</td>
<td>Literal</td>
<td>Write the lower 8-bits of a literal value as a decimal number to the
opened file</td>
<td><code>0xD5</code></td>
</tr>
<tr class="odd">
<td><code>WFB</code></td>
<td>Write Numeric Byte to File</td>
<td>Address</td>
<td>Write contents of memory at the address in a label as a decimal
number to the opened file</td>
<td><code>0xD6</code></td>
</tr>
<tr class="even">
<td><code>WFB</code></td>
<td>Write Numeric Byte to File</td>
<td>Pointer</td>
<td>Write contents of memory at the address in a register as a decimal
number to the opened file</td>
<td><code>0xD7</code></td>
</tr>
<tr class="odd">
<td><code>WFX</code></td>
<td>Write Hexadecimal to File</td>
<td>Register</td>
<td>Write the lower 8-bits of a register value as a hexadecimal number
to the opened file</td>
<td><code>0xD8</code></td>
</tr>
<tr class="even">
<td><code>WFX</code></td>
<td>Write Hexadecimal to File</td>
<td>Literal</td>
<td>Write the lower 8-bits of a literal value as a hexadecimal number to
the opened file</td>
<td><code>0xD9</code></td>
</tr>
<tr class="odd">
<td><code>WFX</code></td>
<td>Write Hexadecimal to File</td>
<td>Address</td>
<td>Write contents of memory at the address in a label as a hexadecimal
number to the opened file</td>
<td><code>0xDA</code></td>
</tr>
<tr class="even">
<td><code>WFX</code></td>
<td>Write Hexadecimal to File</td>
<td>Pointer</td>
<td>Write contents of memory at the address in a register as a
hexadecimal number to the opened file</td>
<td><code>0xDB</code></td>
</tr>
<tr class="odd">
<td><code>WFC</code></td>
<td>Write Raw Byte to File</td>
<td>Register</td>
<td>Write the lower 8-bits of a register value as a raw byte to the
opened file</td>
<td><code>0xDC</code></td>
</tr>
<tr class="even">
<td><code>WFC</code></td>
<td>Write Raw Byte to File</td>
<td>Literal</td>
<td>Write the lower 8-bits of a literal value as a raw byte to the
opened file</td>
<td><code>0xDD</code></td>
</tr>
<tr class="odd">
<td><code>WFC</code></td>
<td>Write Raw Byte to File</td>
<td>Address</td>
<td>Write contents of memory at the address in a label as a raw byte to
the opened file</td>
<td><code>0xDE</code></td>
</tr>
<tr class="even">
<td><code>WFC</code></td>
<td>Write Raw Byte to File</td>
<td>Pointer</td>
<td>Write contents of memory at the address in a register as a raw byte
to the opened file</td>
<td><code>0xDF</code></td>
</tr>
<tr class="odd">
<td><strong>File Operations</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>OFL</code></td>
<td>Open File</td>
<td>Address</td>
<td>Open the file at the path specified by a <code>0x00</code>
terminated string in memory starting at an address in a label</td>
<td><code>0xE0</code></td>
</tr>
<tr class="odd">
<td><code>OFL</code></td>
<td>Open File</td>
<td>Pointer</td>
<td>Open the file at the path specified by a <code>0x00</code>
terminated string in memory starting at an address in a register</td>
<td><code>0xE1</code></td>
</tr>
<tr class="even">
<td><code>CFL</code></td>
<td>Close File</td>
<td>-</td>
<td>Close the currently open file</td>
<td><code>0xE2</code></td>
</tr>
<tr class="odd">
<td><code>DFL</code></td>
<td>Delete File</td>
<td>Address</td>
<td>Delete the file at the path specified by a <code>0x00</code>
terminated string in memory starting at an address in a label</td>
<td><code>0xE3</code></td>
</tr>
<tr class="even">
<td><code>DFL</code></td>
<td>Delete File</td>
<td>Pointer</td>
<td>Delete the file at the path specified by a <code>0x00</code>
terminated string in memory starting at an address in a register</td>
<td><code>0xE4</code></td>
</tr>
<tr class="odd">
<td><code>FEX</code></td>
<td>File Exists</td>
<td>Register, Address</td>
<td>Store <code>1</code> in a register if the filepath specified in
memory starting at an address in a label exists, else
<code>0</code></td>
<td><code>0xE5</code></td>
</tr>
<tr class="even">
<td><code>FEX</code></td>
<td>File Exists</td>
<td>Register, Pointer</td>
<td>Store <code>1</code> in a register if the filepath specified in
memory starting at an address in a register exists, else
<code>0</code></td>
<td><code>0xE6</code></td>
</tr>
<tr class="odd">
<td><code>FSZ</code></td>
<td>Get File Size</td>
<td>Register, Address</td>
<td>In a register, store the byte size of the file at the path specified
in memory starting at an address in a label</td>
<td><code>0xE7</code></td>
</tr>
<tr class="even">
<td><code>FSZ</code></td>
<td>Get File Size</td>
<td>Register, Pointer</td>
<td>In a register, store the byte size of the file at the path specified
in memory starting at an address in a register</td>
<td><code>0xE8</code></td>
</tr>
<tr class="odd">
<td><strong>Reading</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>RCC</code></td>
<td>Read Raw Byte from Console</td>
<td>Register</td>
<td>Read a raw byte from the console, storing it in a register</td>
<td><code>0xF0</code></td>
</tr>
<tr class="odd">
<td><code>RFC</code></td>
<td>Read Raw Byte from File</td>
<td>Register</td>
<td>Read the next byte from the currently open file, storing it in a
register</td>
<td><code>0xF1</code></td>
</tr>
</tbody>
</table>
<h2 id="ascii-table">ASCII Table</h2>
<p>The following is a list of common characters and their corresponding
byte value in decimal.</p>
<table>
<thead>
<tr class="header">
<th>Code</th>
<th>Character</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>10</td>
<td>LF (line feed, new line)</td>
</tr>
<tr class="even">
<td>13</td>
<td>CR (carriage return)</td>
</tr>
<tr class="odd">
<td>32</td>
<td>SPACE</td>
</tr>
<tr class="even">
<td>33</td>
<td>!</td>
</tr>
<tr class="odd">
<td>34</td>
<td>”</td>
</tr>
<tr class="even">
<td>35</td>
<td>#</td>
</tr>
<tr class="odd">
<td>36</td>
<td>$</td>
</tr>
<tr class="even">
<td>37</td>
<td>%</td>
</tr>
<tr class="odd">
<td>38</td>
<td>&amp;</td>
</tr>
<tr class="even">
<td>39</td>
<td>’</td>
</tr>
<tr class="odd">
<td>40</td>
<td>(</td>
</tr>
<tr class="even">
<td>41</td>
<td>)</td>
</tr>
<tr class="odd">
<td>42</td>
<td>*</td>
</tr>
<tr class="even">
<td>43</td>
<td>+</td>
</tr>
<tr class="odd">
<td>44</td>
<td>,</td>
</tr>
<tr class="even">
<td>45</td>
<td>-</td>
</tr>
<tr class="odd">
<td>46</td>
<td>.</td>
</tr>
<tr class="even">
<td>47</td>
<td>/</td>
</tr>
<tr class="odd">
<td>48</td>
<td>0</td>
</tr>
<tr class="even">
<td>49</td>
<td>1</td>
</tr>
<tr class="odd">
<td>50</td>
<td>2</td>
</tr>
<tr class="even">
<td>51</td>
<td>3</td>
</tr>
<tr class="odd">
<td>52</td>
<td>4</td>
</tr>
<tr class="even">
<td>53</td>
<td>5</td>
</tr>
<tr class="odd">
<td>54</td>
<td>6</td>
</tr>
<tr class="even">
<td>55</td>
<td>7</td>
</tr>
<tr class="odd">
<td>56</td>
<td>8</td>
</tr>
<tr class="even">
<td>57</td>
<td>9</td>
</tr>
<tr class="odd">
<td>58</td>
<td>:</td>
</tr>
<tr class="even">
<td>59</td>
<td>;</td>
</tr>
<tr class="odd">
<td>60</td>
<td>&lt;</td>
</tr>
<tr class="even">
<td>61</td>
<td>=</td>
</tr>
<tr class="odd">
<td>62</td>
<td>&gt;</td>
</tr>
<tr class="even">
<td>63</td>
<td>?</td>
</tr>
<tr class="odd">
<td>64</td>
<td>@</td>
</tr>
<tr class="even">
<td>65</td>
<td>A</td>
</tr>
<tr class="odd">
<td>66</td>
<td>B</td>
</tr>
<tr class="even">
<td>67</td>
<td>C</td>
</tr>
<tr class="odd">
<td>68</td>
<td>D</td>
</tr>
<tr class="even">
<td>69</td>
<td>E</td>
</tr>
<tr class="odd">
<td>70</td>
<td>F</td>
</tr>
<tr class="even">
<td>71</td>
<td>G</td>
</tr>
<tr class="odd">
<td>72</td>
<td>H</td>
</tr>
<tr class="even">
<td>73</td>
<td>I</td>
</tr>
<tr class="odd">
<td>74</td>
<td>J</td>
</tr>
<tr class="even">
<td>75</td>
<td>K</td>
</tr>
<tr class="odd">
<td>76</td>
<td>L</td>
</tr>
<tr class="even">
<td>77</td>
<td>M</td>
</tr>
<tr class="odd">
<td>78</td>
<td>N</td>
</tr>
<tr class="even">
<td>79</td>
<td>O</td>
</tr>
<tr class="odd">
<td>80</td>
<td>P</td>
</tr>
<tr class="even">
<td>81</td>
<td>Q</td>
</tr>
<tr class="odd">
<td>82</td>
<td>R</td>
</tr>
<tr class="even">
<td>83</td>
<td>S</td>
</tr>
<tr class="odd">
<td>84</td>
<td>T</td>
</tr>
<tr class="even">
<td>85</td>
<td>U</td>
</tr>
<tr class="odd">
<td>86</td>
<td>V</td>
</tr>
<tr class="even">
<td>87</td>
<td>W</td>
</tr>
<tr class="odd">
<td>88</td>
<td>X</td>
</tr>
<tr class="even">
<td>89</td>
<td>Y</td>
</tr>
<tr class="odd">
<td>90</td>
<td>Z</td>
</tr>
<tr class="even">
<td>91</td>
<td>[</td>
</tr>
<tr class="odd">
<td>92</td>
<td>\</td>
</tr>
<tr class="even">
<td>93</td>
<td>]</td>
</tr>
<tr class="odd">
<td>94</td>
<td>^</td>
</tr>
<tr class="even">
<td>95</td>
<td>_</td>
</tr>
<tr class="odd">
<td>96</td>
<td>`</td>
</tr>
<tr class="even">
<td>97</td>
<td>a</td>
</tr>
<tr class="odd">
<td>98</td>
<td>b</td>
</tr>
<tr class="even">
<td>99</td>
<td>c</td>
</tr>
<tr class="odd">
<td>100</td>
<td>d</td>
</tr>
<tr class="even">
<td>101</td>
<td>e</td>
</tr>
<tr class="odd">
<td>102</td>
<td>f</td>
</tr>
<tr class="even">
<td>103</td>
<td>g</td>
</tr>
<tr class="odd">
<td>104</td>
<td>h</td>
</tr>
<tr class="even">
<td>105</td>
<td>i</td>
</tr>
<tr class="odd">
<td>106</td>
<td>j</td>
</tr>
<tr class="even">
<td>107</td>
<td>k</td>
</tr>
<tr class="odd">
<td>108</td>
<td>l</td>
</tr>
<tr class="even">
<td>109</td>
<td>m</td>
</tr>
<tr class="odd">
<td>110</td>
<td>n</td>
</tr>
<tr class="even">
<td>111</td>
<td>o</td>
</tr>
<tr class="odd">
<td>112</td>
<td>p</td>
</tr>
<tr class="even">
<td>113</td>
<td>q</td>
</tr>
<tr class="odd">
<td>114</td>
<td>r</td>
</tr>
<tr class="even">
<td>115</td>
<td>s</td>
</tr>
<tr class="odd">
<td>116</td>
<td>t</td>
</tr>
<tr class="even">
<td>117</td>
<td>u</td>
</tr>
<tr class="odd">
<td>118</td>
<td>v</td>
</tr>
<tr class="even">
<td>119</td>
<td>w</td>
</tr>
<tr class="odd">
<td>120</td>
<td>x</td>
</tr>
<tr class="even">
<td>121</td>
<td>y</td>
</tr>
<tr class="odd">
<td>122</td>
<td>z</td>
</tr>
<tr class="even">
<td>123</td>
<td>{</td>
</tr>
<tr class="odd">
<td>124</td>
<td>|</td>
</tr>
<tr class="even">
<td>125</td>
<td>}</td>
</tr>
<tr class="odd">
<td>126</td>
<td>~</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>Copyright © 2022–2023 Ptolemy Hill</strong></p>
</body>
</html>
