<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>AssEmbly Reference Manual</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="assembly-reference-manual">AssEmbly Reference Manual</h1>
<p>Applies to versions: <code>2.0.0</code></p>
<p>Last revised: 2023-09-30</p>
<h2 id="introduction">Introduction</h2>
<p>AssEmbly is a custom processor architecture and assembly language
implemented in .NET. It is designed to simplify the process of learning
and writing in assembly language, while still following the same basic
concepts and constraints seen in mainstream architectures such as
x86.</p>
<p>AssEmbly was designed and implemented in its entirety by <a
href="https://github.com/TollyH">Tolly Hill</a>.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#assembly-reference-manual">AssEmbly Reference Manual</a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#technical-information">Technical Information</a></li>
<li><a href="#basic-syntax">Basic Syntax</a>
<ul>
<li><a href="#mnemonics-and-operands">Mnemonics and Operands</a></li>
<li><a href="#comments">Comments</a></li>
<li><a href="#labels">Labels</a></li>
</ul></li>
<li><a href="#operand-types">Operand Types</a>
<ul>
<li><a href="#register">Register</a></li>
<li><a href="#literal">Literal</a></li>
<li><a href="#address">Address</a></li>
<li><a href="#pointer">Pointer</a></li>
</ul></li>
<li><a href="#registers">Registers</a>
<ul>
<li><a href="#register-table">Register Table</a></li>
<li><a href="#rpo--program-offset"><code>rpo</code> — Program
Offset</a></li>
<li><a href="#rsf--status-flags"><code>rsf</code> — Status
Flags</a></li>
<li><a href="#rrv--return-value"><code>rrv</code> — Return
Value</a></li>
<li><a href="#rfp--fast-pass-parameter"><code>rfp</code> — Fast Pass
Parameter</a></li>
<li><a href="#rso--stack-offset"><code>rso</code> — Stack
Offset</a></li>
<li><a href="#rsb--stack-base"><code>rsb</code> — Stack Base</a></li>
<li><a href="#rg0---rg9--general-purpose"><code>rg0</code> -
<code>rg9</code> — General Purpose</a></li>
</ul></li>
<li><a href="#moving-data">Moving Data</a>
<ul>
<li><a href="#moving-with-literals">Moving with Literals</a></li>
<li><a href="#moving-with-registers">Moving with Registers</a></li>
<li><a href="#moving-with-memory">Moving with Memory</a></li>
</ul></li>
<li><a href="#maths-and-bitwise-operations">Maths and Bitwise
Operations</a>
<ul>
<li><a href="#addition-and-multiplication">Addition and
Multiplication</a></li>
<li><a href="#subtraction">Subtraction</a></li>
<li><a href="#division">Division</a></li>
<li><a href="#shifting">Shifting</a></li>
<li><a href="#bitwise">Bitwise</a></li>
<li><a href="#random-number-generation">Random Number
Generation</a></li>
</ul></li>
<li><a href="#negative-numbers">Negative Numbers</a>
<ul>
<li><a href="#arithmetic-right-shifting">Arithmetic Right
Shifting</a></li>
<li><a href="#extending-smaller-signed-values">Extending Smaller Signed
Values</a></li>
<li><a href="#the-overflow-flag-vs-the-carry-flag">The Overflow Flag
vs. the Carry Flag</a></li>
</ul></li>
<li><a href="#floating-point-numbers">Floating Point Numbers</a>
<ul>
<li><a href="#floating-point-math">Floating Point Math</a></li>
<li><a href="#converting-between-integers-and-floats">Converting Between
Integers and Floats</a></li>
<li><a href="#converting-between-floating-point-sizes">Converting
Between Floating Point Sizes</a></li>
</ul></li>
<li><a href="#jumping">Jumping</a></li>
<li><a href="#comparing-testing-and-branching">Comparing, Testing, and
Branching</a>
<ul>
<li><a href="#comparing-unsigned-numbers">Comparing Unsigned
Numbers</a></li>
<li><a href="#comparing-signed-numbers">Comparing Signed
Numbers</a></li>
<li><a href="#comparing-floating-point-numbers">Comparing Floating Point
Numbers</a></li>
<li><a href="#testing-bits">Testing Bits</a></li>
<li><a href="#checking-the-carry-overflow-zero-and-sign-flags">Checking
the Carry, Overflow, Zero, and Sign Flags</a></li>
</ul></li>
<li><a href="#assembler-directives">Assembler Directives</a>
<ul>
<li><a href="#pad--byte-padding"><code>PAD</code> — Byte
Padding</a></li>
<li><a href="#dat--byte-insertion"><code>DAT</code> — Byte Insertion</a>
<ul>
<li><a href="#escape-sequences">Escape Sequences</a></li>
</ul></li>
<li><a href="#num--number-insertion"><code>NUM</code> — Number
Insertion</a></li>
<li><a href="#mac--macro-definition"><code>MAC</code> — Macro
Definition</a></li>
<li><a href="#imp--file-importing"><code>IMP</code> — File
Importing</a></li>
<li><a
href="#analyzer--toggling-assembler-warnings"><code>ANALYZER</code> —
Toggling Assembler Warnings</a></li>
</ul></li>
<li><a href="#console-input-and-output">Console Input and
Output</a></li>
<li><a href="#file-handling">File Handling</a>
<ul>
<li><a href="#opening-and-closing">Opening and Closing</a></li>
<li><a href="#reading-and-writing">Reading and Writing</a></li>
<li><a href="#other-operations">Other Operations</a></li>
</ul></li>
<li><a href="#the-stack">The Stack</a>
<ul>
<li><a href="#using-the-stack-to-preserve-registers">Using the Stack to
Preserve Registers</a></li>
</ul></li>
<li><a href="#subroutines">Subroutines</a>
<ul>
<li><a href="#fast-calling">Fast Calling</a></li>
<li><a href="#return-values">Return Values</a></li>
<li><a href="#subroutines-and-the-stack">Subroutines and the
Stack</a></li>
<li><a href="#passing-multiple-parameters">Passing Multiple
Parameters</a></li>
</ul></li>
<li><a href="#text-encoding">Text Encoding</a></li>
<li><a href="#instruction-data-type-acceptance">Instruction Data Type
Acceptance</a></li>
<li><a href="#status-flag-behaviour">Status Flag Behaviour</a></li>
<li><a href="#full-instruction-reference">Full Instruction Reference</a>
<ul>
<li><a href="#base-instruction-set">Base Instruction Set</a></li>
<li><a href="#signed-extension-set">Signed Extension Set</a></li>
<li><a href="#floating-point-extension-set">Floating Point Extension
Set</a></li>
<li><a href="#extended-base-set">Extended Base Set</a></li>
</ul></li>
<li><a href="#ascii-table">ASCII Table</a></li>
</ul></li>
</ul>
<h2 id="technical-information">Technical Information</h2>
<table>
<colgroup>
<col style="width: 30%" />
<col style="width: 69%" />
</colgroup>
<tbody>
<tr class="odd">
<td>Bits</td>
<td>64 (registers, operands &amp; addresses)</td>
</tr>
<tr class="even">
<td>Word Size</td>
<td>8 bytes (64-bits – called a Quad Word for consistency with x86)</td>
</tr>
<tr class="odd">
<td>Minimum Addressable Unit</td>
<td>Byte (8-bits)</td>
</tr>
<tr class="even">
<td>Register Count</td>
<td>16 (10 general purpose)</td>
</tr>
<tr class="odd">
<td>Architecture Type</td>
<td>Register–memory</td>
</tr>
<tr class="even">
<td>Endianness</td>
<td>Little</td>
</tr>
<tr class="odd">
<td>Signed Number Representation</td>
<td>Two’s Complement</td>
</tr>
<tr class="even">
<td>Branching</td>
<td>Condition code (status register)</td>
</tr>
<tr class="odd">
<td>Opcode Size</td>
<td>1 byte (base instruction set) / 3 bytes (extension sets)</td>
</tr>
<tr class="even">
<td>Operand Size</td>
<td>1 byte (registers, pointers) / 8 bytes (literals,
addresses/labels)</td>
</tr>
<tr class="odd">
<td>Instruction Size</td>
<td>1 byte – 17 bytes (current) / unlimited (theoretical)</td>
</tr>
<tr class="even">
<td>Instruction Count</td>
<td>297 opcodes (102 unique operations)</td>
</tr>
<tr class="odd">
<td>Text Encoding</td>
<td>UTF-8</td>
</tr>
</tbody>
</table>
<h2 id="basic-syntax">Basic Syntax</h2>
<h3 id="mnemonics-and-operands">Mnemonics and Operands</h3>
<p>All AssEmbly instructions are written on a separate line, starting
with a <strong>mnemonic</strong> — a human-readable code that tells the
<strong>assembler</strong> exactly what operation needs to be performed
— followed by any <strong>operands</strong> for the instruction. The
assembler is the program that takes human-readable assembly programs and
turns them into raw numbers — bytes — that can be read by the processor.
This process is called <strong>assembly</strong> or
<strong>assembling</strong>. An operand can be thought of as a parameter
to a function in a high-level language — data that is given to the
processor to read and/or operate on. Mnemonics are separated from
operands with spaces, and operands are separated with commas.</p>
<p>A simple example:</p>
<pre class="text"><code>MVQ rg0, 10</code></pre>
<pre class="text"><code>  MVQ        rg0,      10
  ↑          ↑         ↑
  Mnemonic   Operand   Operand
|----------Instruction----------|</code></pre>
<p>You can have as many spaces as you like between commas and
mnemonics/operands. There do not need to be any around commas, but there
must be at least one between mnemonics and operands. Mnemonics and
operands <strong>cannot</strong> be separated with commas.</p>
<p>Some instructions, like <code>CFL</code>, don’t need any operands. In
these cases, simply have the mnemonic alone on the line.</p>
<p>A line may end in a trailing comma as long as there is at least one
operand on the line. Mnemonics taking no operands cannot be followed by
a trailing comma.</p>
<p>Mnemonics correspond to and are assembled down to
<strong>opcodes</strong>, numbers (in the case of AssEmbly either 1 or 3
bytes) that the processor reads to know what instruction to perform and
what types of operands it needs to read. If an opcode starts with a
<code>0xFF</code> byte, the opcode will be 3 bytes long, with the second
byte corresponding to an <em>extension set</em> number, and the third
byte corresponding to an <em>instruction code</em>. If an opcode starts
with any other byte, that single byte will be the entire opcode, with
the byte corresponding to an <em>instruction code</em> in the base
instruction set (extension set number <code>0x00</code>). This means
that opcodes in the form <code>0xFF, 0x00, 0x??</code> and opcodes in
the form <code>0x??</code> refer to the same instruction, though this
<strong>only</strong> works when the extension set is <code>0x00</code>.
A full list of extension sets and instruction codes can be found toward
the end of the document.</p>
<p>The processor will begin executing from the <strong>first
line</strong> in the file downwards, unless a label with the name
<code>ENTRY</code> is defined, in which case the processor will start
there (more in the following section on labels). Programs should
<em>always</em> end in a <code>HLT</code> instruction (with no operands)
to stop the processor.</p>
<p>For the most part, if an instruction modifies or stores a value
somewhere, the <strong>first</strong> operand will be used as the
<strong>destination</strong>.</p>
<h3 id="comments">Comments</h3>
<p>If you wish to insert text into a program without it being considered
by the assembler as part of the program, you can use a semicolon
(<code>;</code>). Any character after a semicolon will be ignored by the
assembler until the end of the line. You can have a line be entirely a
comment without any instruction if you wish.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 10  ; This text will be ignored
; As will this text
DCR rg0  ; &quot;DCR rg0&quot; will assemble as normal
; Another Comment ; HLT - This is still a comment and will not insert an HLT instruction!</code></pre>
<h3 id="labels">Labels</h3>
<p>Labels mark a position in the file for the program to move
(<strong>jump</strong>) to or reference from elsewhere. They can be
given any name you like (names are <strong>case-sensitive</strong>), but
they must be unique per program and can only contain letters, numbers,
and underscores. Label names <strong>may not</strong> begin with a
number, however. A definition for a label is marked by beginning a line
with a colon — the entire rest of the line will then be read as the new
label name (excluding comments).</p>
<p>For example:</p>
<pre class="text"><code>:AREA_1  ; This comment is valid and will not be read as part of the label
MVQ rg0, 10  ; :AREA_1 now points here

:Area2
DCR rg0  ; :Area2 now points here
HLT</code></pre>
<p>Labels will point to whatever is directly below them, <strong>unless
that is a comment</strong>. Comments are not assembled and so cannot be
pointed to.</p>
<p>For example:</p>
<pre class="text"><code>:NOT_COMMENT  ; Comment 1
; Comment 2
; Comment 3
WCC 10</code></pre>
<p>Here <code>:NOT_COMMENT</code> will point to <code>WCC</code>, as it
is the first thing that will be assembled after the definition was
written.</p>
<p>Labels can also be placed at the very end of a file to point to the
first byte in memory that is not part of the program.</p>
<p>For example, in the small file:</p>
<pre class="text"><code>MVQ rg0, 5
MVQ rg1, 10
:END</code></pre>
<p><code>:END</code> here will have a value of <code>20</code> when
referenced, as each instruction prior will take up <code>10</code> bytes
(more on this later).</p>
<p>The label name <code>:ENTRY</code> (case insensitive) has a special
meaning. If it is present in a file, execution will start from wherever
the entry label points to. If it is not present, execution will start
from the first line.</p>
<p>For example, in this small file:</p>
<pre class="text"><code>MVQ rg0, 5
:ENTRY
MVQ rg1, 10
HLT</code></pre>
<p>When this program is executed, only the <code>MVQ rg1, 10</code> line
will run. <code>MVQ rg0, 5</code> will never be executed.</p>
<h2 id="operand-types">Operand Types</h2>
<p>There are four different types of operand that an instruction may be
able to take. If an instruction supports multiple different possible
combinations of operands, the assembler will automatically determine
their types, you do not need to change the mnemonic at all.</p>
<h3 id="register">Register</h3>
<p>Registers are named, single-number stores separate from the
processor’s main memory. Most operations must be performed on them,
instead of in locations in memory. They are referenced by using their
name (currently always 3 letters — the first one being <code>r</code>,
for example <code>rg0</code>). They always occupy a single byte of
memory after being assembled.</p>
<p>The first operand in this instruction is a register:</p>
<pre class="text"><code>MVQ rg0, 10</code></pre>
<h3 id="literal">Literal</h3>
<p>Literals are numeric values that are directly written in an assembly
file and <strong>do not change</strong>. Their value is read literally
instead of being subject to special consideration, hence the name. They
always occupy 8 bytes (64-bits) of memory after assembly and can be
written in base 10 (denary/decimal), base 2 (binary), or base 16
(hexadecimal). To write in binary, place the characters <code>0b</code>
before the number, or to write in hexadecimal, place <code>0x</code>
before the number.</p>
<p>The second operand in each of these instructions is a literal that
will each represent the same number (ten) after assembly:</p>
<pre class="text"><code>MVQ rg0, 10  ; Base 10
MVQ rg0, 0b1010  ; Base 2
MVQ rg0, 0xA  ; Base 16</code></pre>
<p>When writing literals, you can place an underscore anywhere within
the number value to separate the digits. Underscores cannot be the first
character of the number.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 0x1_000_000  ; This is valid, will be assembled as 0x1000000 (16777216)
MVQ rg0, 0x10_0__000_0  ; This is still valid, underscores don&#39;t have to be uniform

MVQ rg0, 0x_1_000_000  ; This is not valid
MVQ rg0, 0_x1_000_000  ; This is also not valid
MVQ rg0, _0x1_000_000  ; Nor is this</code></pre>
<p>Literals can be made negative by putting a <code>-</code> sign
directly before them (e.g. <code>-42</code>), or be made floating point
by putting a <code>.</code> anywhere in them (e.g. <code>2.3</code>).
Floating point literals can also be made negative
(e.g. <code>-2.3</code>). This is explained in more detail in the
relevant sections on negative and floating point values.</p>
<h3 id="address">Address</h3>
<p>An address is a value that is interpreted as a location to be read
from, written to, or jumped to in a processor’s main memory. In
AssEmbly, an address is always specified by using a
<strong>label</strong>. Once a label has been defined as seen earlier,
they can be referenced by prefixing their name with a colon
(<code>:</code>), similarly to how they are defined — only now it will
be in the place of an operand. Like literals, they always occupy 8 bytes
(64-bits) of memory after assembly.</p>
<p>Consider the following example:</p>
<pre class="text"><code>:AREA_1
WCC 10
MVQ rg0, :AREA_1  ; Move whatever is stored at :AREA_1 in memory to rg0</code></pre>
<p>Here <code>:AREA_1</code> will point to the <strong>first
byte</strong> (i.e. the start of the <strong>opcode</strong>) of the
<strong>directly subsequent assemble-able line</strong> — in this case
<code>WCC</code>. The second operand to <code>MVQ</code> will become the
address that <code>WCC</code> is stored at in memory, <code>0</code> if
it is the first instruction in the file. As <code>MVQ</code> is the
instruction to move to a destination from a source, <code>rg0</code>
will contain <code>0xCD</code> after the instruction executes
(<code>0xCD</code> being the opcode for
<code>WCC &lt;Literal&gt;</code>).</p>
<p>Another example, assuming these are the very first lines in a
file:</p>
<pre class="text"><code>WCC 10
:AREA_1
WCX :AREA_1  ; Will write &quot;CA&quot; to the console</code></pre>
<p><code>:AREA_1</code> will have a value of <code>9</code>, as
<code>WCC 10</code> occupies <code>9</code> bytes. Note that
<code>CA</code> (the opcode for <code>WCX &lt;Address&gt;</code>) will
be written to the console, <em>not</em> <code>9</code>, as the processor
is accessing the byte in memory <em>at</em> the address — <em>not</em>
the address itself.</p>
<p>If, when writing an instruction, you want to utilise the address
<em>itself</em>, rather than the value in memory at that address, insert
an ampersand (<code>&amp;</code>) after the colon, before the label
name.</p>
<p>For example:</p>
<pre class="text"><code>:AREA_1
WCC 10
MVQ rg0, :&amp;AREA_1  ; Move 0 (the address itself) to rg0
WCX :&amp;AREA_1  ; Will write &quot;0&quot; to the console</code></pre>
<h3 id="pointer">Pointer</h3>
<p>So what if you’ve copied an address to a register? You now want to
treat the value of a register as if it were an address in memory, not a
number. This can be achieved with a <strong>pointer</strong>. Simply
prefix a register name with an asterisk (<code>*</code>) to treat the
register contents as a location to store to, read from, or jump to —
instead of a number to operate on. Just like registers, they will occupy
a single byte in memory after assembly.</p>
<p>For example:</p>
<pre class="text"><code>:AREA_1
WCC 10
MVQ rg0, :&amp;AREA_1  ; Move 0 (the address itself) to rg0
MVQ rg1, *rg0  ; Move the item in memory (0xCD) at the address (0) in rg0 to rg1</code></pre>
<p><code>rg1</code> will contain <code>0xCD</code> after the third
instruction finishes.</p>
<h2 id="registers">Registers</h2>
<p>As with most modern architectures, operations in AssEmbly are almost
always performed on <strong>registers</strong>. Each register contains a
64-bit number and has a unique, pre-assigned name. They are stored
separately from the processor’s memory, therefore cannot be referenced
by an address, only by name. There are 16 of them in AssEmbly, 10 of
which are <em>general purpose</em>, meaning they are free to be used for
whatever you wish. All general purpose registers start with a value of
<code>0</code>. The remaining six have special purposes within the
architecture, so should be used with care.</p>
<p>Please be aware that to understand the full operation and purpose for
some registers, knowledge explained later on in the manual may be
required.</p>
<h3 id="register-table">Register Table</h3>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 6%" />
<col style="width: 9%" />
<col style="width: 17%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="header">
<th>Byte</th>
<th>Symbol</th>
<th>Writeable</th>
<th>Full Name</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0x00</td>
<td>rpo</td>
<td>No</td>
<td>Program Offset</td>
<td>Stores the memory address of the current location in memory being
executed</td>
</tr>
<tr class="even">
<td>0x01</td>
<td>rso</td>
<td>Yes</td>
<td>Stack Offset</td>
<td>Stores the memory address of the highest non-popped item on the
stack</td>
</tr>
<tr class="odd">
<td>0x02</td>
<td>rsb</td>
<td>Yes</td>
<td>Stack Base</td>
<td>Stores the memory address of the bottom of the current stack
frame</td>
</tr>
<tr class="even">
<td>0x03</td>
<td>rsf</td>
<td>Yes</td>
<td>Status Flags</td>
<td>Stores bits representing the status of certain instructions</td>
</tr>
<tr class="odd">
<td>0x04</td>
<td>rrv</td>
<td>Yes</td>
<td>Return Value</td>
<td>Stores the return value of the last executed subroutine</td>
</tr>
<tr class="even">
<td>0x05</td>
<td>rfp</td>
<td>Yes</td>
<td>Fast Pass Parameter</td>
<td>Stores a single parameter passed to a subroutine</td>
</tr>
<tr class="odd">
<td>0x06</td>
<td>rg0</td>
<td>Yes</td>
<td>General 0</td>
<td><em>General purpose</em></td>
</tr>
<tr class="even">
<td>0x07</td>
<td>rg1</td>
<td>Yes</td>
<td>General 1</td>
<td><em>General purpose</em></td>
</tr>
<tr class="odd">
<td>0x08</td>
<td>rg2</td>
<td>Yes</td>
<td>General 2</td>
<td><em>General purpose</em></td>
</tr>
<tr class="even">
<td>0x09</td>
<td>rg3</td>
<td>Yes</td>
<td>General 3</td>
<td><em>General purpose</em></td>
</tr>
<tr class="odd">
<td>0x0A</td>
<td>rg4</td>
<td>Yes</td>
<td>General 4</td>
<td><em>General purpose</em></td>
</tr>
<tr class="even">
<td>0x0B</td>
<td>rg5</td>
<td>Yes</td>
<td>General 5</td>
<td><em>General purpose</em></td>
</tr>
<tr class="odd">
<td>0x0C</td>
<td>rg6</td>
<td>Yes</td>
<td>General 6</td>
<td><em>General purpose</em></td>
</tr>
<tr class="even">
<td>0x0D</td>
<td>rg7</td>
<td>Yes</td>
<td>General 7</td>
<td><em>General purpose</em></td>
</tr>
<tr class="odd">
<td>0x0E</td>
<td>rg8</td>
<td>Yes</td>
<td>General 8</td>
<td><em>General purpose</em></td>
</tr>
<tr class="even">
<td>0x0F</td>
<td>rg9</td>
<td>Yes</td>
<td>General 9</td>
<td><em>General purpose</em></td>
</tr>
</tbody>
</table>
<h3 id="rpo-program-offset"><code>rpo</code> — Program Offset</h3>
<p>Stores the memory address of the current location in memory being
executed. For safety, it cannot be directly written to. To change where
you are in a program, use a <strong>jump instruction</strong> (explained
later on).</p>
<p>For example, in the short program (assuming the first instruction is
the first in a file):</p>
<pre class="text"><code>MVQ rg0, 10
DCR rg0</code></pre>
<p>When the program starts, <code>rpo</code> will have a value of
<code>0</code> — the address of the first item in memory. After the
first instruction has finished executing, <code>rpo</code> will have a
value of <code>10</code>: its previous value <code>0</code>, plus
<code>1</code> byte for the mnemonic’s opcode, <code>1</code> byte for
the register operand, and <code>8</code> bytes for the literal operand.
<code>rpo</code> is now pointing to the opcode of the next instruction
(<code>DCR</code>).</p>
<p><strong>Note:</strong> <code>rpo</code> is incremented by 1
<strong><em>before</em></strong> an instruction begins execution,
therefore when used as an operand in an instruction, it will point to
the address of the <strong>first operand</strong>, <strong>not to the
address of the opcode</strong>. It will not be incremented again until
<em>after</em> the instruction has completed.</p>
<p>For example, in the instruction:</p>
<pre class="text"><code>MVQ rg0, rpo</code></pre>
<p>Before execution of the instruction begins, <code>rpo</code> will
point to the opcode corresponding to <code>MVQ</code> with a register
and literal. Once the processor reads this, it increments
<code>rpo</code> by <code>1</code>. <code>rpo</code> now points to the
first operand: <code>rg0</code>. This value will be retained until after
the instruction has completed, when <code>rpo</code> will be increased
by <code>2</code> (<code>1</code> for each register operand). This means
there was an increase of <code>3</code> overall when including the
initial increment by <code>1</code> for the opcode.</p>
<h3 id="rsf-status-flags"><code>rsf</code> — Status Flags</h3>
<p>The status flags register is used to mark some information about
previously executed instructions. While it stores a 64-bit number just
like every other register, its value should instead be treated
bit-by-bit rather than as one number.</p>
<p>Currently, the <strong>lowest 5</strong> bits of the 64-bit value
have a special use — the remaining 59 will not be automatically modified
as of current, though it is recommended that you do not use them for
anything else in case this changes in the future.</p>
<p>The 5 bits currently in use are:</p>
<pre class="text"><code>0b00...00000OSFCZ

... = 52 omitted bits
Z = Zero flag
C = Carry flag
F = File end flag
S = Sign Flag
O = Overflow Flag</code></pre>
<p>Each bit of this number can be considered as a <code>true</code>
(<code>1</code>) or <code>false</code> (<code>0</code>) value as to
whether the flag is “set” or not.</p>
<p>More information on using these flags can be found in the section on
comparison and testing.</p>
<p>A full table of how each instruction modifies the status flag
register can be found toward the end of the document.</p>
<h3 id="rrv-return-value"><code>rrv</code> — Return Value</h3>
<p>Stores the return value of the last executed subroutine. Note that if
a subroutine doesn’t return a value, <code>rrv</code> will remain
unaffected.</p>
<p>For example:</p>
<pre class="text"><code>:SUBROUTINE_ONE
...
...
...
RET 4  ; Return, setting rrv to the literal 4

:SUBROUTINE_TWO
...
...
...
RET  ; Return, leaving rrv unaffected

CAL :SUBROUTINE_ONE
; rrv is now 4
CAL :SUBROUTINE_TWO
; rrv is still 4</code></pre>
<p>More information can be found in the section on subroutines.</p>
<h3 id="rfp-fast-pass-parameter"><code>rfp</code> — Fast Pass
Parameter</h3>
<p>Stores a single parameter passed to a subroutine. If such a parameter
is not provided, <code>rfp</code> remains unaffected.</p>
<p>For example:</p>
<pre class="text"><code>:SUBROUTINE_ONE
ADD rfp, 1
RET rfp

:SUBROUTINE_TWO
ADD rfp, 2
RET rfp

CAL :SUBROUTINE_ONE, 4  ; This will implicitly set rfp to 4
; rrv is now 5
CAL :SUBROUTINE_TWO, 6  ; This will implicitly set rfp to 6
; rrv is now 8
CAL :SUBROUTINE_TWO  ; rfp will remain 6 here
; rrv is now 10</code></pre>
<p>Implicitly setting <code>rfp</code> like this with the
<code>CAL</code> instruction is called <strong>fast passing</strong> or
<strong>fast calling</strong>, hence the name fast pass parameter.</p>
<p>Note that in practice, if a subroutine is designed to take a fast
pass parameter, you should <strong>always</strong> explicitly provide
it, even if you think <code>rfp</code> will already have the value you
want. Similarly, you should not use <code>rfp</code> in a subroutine if
it has not been explicitly set in its calls.</p>
<p>More information can be found in the section on subroutines.</p>
<h3 id="rso-stack-offset"><code>rso</code> — Stack Offset</h3>
<p>Stores the memory address of the highest non-popped item on the stack
(note that the stack fills from the end of memory backwards). If nothing
is left on the stack in the current subroutine, it will be equal to
<code>rsb</code>, and if nothing is left on the stack at all, it will
still be equal to <code>rsb</code>, with both being equal to one over
the highest possible address in memory (so will result in an error if
that address is read from).</p>
<p>More information can be found in the dedicated sections on the stack
and subroutines.</p>
<p>A simple example, assuming memory is 2046 bytes in size (making 2045
the highest address):</p>
<pre class="text"><code>WCN rso  ; Outputs &quot;2046&quot;
PSH 5  ; Push the literal 5 to the stack
WCN rso  ; Outputs &quot;2038&quot; (stack values are 8 bytes)
POP rg0  ; Pop the just-pushed 5 into rg0
WCN rso  ; Outputs &quot;2046&quot;</code></pre>
<h3 id="rsb-stack-base"><code>rsb</code> — Stack Base</h3>
<p>Stores the memory address of the bottom of the current stack frame.
<code>rsb</code> will only ever change when subroutines are being
utilised — see the dedicated sections on the stack and subroutines for
more info.</p>
<p>Note that <code>rsb</code> does not contain the address of the first
item pushed to the stack, rather the address that all pushed items will
be on top of.</p>
<h3 id="rg0---rg9-general-purpose"><code>rg0</code> - <code>rg9</code> —
General Purpose</h3>
<p>These 10 registers have no special purpose. They will never be
changed unless you explicitly change them with either a move operation,
or another operation that stores to registers. These will be used most
of the time to store and operate on values, as using memory or the stack
to do so is inefficient (and in many cases impossible without copying to
a register first), so should only be done when you run out of free
registers.</p>
<h2 id="moving-data">Moving Data</h2>
<p>There are four different instructions that are used to move data
around without altering it in AssEmbly, each one moving a different
number of bytes. <code>MVB</code> moves a single byte, <code>MVW</code>
moves two (a.k.a. a word, 16-bits), <code>MVD</code> moves four (a.k.a.
a double word, 32-bits), and <code>MVQ</code> moves eight (a.k.a. a quad
word, 64-bits, a full number in AssEmbly).</p>
<p>Data can either be moved between two registers, from a register to a
memory location, or from a memory location to a register. You cannot
move data between two memory locations, you must use a register as a
midpoint instead. To move data to or from a memory location, you can use
either a label or a pointer.</p>
<p>The move instructions are also how the value of a register or memory
location is set to a literal value. In a sense, they can be considered
the equivalent of the <code>=</code> assignment operator in higher-level
languages.</p>
<p>When using move instructions, the destination always comes first. The
destination cannot be a literal.</p>
<h3 id="moving-with-literals">Moving with Literals</h3>
<p>An example of setting registers to the maximum literal values for
each instruction:</p>
<pre class="text"><code>MVQ rg0, 18446744073709551615  ; 64-bit integer limit
MVD rg1, 4294967295  ; 32-bit integer limit
MVW rg2, 65535  ; 16-bit integer limit
MVB rg3, 255  ; 8-bit integer limit</code></pre>
<p>Or labels and pointers:</p>
<pre class="text"><code>MVQ *rg0, 18446744073709551615  ; 64-bit integer limit
MVD *rg1, 4294967295  ; 32-bit integer limit
MVW :AREA_1, 65535  ; 16-bit integer limit
MVB :AREA_2, 255  ; 8-bit integer limit</code></pre>
<p>Note that providing a literal over the limit for a given instruction
will not result in an error. Instead, the <strong>upper</strong> bits
that do not fit in the specified size will be truncated. All 64-bits
will still be assembled into the binary (literals are
<strong>always</strong> assembled to 8 bytes).</p>
<p>For example:</p>
<pre class="text"><code>MVB rg0, 9874</code></pre>
<p><code>MVB</code> can only take a single byte, or 8 bits, but in
binary <code>9874</code> is <code>10011010010010</code>, requiring 14
bits at minimum to store. The lower 8 bits will be kept:
<code>10010010</code> — the remaining 6 (<code>100110</code>) will be
discarded. After this instruction has been executed, <code>rg0</code>
will have a value of <code>146</code>.</p>
<h3 id="moving-with-registers">Moving with Registers</h3>
<p>When moving to and from a register, <code>MVQ</code> will update or
read all of its bits (remember that registers are 64-bit). If any of the
smaller move instructions are used, the <strong>lower</strong> bits of
the register will be used, with the remaining upper bits of a
destination register all being set to <code>0</code>.</p>
<p>For example, assume that before the <code>MVD</code> instruction,
<code>rg1</code> has a value of
<code>14,879,176,506,051,693,048</code>:</p>
<pre class="text"><code>MVW rg1, 65535</code></pre>
<p><code>14,879,176,506,051,693,048</code> in binary is
<code>1100111001111101011101000011001011110001100011001000100111111000</code>,
a full 64-bits, and <code>65535</code> is <code>1111111111111111</code>,
requiring only 16 bits. <code>MVW</code> will only consider these 16
bits (if there were more they would have been truncated, see above
section). Instead of altering only the lowest 16 bits of
<code>rg1</code>, <code>MVW</code> will instead set all the remaining 48
bits to <code>0</code>, resulting in a final value of
<code>0000000000000000000000000000000000000000000000001111111111111111</code>
— <code>65535</code> perfectly.</p>
<p>Similarly to literals, if a source register contains a number greater
than what a move instruction can handle, the upper bits will be
disregarded.</p>
<h3 id="moving-with-memory">Moving with Memory</h3>
<p>Unlike with registers, using different sizes of move instruction
<em>will</em> affect how any bytes are read from memory. Bytes are read
from or written to <strong>starting</strong> at the address in the given
label or pointer, and only the required number for the given instruction
are read or written (1 for <code>MVB</code>, 2 for <code>MVW</code>, 4
for <code>MVD</code>, 8 for <code>MVQ</code>). The instructions will
<em>always</em> write these numbers of bytes, if a number to be moved
takes up less, it will be padded with <code>0</code>s.</p>
<p>Numbers are stored in memory in little endian encoding, meaning that
the smallest byte is stored first, up to the largest. For example, the
32-bit number <code>2,356,895,874</code> is represented in hexadecimal
as <code>0x8C7B6082</code>, which can be broken down into 4 bytes:
<code>8C</code>, <code>7B</code>, <code>60</code>, and <code>82</code>.
When stored in memory, this order will be <em>reversed</em>, as
follows:</p>
<pre class="text"><code>| Address | 00 | 01 | 02 | 03 |
|  Value  | 82 | 60 | 7B | 8C |</code></pre>
<p>This allows you to read a number with a smaller move instruction than
what it was written with, whilst maintaining the same upper-bit
truncating behaviour seen with literals and registers.</p>
<p>An example with a 64-bit number, <code>35,312,134,238,538,232</code>
(<code>0x007D7432F18C89F8</code>):</p>
<pre class="text"><code>| Address | 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 |
|  Value  | F8 | 89 | 8C | F1 | 32 | 74 | 7D | 00 |</code></pre>
<p>Be aware that moving directly between two memory locations is not
allowed. To move from one location in memory to another, use a register
as a midpoint, like so:</p>
<pre class="text"><code>MVQ rg0, :MEMORY_SOURCE
MVQ :MEMORY_DESTINATION, rg0</code></pre>
<p>This also applies to pointers as well as labels (<code>rg1</code>
contains the source address, <code>rg2</code> the destination):</p>
<pre class="text"><code>MVQ rg0, *rg1
MVQ *rg2, rg0</code></pre>
<p>When using any move instruction larger than <code>MVB</code>, be
careful to ensure that not only the starting point is within the bounds
of available memory, but also all of the subsequent bytes. For example,
if you have <code>2046</code> bytes of available memory (making
<code>2045</code> the maximum address), you cannot use <code>MVQ</code>
on the starting address <code>2043</code>, as that requires at least 8
bytes.</p>
<h2 id="maths-and-bitwise-operations">Maths and Bitwise Operations</h2>
<p>Math and bitwise instructions operate <strong>in-place</strong> in
AssEmbly, meaning the first operand for the operation is also used as
the destination for the resulting value to be stored to. Destinations,
and thus the first operand, must always be a
<strong>register</strong>.</p>
<p>Mathematical and bitwise operations are always done with 64-bits,
therefore if an address (i.e. a label or pointer) is used as the second
operand, 8 bytes will be read starting at that address for the operation
in little endian encoding (see the “moving with memory” section above
for more info on little endian).</p>
<h3 id="addition-and-multiplication">Addition and Multiplication</h3>
<p>Examples of addition and multiplication:</p>
<pre class="text"><code>MVQ rg0, 55  ; Set the value of rg0 to 55
ADD rg0, 45  ; Add 45 to the value of rg0, storing in rg0
; rg0 is now 100
MUL rg0, 3  ; Multiply the value of rg0 by 3, storing in rg0
; rg0 is now 300
MVQ rg1, rg0
MUL rg1, rg0  ; Multiply the value of rg1 by the value of rg0, storing in rg1
; rg1 is now 90000</code></pre>
<p>Be aware that because there is a limit of 64-bits for mathematical
operations, if an addition or multiplication operation results in this
limit (<code>18446744073709551615</code>) being exceeded, the carry
status flag will be set to <code>1</code>, and the result will be
wrapped around back to <code>0</code>, plus however much the limit was
exceeded by.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 18446744073709551615  ; Set rg0 to the 64-bit limit
ADD rg0, 10  ; Add 10 to rg0
; rg0 is now 10

MVQ rg0, 18446744073709551590  ; Set rg0 to the 64-bit limit take 25
ADD rg0, 50  ; Add 50 to rg0
; rg0 is now 24</code></pre>
<p>In the specific case of adding <code>1</code> to a register, the
<code>ICR</code> (increment) operation can be used instead.</p>
<pre class="text"><code>MVQ rg0, 5
ICR rg0
; rg0 is now 6</code></pre>
<h3 id="subtraction">Subtraction</h3>
<p>An example of subtraction:</p>
<pre class="text"><code>MVQ rg0, 55  ; Set the value of rg0 to 55
SUB rg0, 45  ; Subtract 45 from the value of rg0, storing in rg0
; rg0 is now 10
MVQ rg1, rg0
SUB rg1, rg0  ; Subtract the value of rg0 from rg1, storing in rg1
; rg1 is now 0</code></pre>
<p>If a subtraction causes the result to go below 0, the carry status
flag will be set to <code>1</code>, and the result will be wrapped
around up to the upper limit <code>18446744073709551615</code>, minus
however much the limit was exceeded by.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 0  ; Set rg0 to 0
SUB rg0, 1  ; Subtract 1 from rg0
; rg0 is now 18446744073709551615 (-1) 

MVQ rg0, 25  ; Set rg0 to 25
SUB rg0, 50  ; Subtract 50 from rg0
; rg0 is now 18446744073709551591 (-25)</code></pre>
<p>This overflowed value can also be interpreted as a negative number
using two’s complement if desired, which is explained further in the
section on negative numbers.</p>
<p>In the specific case of subtracting <code>1</code> from a register,
the <code>DCR</code> (decrement) operation can be used instead.</p>
<pre class="text"><code>MVQ rg0, 5
DCR rg0
; rg0 is now 4</code></pre>
<h3 id="division">Division</h3>
<p>There are three types of division in AssEmbly: integer division
(<code>DIV</code>), division with remainder (<code>DVR</code>), and
remainder only (<code>REM</code>).</p>
<p>Integer division divides the first operand by the second, discards
the remainder, then stores the result in the first operand. For
example:</p>
<pre class="text"><code>MVQ rg0, 12  ; Set rg0 to 12
DIV rg0, 4  ; Divide the value in rg0 by 4, storing the result in rg0
; rg0 is now 3

MVQ rg1, 23  ; Set rg1 to 23
DIV rg1, 3  ; Divide the value in rg1 by 3, storing the result in rg1
; rg1 is now 7 (the remainder of 2 is discarded)</code></pre>
<p>Division with remainder, unlike most other operations, takes three
operands, the first two being destination registers, and the third being
the divisor. Like with the other operations, the first operand is used
as the dividend and the result for the integer part of the division. The
value of the second operand is not considered, the second operand simply
being the register to store the remainder of the division.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 12  ; Set rg0 to 12
DVR rg0, rg1, 4  ; Divide the value in rg0 by 4, storing the integer result in rg0, and remainder in rg1
; rg0 is now 3, rg1 is now 0

MVQ rg2, 23  ; Set rg2 to 23
DVR rg2, rg3, 3  ; Divide the value in rg2 by 3, storing the integer result in rg2, and remainder in rg3
; rg2 is now 7, rg3 is now 2</code></pre>
<p>Remainder only division is similar to integer division in that it
only keeps one of the results, but this time the dividend (first
operand) is overwritten by the remainder, and the integer result is
discarded:</p>
<pre class="text"><code>MVQ rg0, 12  ; Set rg0 to 12
REM rg0, 4  ; Divide the value in rg0 by 4, storing the remainder in rg0
; rg0 is now 0

MVQ rg1, 23  ; Set rg1 to 23
REM rg1, 3  ; Divide the value in rg1 by 3, storing the remainder in rg1
; rg1 is now 2 (the integer result of 7 is discarded)</code></pre>
<h3 id="shifting">Shifting</h3>
<p>Shifting is the process of moving the bits in a binary number either
up (left — <code>SHL</code>) or down (right — <code>SHR</code>) a
certain number of places.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 0b11010
; rg0:
; |  Bit  | ... | 64 | 32 | 16 | 8  | 4  | 2  | 1  |
; | Value | ... | 0  | 0  | 1  | 1  | 0  | 1  | 0  |

SHL rg0, 2
; rg0:
; |  Bit  | ... | 64 | 32 | 16 | 8  | 4  | 2  | 1  |
; | Value | ... | 1  | 1  | 0  | 1  | 0  | 0  | 0  |</code></pre>
<p>The bits were shifted 2 places to the left, and new bits on the right
were set to 0.</p>
<p>Here’s one for shifting right:</p>
<pre class="text"><code>MVQ rg0, 0b11010
; rg0:
; |  Bit  | ... | 64 | 32 | 16 | 8  | 4  | 2  | 1  |
; | Value | ... | 0  | 0  | 1  | 1  | 0  | 1  | 0  |

SHR rg0, 2
; rg0:
; |  Bit  | ... | 64 | 32 | 16 | 8  | 4  | 2  | 1  |
; | Value | ... | 0  | 0  | 0  | 0  | 1  | 1  | 0  |</code></pre>
<p>The bits were shifted 2 places to the right, and new bits on the left
were set to 0.</p>
<p>If, like with the right shift example above, a shift causes at least
one <code>1</code> bit to go off the edge (either below the first bit or
above the 64th), the carry flag will be set to <code>1</code>, otherwise
it will be set to <code>0</code>.</p>
<h3 id="bitwise">Bitwise</h3>
<p>Bitwise operations consider each bit of the operands individually
instead of as a whole number. There are three operations that take two
operands (<code>AND</code>, <code>ORR</code>, and <code>XOR</code>), and
one that takes only one (<code>NOT</code>).</p>
<p>Here are tables of how each two-operand operation will affect each
bit</p>
<p>Bitwise And (<code>AND</code>):</p>
<pre class="text"><code>    +---+---+
    | 0 | 1 |
+---+---+---+
| 0 | 0 | 0 |
+---+---+---+
| 1 | 0 | 1 |
+---+---+---+</code></pre>
<p>The <code>AND</code> operation will only set a bit to <code>1</code>
if the bit in both operands is <code>1</code>. For example:</p>
<pre class="text"><code>MVQ rg0, 0b00101
AND rg0, 0b10100
; rg0 now has a value of 0b00100</code></pre>
<p>Bitwise Or (<code>ORR</code>):</p>
<pre class="text"><code>    +---+---+
    | 0 | 1 |
+---+---+---+
| 0 | 0 | 1 |
+---+---+---+
| 1 | 1 | 1 |
+---+---+---+</code></pre>
<p>The <code>ORR</code> operation will set a bit to <code>1</code> if
the bit in either operand is <code>1</code>. For example:</p>
<pre class="text"><code>MVQ rg0, 0b00101
ORR rg0, 0b10100
; rg0 now has a value of 0b10101</code></pre>
<p>Bitwise Exclusive Or (<code>XOR</code>):</p>
<pre class="text"><code>    +---+---+
    | 0 | 1 |
+---+---+---+
| 0 | 0 | 1 |
+---+---+---+
| 1 | 1 | 0 |
+---+---+---+</code></pre>
<p>The <code>XOR</code> operation will set a bit to <code>1</code> if
the bit in one, but not both, operands is <code>1</code>. For
example:</p>
<pre class="text"><code>MVQ rg0, 0b00101
XOR rg0, 0b10100
; rg0 now has a value of 0b10001</code></pre>
<p>The <code>NOT</code> operation only takes a single operand, which
must be a register. It simply “flips” the value of each bit
(i.e. <code>1</code> becomes <code>0</code>, <code>0</code> becomes
<code>1</code>).</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 0b00101
NOT rg0
; rg0 now has a value of 0b11010</code></pre>
<h3 id="random-number-generation">Random Number Generation</h3>
<p>The random number instruction (<code>RNG</code>) takes a single
operand: the register to store the result in. The instruction always
randomises all 64-bits of a register, meaning the result could be
anywhere between 0 and 18446744073709551615.</p>
<p>Remainder only division (<code>REM</code>) by a value one higher than
the desired maximum can be used to limit the random number to a maximum
value, like so:</p>
<pre class="text"><code>RNG rg0  ; rg0 could now be any value between 0 and 18446744073709551615
REM rg0, 5  ; rg0 is now constrained between 0 and 4 depending on its initial value</code></pre>
<p>To set a minimum value also, simply add a constant value to the
result of the <code>REM</code> operation:</p>
<pre class="text"><code>RNG rg0  ; rg0 could now be any value between 0 and 18446744073709551615
REM rg0, 5  ; rg0 is now constrained between 0 and 4 depending on its initial value
ADD rg0, 5  ; rg0 is now constrained between 5 and 9</code></pre>
<h2 id="negative-numbers">Negative Numbers</h2>
<p>Negative numbers are stored using two’s complement in AssEmbly, which
means that negative values are stored as their positive counterpart with
a bitwise NOT performed, then incremented by <code>1</code>.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 9547
; rg0 is 0b0000000000000000000000000000000000000000000000000010010101001011 in binary
MVQ rg0, -9547  ; You can use a &#39;-&#39; sign anywhere a regular literal would be accepted
; rg0 is 0b1111111111111111111111111111111111111111111111111101101010110101 in binary</code></pre>
<p>To switch between the positive and negative form of a number, use the
<code>SIGN_NEG</code> instruction:</p>
<pre class="text"><code>MVQ rg0, 9547
SIGN_NEG rg0  ; Performs the equivalent of &quot;NOT rg0&quot; then &quot;ICR rg0&quot; in one instruction
; rg0 is now -9547 (or 18446744073709542069 when interpreted as unsigned)</code></pre>
<p>Stored values can be interpreted as either <strong>unsigned</strong>
or <strong>signed</strong>. Unsigned values are always positive and use
all 64 bits to store their value, giving a range of <code>0</code> to
<code>18,446,744,073,709,551,615</code>. Signed values can be either
positive <em>or</em> negative and, while still stored using 64-bits, the
highest bit is instead to store the sign. This gives a range of
<code>-9,223,372,036,854,775,808</code> to
<code>9,223,372,036,854,775,807</code> for signed operations. The number
of distinct values is the same as unsigned values, but now half of the
values are negative.</p>
<p>To check if the limits of a signed number have been exceeded after an
operation instead of the limits of an unsigned number, the
<strong>overflow flag</strong> should be used instead of the carry flag.
This is explained in detail in the dedicated section on the overflow
flag vs. the carry flag.</p>
<p>Numeric literals can be made negative by prepending the
<code>-</code> sign onto them. Much of the base instruction set can take
negative numbers as operands and work exactly as expected, though there
are some exceptions. A full table of which instructions work as expected
with negative values and which ones do not can be found toward the end
of the document, though as a general rule, if an instruction has an
equivalent that begins with <code>SIGN_</code>, you should use the
signed one instead if negative values are expected.</p>
<p>Some instructions that work normally with negative values include
<code>ADD</code>, <code>SUB</code>, and <code>MUL</code>. Some that do
not include <code>DIV</code> and <code>WCN</code>, where the distinction
between unsigned and signed values becomes important, as it will affect
the result. The <code>SIGN_DIV</code> and <code>SIGN_WCN</code>
instructions for example should be used instead when negative numbers
are possible and desired. It is worth noting that instructions in the
base instruction set (instructions not beginning with an extension like
<code>SIGN_</code>) always interpret numbers as unsigned; the reason
some operations do not need a signed counterpart to counteract this is
that the usage of two’s complement allows overflowed unsigned results
and signed results to have the same bit representation with these
compatible operations.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 12
ADD rg0, -5
; rg0 is now 7, ADD works as expected with negative values

MVQ rg0, 12
SUB rg0, -5
; rg0 is now 17, SUB works as expected with negative values

MVQ rg0, 12
DIV rg0, -6
; rg0 is NOT -2, the SIGN_DIV instruction needs to be used instead

MVQ rg0, 12
SIGN_DIV rg0, -6
; rg0 is now -2, as expected

WCN rg0
; 18446744073709551614 has been printed to the console, as WCN always assumes that the value is unsigned
SIGN_WCN rg0
; -2 has now been printed to the console, as expected</code></pre>
<p>There are other instructions that have signed equivalents, these are
simply used as an example. The signed operations also work on positive
values, so the signed equivalent of relevant instructions should always
be used wherever negative values are <em>possible</em> and desired, not
just where they are guaranteed.</p>
<h3 id="arithmetic-right-shifting">Arithmetic Right Shifting</h3>
<p>When shifting bits to the right, there are two options: logical
shifting (as explained in the previous shifting section), or arithmetic
shifting. Arithmetic shifting should be used when you wish to shift a
value whilst retaining its sign.</p>
<p>Arithmetic right shifts can be performed with the
<code>SIGN_SHR</code>, which takes the same operands as
<code>SHR</code>, but behaves slightly differently when the sign bit of
the initial value is set.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 0b11010
; rg0:
; |  Bit  | ... | 64 | 32 | 16 | 8  | 4  | 2  | 1  |
; | Value | ... | 0  | 0  | 1  | 1  | 0  | 1  | 0  |
; All omitted bits are 0

SIGN_SHR rg0, 2
; rg0:
; |  Bit  | ... | 64 | 32 | 16 | 8  | 4  | 2  | 1  |
; | Value | ... | 0  | 0  | 0  | 0  | 1  | 1  | 0  |
; All omitted bits are 0</code></pre>
<p>This behaviour is identical to <code>SHR</code>, as the value is not
signed.</p>
<p>Here’s an example with a negative value:</p>
<pre class="text"><code>MVQ rg0, -26
; rg0:
; |  Bit  | ... | 64 | 32 | 16 | 8  | 4  | 2  | 1  |
; | Value | ... | 1  | 1  | 0  | 0  | 1  | 1  | 0  |
; All omitted bits are 1

SIGN_SHR rg0, 2
; rg0:
; |  Bit  | ... | 64 | 32 | 16 | 8  | 4  | 2  | 1  |
; | Value | ... | 1  | 1  | 1  | 1  | 0  | 0  | 1  |
; All omitted bits are 1</code></pre>
<p>Because the sign bit was set in the original value, all new bits
shifted into the most significant bit were set to <code>1</code> instead
of <code>0</code>, keeping the sign of the result the same as the
initial value.</p>
<p>The behaviour of the carry flag is also altered when performing an
arithmetic shift. Where <code>SHR</code> sets the carry flag if any
<code>1</code> bit is shifted past the least significant bit and
discarded, <code>SIGN_SHR</code> instead sets the carry flag if any bits
<strong>not equal to the sign bit</strong> are discarded. This means
that for negative initial values, any <code>0</code> bit being discarded
will set the carry bit, and for positive initial values, any
<code>1</code> bit being discarded will set the carry bit.</p>
<p>Using an 8-bit number for demonstration, the behaviour of a
<strong>logical shift</strong> (<code>SHR</code>) looks like this:</p>
<pre class="text"><code>-26 &gt;&gt; 1
| 1   | 1   | 1   | 0   | 0   | 1   | 1   | 0   |-&gt; discarded bit not 1, UNSET carry flag
     \     \     \     \     \     \     \
      \     \     \     \     \     \     \
| 0   | 1   | 1   | 1   | 0   | 0   | 1   | 1   |
= 115</code></pre>
<p>Whereas the behaviour of an <strong>arithmetic shift</strong>
(<code>SIGN_SHR</code>) looks like this:</p>
<pre class="text"><code>-26 &gt;&gt; 1
| 1   | 1   | 1   | 0   | 0   | 1   | 1   | 0   |-&gt; discard not equal to sign, SET carry flag
  |  \     \     \     \     \     \     \  
  |   \     \     \     \     \     \     \ 
| 1   | 1   | 1   | 1   | 0   | 0   | 1   | 1   |
= -13</code></pre>
<h3 id="extending-smaller-signed-values">Extending Smaller Signed
Values</h3>
<p>Operations on signed numbers will always expect them to be 64-bits in
size, with the 64th bit as the sign bit. If you have a signed value
stored in a smaller format, using the 8th (byte), 16th (word), or 32nd
(double word) bits as the sign bit, you can use one of the extension
instructions (<code>SIGN_EXB</code>, <code>SIGN_EXW</code>, and
<code>SIGN_EXD</code> respectively) to convert the number to its
equivalent value in 64 bits.</p>
<p>For example:</p>
<pre class="text"><code>MVW rg0, 0b1111111101011011
; rg0 is 0b0000000000000000000000000000000000000000000000001111111101011011 in binary
; This is -165 when considering only the lower 16 bits as a signed number,
; however we need the value to occupy all 64-bits to be interpreted properly.
; As of current, even the signed instructions will read rg0 as 65371

SIGN_EXW rg0  ; SIGN_EXW is for extending 16-&gt;64, use SIGN_EXB for 8-&gt;64 or SIGN_EXD for 32-&gt;64
; rg0 is now 0b1111111111111111111111111111111111111111111111111111111101011011 in binary
; This occupies all 64-bits, so rg0 will now work correctly as -165</code></pre>
<p>Using the extending instructions with a positive value will not
affect the value of the register up to the specified size of bits,
though any bits higher than the number supported by the used extend
instruction will be set to <code>0</code> instead of <code>1</code>.</p>
<p>For example:</p>
<pre class="text"><code>MVB rg0, 12
; rg0 is 0b0000000000000000000000000000000000000000000000000000000000001100 in binary

SIGN_EXB rg0
; rg0 is unchanged

MVW rg0, 569
; rg0 is 0b0000000000000000000000000000000000000000000000000000001000111001 in binary
; rg0 doesn&#39;t fit in a single byte!

SIGN_EXB rg0
; rg0 is now 0b0000000000000000000000000000000000000000000000000000000000111001
; Any bits higher than the 8th bit have been unset, making rg0 equal to only 57</code></pre>
<p>The second example here caused part of the number to be lost as
<code>SIGN_EXB</code> was used when the value was larger than 8-bits. A
similar scenario will occur if a negative value requires more bits than
the used extend instruction can handle, though the upper bits will all
be set to <code>1</code> instead of <code>0</code> in this case.</p>
<p>Converting from a larger size of signed integer to a smaller one is
as simple as taking only the desired number of lower bits. Assuming the
value can fit within the target signed integer size’s limits, no
specific operation needs to be used.</p>
<h3 id="the-overflow-flag-vs.-the-carry-flag">The Overflow Flag vs. the
Carry Flag</h3>
<p>As explained earlier, during most mathematical operations the carry
flag is set whenever a subtraction goes below <code>0</code>, or an
addition goes above <code>18446744073709551615</code>. This is useful in
unsigned arithmetic, as it will inform you when the result of an
operation is not mathematically correct, however in signed arithmetic,
it cannot be used for this purpose. To overcome this, the status flag
register also contains an <strong>overflow flag</strong>. This flag is
set specifically when the result of an operation is incorrect when
interpreted as a <em>signed</em> value. It has no useful meaning during
unsigned arithmetic.</p>
<p>Some examples:</p>
<pre class="text"><code>MVQ rg0, 10
SUB rg0, 5
; As unsigned, rg0 is now 5. As signed it is also 5.
; Carry flag has been UNSET, answer is correct as unsigned.
; Overflow flag has been UNSET, answer is correct as signed.

MVQ rg0, 0
SUB rg0, 5
; As unsigned, rg0 is now 18446744073709551611. As signed it is -5.
; Carry flag has been SET, answer is incorrect as unsigned.
; Overflow flag has been UNSET, answer is correct as signed.

MVQ rg0, 0x7FFFFFFFFFFFFFFF  ; (hexadecimal for 9223372036854775807 as both signed and unsigned)
ADD rg0, 5
; As unsigned, rg0 is now 9223372036854775812. As signed it is -9223372036854775804.
; Carry flag has been UNSET, answer is correct as unsigned.
; Overflow flag has been SET, answer is incorrect as signed.

MVQ rg0, 0x7FFFFFFFFFFFFFFF
SUB rg0, 0xFFFFFFFFFFFFFFFF
; As unsigned, rg0 is now 9223372036854775808. As signed it is -9223372036854775808.
; Carry flag has been SET, answer is incorrect as unsigned.
; Overflow flag has been SET, answer is incorrect as signed.</code></pre>
<h2 id="floating-point-numbers">Floating Point Numbers</h2>
<p>AssEmbly has instructions to perform operations on floating point
values. These instructions work with the IEEE 754 double-precision
floating point format (also known as <code>float64</code> or
<code>double</code>). In this format, values, including whole numbers,
are stored using an entirely different format from regular integer
values, which means that, unlike with signed values, very little of the
base instruction set can work with floating point values. Instead,
instructions in the floating point instruction set (mnemonics starting
with <code>FLPT_</code>) must be used. There is a full table towards the
end of the document that details which instructions accept which formats
of data.</p>
<p>To make an integer literal into a floating point literal, it must
contain a decimal point (<code>.</code>). Any numeric literal containing
a decimal point will be assembled into a 64-bit float.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 5
; rg0 is 0x0000000000000005, which cannot be used in floating point operations

MVQ rg0, 5.0  ; The trailing 0 can be omitted to just have &quot;5.&quot; if desired
; rg0 is 0x4014000000000000, or 5.0 in double floating point format,
; and can now be used in floating point operations</code></pre>
<h3 id="floating-point-math">Floating Point Math</h3>
<p>There are floating point equivalents of all the math operations in
the base instruction set, as well as some additional mathematical
operations exclusive to floating point values. Integers and floating
point values <em>cannot</em> be mixed when performing floating point
operations; any integer values must be converted to a float first, as
explained in the following section.</p>
<p>Some examples of basic floating point math:</p>
<pre class="text"><code>MVQ rg0, 5.7
FLPT_ADD rg0, 3.2
FLPT_WCN rg0
; &quot;8.9&quot; is printed to the console

MVQ rg1, -12.3
FLPT_MUL rg0, rg1
FLPT_WCN rg0
; &quot;-109.47000000000001&quot; is printed to the console (note the floating point inaccuracy)

MVQ rg0, 1.0
FLPT_DIV rg0, 3.0
FLPT_WCN rg0
; &quot;0.3333333333333333&quot; is printed to the console</code></pre>
<p>As can be seen with the second operation, floating point values
cannot always represent decimal numbers with 100% accuracy, and may
sometimes be off by a tiny fractional amount when converted to and from
base 10.</p>
<p>Operations exclusive to floating point include trigonometric
functions (i.e. Sine, Cosine, and Tangent and their inverses),
single-instruction exponentiation, and logarithms. The trigonometric
functions all operate on <strong>radians</strong> (a full circle is
<code>2 * PI</code> radians). You can convert degrees to radians by
multiplying the degrees by <code>0.017453292519943295</code>
(<code>PI / 180</code>), and you can convert radians to degrees by
multiplying the radians by <code>57.295779513082323</code>
(<code>180 / PI</code>).</p>
<p>Some examples:</p>
<pre class="text"><code>MVQ rg0, 5.0
FLPT_POW rg0, 2.0
FLPT_WCN rg0
; &quot;25&quot; is printed to the console

FLPT_LOG rg0, 5.0
FLPT_WCN rg0
; &quot;2&quot; is printed to the console

FLPT_SIN rg0
FLPT_WCN rg0
; &quot;0.9092974268256817&quot; is printed to the console</code></pre>
<h3 id="converting-between-integers-and-floats">Converting Between
Integers and Floats</h3>
<p>Because integers and floating point values are stored in separate
formats and are not implicitly compatible, you must explicitly convert
between them to have data in the format expected by each instruction
being used.</p>
<p>There are two instructions for converting integers to floats:
<code>FLPT_UTF</code> and <code>FLPT_STF</code>. These interpret the
integer value of a register as either unsigned or signed respectively,
and convert it to its closest equivalent in floating point format. Be
aware that integers that require more than 53 bits to represent as an
integer may not be converted to an identical value as a float, due to
precision limitations with large numbers in the double-precision
floating point format.</p>
<p>Examples of integer to float conversion:</p>
<pre class="text"><code>MVQ rg0, 5
; rg0 is 0x0000000000000005, which cannot be used in floating point operations

FLPT_UTF rg0  ; FLPT_STF would produce the same result in this case
; rg0 is 0x4014000000000000, or 5.0 in double floating point format,
; and can now be used in floating point operations

MVQ rg0, -8
; rg0 is 0xFFFFFFFFFFFFFFF8
FLPT_STF rg0
; rg0 is 0xC020000000000000 (-8.0)

MVQ rg0, -8
; rg0 is 0xFFFFFFFFFFFFFFF8
FLPT_UTF rg0
; rg0 is 0x43F0000000000000 (18446744073709552000.0)</code></pre>
<p>There are four instructions for converting floats to integers:
<code>FLPT_FTS</code>, <code>FLPT_FCS</code>, <code>FLPT_FFS</code>, and
<code>FLPT_FNS</code>. These convert a floating point value to an
integer which can be interpreted as signed, using one of four rounding
methods respectively: truncation (rounding toward zero), ceiling
(rounding to the greater adjacent integer), floor (rounding to the
lesser adjacent integer), and nearest (rounding to the closest integer,
with exact midpoints being rounded to the adjacent integer that is
even).</p>
<p>Examples of float to integer conversion:</p>
<pre class="text"><code>MVQ rg0, 5.7
FLPT_FTS rg0
SIGN_WCN rg0
; &quot;5&quot; is printed to console

MVQ rg0, 5.7
FLPT_FCS rg0
SIGN_WCN rg0
; &quot;6&quot; is printed to console

MVQ rg0, 5.7
FLPT_FFS rg0
SIGN_WCN rg0
; &quot;5&quot; is printed to console

MVQ rg0, 5.7
FLPT_FNS rg0
SIGN_WCN rg0
; &quot;6&quot; is printed to console

MVQ rg0, -5.7
FLPT_FTS rg0
SIGN_WCN rg0
; &quot;-5&quot; is printed to console

MVQ rg0, -5.7
FLPT_FCS rg0
SIGN_WCN rg0
; &quot;-5&quot; is printed to console

MVQ rg0, -5.7
FLPT_FFS rg0
SIGN_WCN rg0
; &quot;-6&quot; is printed to console

MVQ rg0, -5.7
FLPT_FNS rg0
SIGN_WCN rg0
; &quot;-6&quot; is printed to console</code></pre>
<p>Some further examples of <code>FLPT_FNS</code> with midpoint and
lower values:</p>
<pre class="text"><code>MVQ rg0, 5.5
FLPT_FNS rg0
SIGN_WCN rg0
; &quot;6&quot; is printed to console

MVQ rg0, 6.5
FLPT_FNS rg0
SIGN_WCN rg0
; &quot;6&quot; is printed to console

MVQ rg0, 2.5
FLPT_FNS rg0
SIGN_WCN rg0
; &quot;2&quot; is printed to console

MVQ rg0, 3.5
FLPT_FNS rg0
SIGN_WCN rg0
; &quot;4&quot; is printed to console

MVQ rg0, 12.4
FLPT_FNS rg0
SIGN_WCN rg0
; &quot;12&quot; is printed to console

MVQ rg0, 3.2
FLPT_FNS rg0
SIGN_WCN rg0
; &quot;3&quot; is printed to console</code></pre>
<h3 id="converting-between-floating-point-sizes">Converting Between
Floating Point Sizes</h3>
<p>Floating point operations work solely on 64-bit floating point
values, however there are other common sizes of floating point value
which you may wish to convert between. There are instructions to convert
to and from the half-precision (16-bit) and single-precision (32-bit)
IEEE 754 floating point formats. To convert <strong>to</strong> a
double-precision float, the <code>FLPT_EXH</code> and
<code>FLPT_EXS</code> instructions are used to convert from
half-precision and single-precision floats respectively. To convert
<strong>from</strong> a double-precision float, the
<code>FLPT_SHH</code> and <code>FLPT_SHS</code> instructions are used to
convert to half-precision and single-precision floats respectively. You
cannot convert directly between half- and single-precision floats
without converting to a double-precision float first.</p>
<p>Here are some examples of direct conversion:</p>
<pre class="text"><code>MVQ rg0, 0x4248  ; 3.141 as a half-precision float
; rg0 cannot currently be used with floating point operations
FLPT_EXH rg0
; rg0 is now 0x4009200000000000 (3.140625) and can be used in floating point operations

MVQ rg0, 0x40490FDB  ; 3.1415927 as a single-precision float
; rg0 cannot currently be used with floating point operations
FLPT_EXS rg0
; rg0 is now 0x400921FB60000000 (3.14159274101257) and can be used in floating point operations

MVQ rg0, 3.141592653589793
; rg0 is 0x400921FB54442D18
FLPT_SHH rg0
; rg0 is now 0x4248 (3.141 as a half-precision float)

MVQ rg0, 3.141592653589793
; rg0 is 0x400921FB54442D18
FLPT_SHS rg0
; rg0 is now 0x40490FDB (3.1415927 as a single-precision float)</code></pre>
<p>And one for converting a single-precision to a half-precision
float:</p>
<pre class="text"><code>MVQ rg0, 0x40490FDB  ; 3.1415927 as a single-precision float
FLPT_EXS rg0
; rg0 is now 0x400921FB60000000 (3.14159274101257)
FLPT_SHH rg0
; rg0 is now 0x4248 (3.141 as a half-precision float)</code></pre>
<h2 id="jumping">Jumping</h2>
<p>Jumping is the processes of changing where the processor is currently
executing in a program (represented with the <code>rpo</code> register).
Jumps can be used to make loops, execute code if only a certain
condition is met, or to reuse code, such as with subroutines. After a
jump, the processor will continue to execute instructions from the new
location, it will not automatically return to where it was before.</p>
<p>Jumps are usually made to labels, like so:</p>
<pre class="text"><code>MVQ rg0, 0  ; Set rg0 to 0
:ADD_LOOP  ; Create a label to the following instruction (ADD)
ADD rg0, 5  ; Add 5 to the current value of rg0
JMP :ADD_LOOP  ; Go back to ADD_LOOP and continue executing from there</code></pre>
<p>This program will set rg0 to 0, then infinitely keep adding 5 to the
register by jumping back to the <code>ADD_LOOP</code> label. To only
jump some of the time, for example to create a conditional loop, see the
following section on branching.</p>
<p>Here is another example of a jump:</p>
<pre class="text"><code>MVQ rg0, 0
ADD rg0, 5
JMP :SKIP
ADD rg0, 5  ; This won&#39;t be executed
ADD rg0, 5  ; This won&#39;t be executed
:SKIP
; rg0 is 5 here</code></pre>
<p><code>rg0</code> only ends up being 5 at the end of this example, as
jumping to the <code>SKIP</code> label prevented the two other
<code>ADD</code> instructions from being reached.</p>
<p>Jumps can also be made to pointers, though you must be sure that the
pointer will contain the address of a valid opcode before jumping
there.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, :&amp;MY_CODE  ; Move the literal address of MY_CODE to rg0
JMP *rg0  ; Jump to that address
MVQ rg0, 5  ; This won&#39;t be executed
:MY_CODE
MVQ rg0, 17
; rg0 will be 17, not 5</code></pre>
<h2 id="comparing-testing-and-branching">Comparing, Testing, and
Branching</h2>
<p>Branching is similar to jumping in that it changes where in the
program execution is currently taking place, however, when branching, a
condition is checked first before performing the jump. If the condition
is not met, the program will continue execution as normal without
jumping anywhere.</p>
<p>The conditional jump instructions are as follows:</p>
<pre class="text"><code>+----------+----------------------------------+
| Mnemonic | Meaning                          |
+----------+----------------------------------+
| JEQ      | Jump if Equal                    |
| JNE      | Jump if not Equal                |
| JLT      | Jump if Less Than                |
| JLE      | Jump if Less Than or Equal To    |
| JGT      | Jump if Greater Than             |
| JGE      | Jump if Greater Than or Equal To |
+----------+----------------------------------+
| JZO      | Jump if Zero (=JEQ)              |
| JNZ      | Jump if not Zero (=JNE)          |
| JCA      | Jump if Carry (=JLT)             |
| JNC      | Jump if no Carry (=JGE)          |
+----------+----------------------------------+
| SIGN_JLT | Jump if Less Than                |
| SIGN_JLE | Jump if Less Than or Equal To    |
| SIGN_JGT | Jump if Greater Than             |
| SIGN_JGE | Jump if Greater Than or Equal To |
+----------+----------------------------------+
| SIGN_JSI | Jump if Sign                     |
| SIGN_JNS | Jump if not Sign                 |
| SIGN_JOV | Jump if Overflow                 |
| SIGN_JNO | Jump if not Overflow             |
+----------+----------------------------------+</code></pre>
<p>The top section of instructions should be performed following a
<code>CMP</code> operation on unsigned values, or a
<code>FLPT_CMP</code> operation on floating point values. The
instructions in the second section are aliases of four of the mnemonics
in the top section (i.e. they share the same opcode) designed for use
after mathematical operations or for bit testing (explained more in the
relevant sections).</p>
<p>The bottom two sections are part of the signed extension set, with
the higher of the two being designed for use following a
<code>CMP</code> instruction on signed values, and the bottom section
being for use specifically to branch based on the state of the sign or
overflow flags.</p>
<h3 id="comparing-unsigned-numbers">Comparing Unsigned Numbers</h3>
<p>To branch based on how two unsigned (always positive) numbers relate
to each other, the <code>CMP</code> instruction can be utilised. It
takes two operands (the first of which must be a register — it won’t be
modified), and compares them for use with a conditional jump instruction
immediately afterwards.</p>
<p>For example:</p>
<pre class="text"><code>RNG rg0  ; Set rg0 to a random number
CMP rg0, 1000  ; Compare rg0 to 1000
JGT :GREATER  ; Jump straight to GREATER if rg0 is greater than 1000
ADD rg0, 1000  ; This will execute only if rg0 is less than or equal to 1000
:GREATER
SUB rg0, 1000  ; This will execute in either situation</code></pre>
<p>Be aware that the <code>GREATER</code> label will still be reached if
<code>rg0</code> is less than or equal to <code>1000</code> here, the
<code>ADD</code> instruction will just be executed first.</p>
<p>To have the contents of the <code>GREATER</code> label execute
<strong>only</strong> if <code>rg0</code> is greater than
<code>1000</code>, include an unconditional jump like so:</p>
<pre class="text"><code>RNG rg0  ; Set rg0 to a random number
CMP rg0, 1000  ; Compare rg0 to 1000
JGT :GREATER  ; Jump straight to GREATER if rg0 is greater than 1000
ADD rg0, 1000  ; This will execute only if rg0 is less than or equal to 1000
JMP :END  ; Jump straight to END to prevent GREATER section being executed
:GREATER
SUB rg0, 1000  ; This will execute only if rg0 is greater than 1000
:END</code></pre>
<p>The <code>CMP</code> instruction works by subtracting the second
operand from the first, but not storing the result anywhere. This
operation still updates the status flags (<code>rsf</code>) however, and
these can be used to check how the numbers relate. For example, if the
second operand is greater than the first, you can guarantee that the
operation will set the carry flag, as it would cause the result to be
negative. This means to check if the first is greater than or equal to
the second, you can simply check if the carry flag was unset. To check
if the values were equal, the zero flag can be checked, as if the two
operands of a subtraction are equal, the result will always be zero.</p>
<p>A full list of what each conditional jump instruction is checking for
in terms of the status flags can be found in the full instruction
reference.</p>
<h3 id="comparing-signed-numbers">Comparing Signed Numbers</h3>
<p>The <code>CMP</code> instruction can also be used to compare signed
(negative and positive) values, with its usage and behaviour remaining
unchanged. After using the <code>CMP</code> instruction, however, you
should use the signed version of the base conditional jump instructions,
e.g. <code>SIGN_JLT</code> instead of <code>JLT</code>. The only
exception to this is <code>JEQ</code> and <code>JNE</code>, which do not
have signed versions, as they work with both signed and unsigned
values.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 25
MVQ rg1, -6
CMP rg0, rg1
SIGN_JGT :GREATER
WCN 10  ; This will not execute, 25 is greater than -6
:GREATER
WCN 20  ; This will execute
; Only &quot;20&quot; is output to the console</code></pre>
<p>And what would happen if the regular <code>JGT</code> instruction was
used:</p>
<pre class="text"><code>MVQ rg0, 25
MVQ rg1, -6
CMP rg0, rg1
JGT :GREATER
WCN 10  ; This will execute, even though 25 is greater than -6
:GREATER
WCN 20  ; This will execute
; &quot;1020&quot; is output to the console, -6 was interpreted instead as 18446744073709551610</code></pre>
<p>Here the comparison doesn’t work as expected because the conditional
jump used (<code>JGT</code>) only works assuming the comparison was
intended to be unsigned. The signed versions of these instructions (like
<code>SIGN_JGT</code>) use the state of the sign, overflow, and zero
status flags so that they work as expected when used after signed
comparisons. A full list of what each conditional jump instruction is
checking for in terms of the status flags can be found in the full
instruction reference.</p>
<h3 id="comparing-floating-point-numbers">Comparing Floating Point
Numbers</h3>
<p>To compare two floating point values, the <code>FLPT_CMP</code>
instruction needs to be used instead of the <code>CMP</code>
instruction. After using <code>FLPT_CMP</code>, the
<strong>unsigned</strong> version of the desired conditional jump should
be used, <strong>even if one or both of the floating point values were
negative</strong>. There are no dedicated conditional jump instructions
for floating point values.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 25.4
MVQ rg1, -6.3
FLPT_CMP rg0, rg1
JGT :GREATER
WCN 10  ; This will not execute, 25.4 is greater than -6.3
:GREATER
WCN 20  ; This will execute
; Only &quot;20&quot; is output to the console</code></pre>
<p><code>FLPT_CMP</code> updates the status flags with the unsigned
conditional jumps in mind. If the first operand is less than the second,
the carry flag is set. If they are equal, the zero flag is set. The
overflow flag is always <code>0</code> after using
<code>FLPT_CMP</code>.</p>
<h3 id="testing-bits">Testing Bits</h3>
<p>To test if a single bit of a number is set or not, the
<code>TST</code> instruction can be used. Just like <code>CMP</code>, it
takes two operands, the first of which being a register. The second
should usually be a binary literal with only a single bit (the one to
check) set as 1. It should then be followed by either <code>JZO</code>
(jump if zero), or <code>JNZ</code> (jump if not zero). An example of
where this may be used is checking if the third bit of <code>rsf</code>
is set (the file end flag), as there isn’t a built-in conditional jump
that checks this flag.</p>
<p>This would be done like so:</p>
<pre class="text"><code>:READ
RFC rg0  ; Read the next byte from the open file to rg0
TST rsf, 0b100  ; Check if the third bit is set
JZO :READ  ; If it isn&#39;t set (i.e. it is equal to 0), jump back to READ</code></pre>
<p>This program will keep looping until the third bit of
<code>rsf</code> becomes <code>1</code>. meaning that the end of the
file has been reached.</p>
<p>Similarly to <code>CMP</code>, <code>TST</code> works by performing a
bitwise and on the two operands, discarding the result, but still
updating the status flags. A bitwise and will ensure that only the bit
you want to check remains as <code>1</code>, but only if it started as
<code>1</code>. If a bit is not one that you are checking, or it wasn’t
<code>1</code> to start with, it will end up as <code>0</code>. If the
resulting number isn’t zero, leaving the zero flag unset, the bit
must’ve been <code>1</code>, and vice versa.</p>
<h3 id="checking-the-carry-overflow-zero-and-sign-flags">Checking the
Carry, Overflow, Zero, and Sign Flags</h3>
<p>The carry, overflow, zero, and sign flags also have specific jump
operations that can check if they are currently set or unset.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, 5
SUB rg0, 10
JCA :CARRY  ; Jump to label if carry flag is set
WCN 10  ; This will not execute, as 5 SUB 10 will cause the carry flag to be set
:CARRY
WCN 20
; Only &quot;20&quot; will be written to the console</code></pre>
<p><code>JCA</code> here is checking if the carry flag is set or not
following the subtraction. The jump will only occur if the carry flag is
<code>1</code> (set), otherwise, as with the other jump types, execution
will continue as normal. <code>JNC</code> can be used to perform the
inverse, jump only if the carry flag is unset.</p>
<p>The zero flag checks can also be used following a mathematical
operation like so:</p>
<pre class="text"><code>SUB rg0, 7  ; Subtract 7 from rg0
JNZ :NOT_ZERO  ; Jump straight to NOT_ZERO if rg0 didn&#39;t become 0
ADD rg0, 1  ; Only execute this if rg0 became 0 because of the SUB operation
:NOT_ZERO</code></pre>
<p>The <code>ADD</code> instruction here will only execute if the
subtraction by 7 caused <code>rg0</code> to become exactly equal to
<code>0</code>.</p>
<p>The <code>SIGN_JOV</code>, <code>SIGN_JNO</code>,
<code>SIGN_JSI</code>, and <code>SIGN_JNS</code> instructions can be
used to check if the overflow and sign flags are set and unset
respectively in the same way:</p>
<pre class="text"><code>SUB rg0, 7  ; Subtract 7 from rg0
SIGN_JNS :NOT_NEGATIVE  ; Jump straight to NOT_NEGATIVE if rg0 didn&#39;t become negative
SIGN_NEG rg0  ; Only execute this if rg0 became negative because of the SUB operation
:NOT_NEGATIVE
; rg0 is now the absolute result</code></pre>
<p>An equivalent of the first example, but for the overflow flag instead
of the carry flag, as should be used for signed operations:</p>
<pre class="text"><code>MVQ rg0, 5
SUB rg0, 10
JOV :OVERFLOW  ; Jump to label if overflow flag is set
WCN 10  ; This will execute, as 5 SUB 10 will not cause the overflow flag to be set
:OVERFLOW
WCN 20
; &quot;1020&quot; will be written to the console</code></pre>
<h2 id="assembler-directives">Assembler Directives</h2>
<p>Assembler directives follow the same format as standard instructions,
however, instead of being assembled to an opcode for the processor to
execute, they tell the assembler itself to do something to modify either
the final binary file or the lines of the source file as its being
assembled.</p>
<h3 id="pad-byte-padding"><code>PAD</code> — Byte Padding</h3>
<p>The <code>PAD</code> directive tells the assembler to insert a
certain number of <code>0</code> bytes wherever the directive is placed
in the file. This is most often used just after a label definition to
allocate a certain amount of guaranteed free and available memory to
store data.</p>
<p>For example, consider the following program:</p>
<pre class="text"><code>MVQ rg0, :&amp;PADDING  ; Store the address of the padding in rg0
JMP :PROGRAM  ; Jump to the next part of the program, skipping over the padding

:PADDING
PAD 16  ; Insert 16 empty bytes

:PROGRAM
MVQ *rg0, 765  ; Set the first 8 bytes of the padding to represent 765
ADD rg0, 8  ; Add 8 to rg0, it now points to the next number</code></pre>
<p>This program would assemble to the following bytes:</p>
<pre class="text"><code>99 06 13 00 00 00 00 00 00 00 02 23 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 9F 06 FD 02 00 00 00 00 00 00 11 06 08 00 00 00 00 00 00 00</code></pre>
<p>Which can be broken down to:</p>
<pre class="text"><code>Address | Bytes
--------+----------------------------------------------------
 0x00   | 99             | 06  | 13 00 00 00 00 00 00 00
        | MVQ (reg, lit) | rg0 | :PADDING (address 0x13)
--------+----------------------------------------------------
 0x0A   | 02  | 23 00 00 00 00 00 00 00
        | JMP | :PROGRAM (address 0x23)
--------+----------------------------------------------------
 0x13   | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
        | PAD 16
--------+----------------------------------------------------
 0x23   | 9F             | 06   | FD 02 00 00 00 00 00 00
        | MVQ (ptr, lit) | *rg0 | 765 (0x2FD)
--------+----------------------------------------------------
 0x2D   | 11  | 06  | 08 00 00 00 00 00 00 00
        | ADD | rg0 | 8</code></pre>
<p>Note that usually, to reduce the number of jumps required,
<code>PAD</code>s would be placed after all program instructions. It was
put in the middle of the program here for demonstration purposes.</p>
<h3 id="dat-byte-insertion"><code>DAT</code> — Byte Insertion</h3>
<p>The <code>DAT</code> directive inserts either a single byte, or a
string of UTF-8 character bytes, into a program wherever the directive
is located. As with <code>PAD</code>, it can be directly preceded by a
label definition to point to the byte or string of bytes. If not being
used with a string, <code>DAT</code> can only insert single bytes at
once, meaning the maximum value is 255. It is also not suitable for
inserting numbers to be used in 64-bit expecting operations (such as
maths and bitwise), see the following section on the <code>NUM</code>
directive for inserting 64-bit numbers.</p>
<p>An example of single byte insertion:</p>
<pre class="text"><code>MVB rg0, :BYTE  ; MVB must be used, as DAT will not insert a full 64-bit number
; rg0 is now 54
HLT  ; Stop the program executing into the DAT insertion (important!)

:BYTE
DAT 54  ; Insert a single 54 byte (0x36)</code></pre>
<p>This program assembles into the following bytes:</p>
<pre class="text"><code>82 06 0B 00 00 00 00 00 00 00 00 36</code></pre>
<p>Which can be broken down to:</p>
<pre class="text"><code>Address | Bytes
--------+----------------------------------------------------
 0x00   | 82             | 06  | 0B 00 00 00 00 00 00 00
        | MVB (reg, adr) | rg0 | :BYTE (address 0x0B)
--------+----------------------------------------------------
 0x0A   | 00
        | HLT
--------+----------------------------------------------------
 0x0B   | 36
        | DAT 54</code></pre>
<p>To insert a string using <code>DAT</code>, the desired characters
must be surrounded by quotation marks (<code>"</code>) and be given as
the sole operand to the directive. For example:</p>
<pre class="text"><code>MVQ rg0, :&amp;STRING  ; Move literal address of string to rg0
:STRING_LOOP
MVB rg1, *rg0  ; Move contents of address stored in rg0 to rg1
CMP rg1, 0  ; Check if rg1 is 0
JEQ :END  ; If it is, stop program
ICR rg0  ; Otherwise, increment source address by 1
WCC rg1  ; Write the read character to the console
JMP :STRING_LOOP  ; Loop back to print next character

:END
HLT  ; End execution to stop processor running into string data

:STRING
DAT &quot;Hello!\0&quot;  ; Store a string of character bytes after program data.
; Note that the string ends with &#39;\0&#39; (a 0 or &quot;null&quot; byte)</code></pre>
<p>This program will loop through the string, placing the byte value of
each character in <code>rg0</code> and writing it to the console, until
it reaches the 0 byte, when it will then stop to avoid looping
infinitely. While not a strict requirement, terminating a string with a
0 byte like this should always be done to give an easy way of knowing
when the end of a string has been reached. Placing a <code>DAT 0</code>
directive on the line after the string insertion will also achieve this
0 termination, and will result in the exact same bytes being assembled,
however using the <code>\0</code> escape sequence is more compact.
Escape sequences are explained after this example.</p>
<p>The example program assembles down to the following bytes:</p>
<pre class="text"><code>99 06 2E 00 00 00 00 00 00 00 83 07 06 75 07 00 00 00 00 00 00 00 00 04 2D 00 00 00 00 00 00 00 14 06 CC 07 02 0A 00 00 00 00 00 00 00 00 48 65 6C 6C 6F 21 00</code></pre>
<p>Which can be broken down to:</p>
<pre class="text"><code>Address | Bytes
--------+----------------------------------------------------
 0x00   | 99             | 06  | 2E 00 00 00 00 00 00 00
        | MVQ (reg, lit) | rg0 | :STRING (address 0x2E)
--------+----------------------------------------------------
 0x0A   | 83             | 07  | 06
        | MVB (reg, ptr) | rg1 | *rg0
--------+----------------------------------------------------
 0x0D   | 75             | 07  | 00 00 00 00 00 00 00 00
        | CMP (reg, lit) | rg1 | 0
--------+----------------------------------------------------
 0x17   | 04        | 2D 00 00 00 00 00 00 00
        | JEQ (adr) | :END (address 0x2D)
--------+----------------------------------------------------
 0x20   | 14        | 06
        | ICR (reg) | rg0
--------+----------------------------------------------------
 0x22   | CC        | 07
        | WCC (reg) | rg1
--------+----------------------------------------------------
 0x24   | 02        | 0A 00 00 00 00 00 00 00
        | JMP (adr) | :STRING_LOOP (address 0x0A)
--------+----------------------------------------------------
 0x2D   | 00
        | HLT
--------+----------------------------------------------------
 0x2E   | 48 65 6C 6C 6F 21 00
        | DAT &quot;Hello!\0&quot;</code></pre>
<h4 id="escape-sequences">Escape Sequences</h4>
<p>There are some sequences of characters that have special meanings
when found inside a string. Each of these begins with a backslash
(<code>\</code>) character and are used to insert characters into the
string that couldn’t be inserted normally. Every supported sequence is
as follows:</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 13%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th>Escape sequence</th>
<th>Character name</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>\"</code></td>
<td>Double quote</td>
<td>Used to insert a double quote into the string without causing the
string to end.</td>
</tr>
<tr class="even">
<td><code>\\</code></td>
<td>Backslash</td>
<td>For a string to contain a backslash, you must escape it so it isn’t
treated as the start of an escape sequence.</td>
</tr>
<tr class="odd">
<td><code>\0</code></td>
<td>Null</td>
<td>ASCII 0x00. Should be used to terminate every string.</td>
</tr>
<tr class="even">
<td><code>\a</code></td>
<td>Alert</td>
<td>ASCII 0x07.</td>
</tr>
<tr class="odd">
<td><code>\b</code></td>
<td>Backspace</td>
<td>ASCII 0x08.</td>
</tr>
<tr class="even">
<td><code>\f</code></td>
<td>Form feed</td>
<td>ASCII 0x0C.</td>
</tr>
<tr class="odd">
<td><code>\n</code></td>
<td>Newline</td>
<td>ASCII 0x0A. Will cause the string to move onto a new console/file
line when printed. Should be preceded by <code>\r</code> on
Windows.</td>
</tr>
<tr class="even">
<td><code>\r</code></td>
<td>Carriage return</td>
<td>ASCII 0x0D.</td>
</tr>
<tr class="odd">
<td><code>\t</code></td>
<td>Horizontal tab</td>
<td>ASCII 0x09.</td>
</tr>
<tr class="even">
<td><code>\v</code></td>
<td>Vertical tab</td>
<td>ASCII 0x0B.</td>
</tr>
<tr class="odd">
<td><code>\u....</code></td>
<td>Unicode codepoint (16-bit)</td>
<td>Inserts the unicode character with a codepoint represented by 4
hexadecimal digits in the range <code>0x0000</code> to
<code>0xFFFF</code>.</td>
</tr>
<tr class="even">
<td><code>\U........</code></td>
<td>Unicode codepoint (32-bit)</td>
<td>Inserts the unicode character with a codepoint represented by 8
hexadecimal digits in the range <code>0x00000000</code> to
<code>0x0010FFFF</code>, excluding <code>0x0000d800</code> to
<code>0x0000dfff</code>.</td>
</tr>
<tr class="odd">
<td><code>\'</code></td>
<td>Single quote</td>
<td>Included for future expansion. Not currently required - simply type
a <code>'</code> character instead.</td>
</tr>
</tbody>
</table>
<h3 id="num-number-insertion"><code>NUM</code> — Number Insertion</h3>
<p>The <code>NUM</code> directive is similar to <code>DAT</code>, except
it always inserts 8 bytes exactly, so can be used to represent 64-bit
numbers for use in instructions which always work on 64-bit values, like
maths and bitwise operations. <code>NUM</code> cannot be used to insert
strings, only single 64-bit numerical values (including unsigned,
signed, and floating point).</p>
<p>An example:</p>
<pre class="text"><code>MVQ rg0, 115  ; Initialise rg0 to 15
ADD rg0, :NUMBER  ; Add the number stored in memory to rg0
; rg0 is now 100130
HLT  ; End execution to stop processor running into number data

:NUMBER
NUM 100_015  ; Insert the number 100015 with 8 bytes</code></pre>
<p>Which will produce the following bytes:</p>
<pre class="text"><code>99 06 73 00 00 00 00 00 00 00 12 06 15 00 00 00 00 00 00 00 00 AF 86 01 00 00 00 00 00</code></pre>
<p>Breaking down into:</p>
<pre class="text"><code>Address | Bytes
--------+----------------------------------------------------
 0x00   | 99             | 06  | 73 00 00 00 00 00 00 00
        | MVQ (reg, lit) | rg0 | 115 (0x73)
--------+----------------------------------------------------
 0x0A   | 12             | 06  | 15 00 00 00 00 00 00 00
        | ADD (reg, adr) | rg0 | :NUMBER (address 0x15)
--------+----------------------------------------------------
 0x14   | 00
        | HLT
--------+----------------------------------------------------
 0x15   | AF 86 01 00 00 00 00 00
        | NUM 100_015 (0x186AF)</code></pre>
<p>As with other operations in AssEmbly, <code>NUM</code> stores numbers
in memory using little endian encoding. See the section on moving with
memory for more info on how this encoding works.</p>
<h3 id="mac-macro-definition"><code>MAC</code> — Macro Definition</h3>
<p>The <code>MAC</code> directive defines a <strong>macro</strong>, a
piece of text that the assembler will replace with another on every line
where the text is present. The directive takes the text to replace as
the first operand, then the text for it to be replaced with as the
second. Macros only take effect on lines after the one where they are
defined, and they can be overwritten to change the replacement text by
defining a new macro with the same name as a previous one. Unlike other
instructions, the operands to the <code>MAC</code> directive don’t have
to be a standard valid format of operand, both will automatically be
interpreted as literal text.</p>
<p>For example:</p>
<pre class="text"><code>MVQ rg0, Number  ; Results in an error

MAC Number, 345
MVQ rg0, Number
; rg0 is now 345

MAC Number, 678
MVQ rg1, Number
; rg1 is now 678

MAC Inst, ICR rg1
Inst
; rg1 is now 679

MAC Inst, ADD rg1, 6
Inst
; rg1 is now 685</code></pre>
<p>The first line here results in an error, as a macro with a name of
<code>Number</code> hasn’t been defined yet (macros don’t apply
retroactively). <code>MVQ rg0, Number</code> gets replaced with
<code>MVQ rg0, 345</code>, setting <code>rg0</code> to <code>345</code>.
<code>MVQ rg1, Number</code> gets replaced with
<code>MVQ rg1, 678</code>, as the <code>Number</code> macro was
redefined on the line before, setting <code>rg1</code> to
<code>678</code>. <code>Inst</code> gets replaced with
<code>ICR rg1</code>, incrementing <code>rg1</code> by <code>1</code>,
therefore setting it to <code>679</code> (macros can contain spaces and
can be used to give another name to mnemonics, or even entire
instructions, as seen in the last example).</p>
<p>Note that macro definitions ignore many standard syntax rules due to
each operand being interpreted as literal text. Both operands can
contain whitespace, and the second operand may contain commas. They are
case sensitive, and macros with the same name but different
capitalisations can exist simultaneously. Be aware that aside from a
<strong>single</strong> space character separating the <code>MAC</code>
mnemonic from its operands, leading and trailing whitespace in either of
the operands will not be removed. Macros can also contain quotation
marks (<code>"</code>), which will not be immediately parsed as a string
within the macro. If the quotation marks are placed into a line as
replacement text, they will be parsed normally as a part of the
line.</p>
<h3 id="imp-file-importing"><code>IMP</code> — File Importing</h3>
<p>The <code>IMP</code> directive inserts the contents of another file
wherever the directive is placed. It allows a program to be split across
multiple files, as well as allowing code to be reused across multiple
source files without having to copy the code into each file. The
directive takes a single string operand (which must be enclosed in
quotes), which can either be a full path
(i.e. <code>Drive:/Folder/Folder/file.asm</code>) or a path relative to
the directory of the source file being assembled
(i.e. <code>file.asm</code>, <code>Folder/file.asm</code>, or
<code>../Folder/file.asm</code>).</p>
<p>For example, suppose you had two files in the same folder, one called
<code>program.asm</code>, and one called <code>numbers.asm</code>.</p>
<p>Contents of <code>program.asm</code>:</p>
<pre class="text"><code>MVQ rg0, :NUMBER_ONE
MVQ rg1, :NUMBER_TWO
HLT  ; Prevent program executing into number data

IMP &quot;numbers.asm&quot;</code></pre>
<p>Contents of <code>numbers.asm</code>:</p>
<pre class="text"><code>:NUMBER_ONE
NUM 123

:NUMBER_TWO
NUM 456</code></pre>
<p>When <code>program.asm</code> is assembled, the assembler will open
and include the lines in <code>numbers.asm</code> once it reaches the
<code>IMP</code> directive, resulting in the file looking like so:</p>
<pre class="text"><code>MVQ rg0, :NUMBER_ONE
MVQ rg1, :NUMBER_TWO
HLT  ; Prevent program executing into number data

IMP &quot;numbers.asm&quot;
:NUMBER_ONE
NUM 123

:NUMBER_TWO
NUM 456</code></pre>
<p>Meaning that <code>rg0</code> will finish with a value of
<code>123</code>, and <code>rg1</code> will finish with a value of
<code>456</code>.</p>
<p>The <code>IMP</code> directive simply inserts the text contents of a
file into the current file for assembly. This means that any label names
in files being imported will be usable in the main file, though imposes
the added restriction that label names must be unique across the main
file and all its imported files.</p>
<p>Files given to the <code>IMP</code> directive <strong>must</strong>
be AssEmbly source files, not already assembled binaries. It is
recommended, though not a strict requirement, that import statements are
placed at the end of a file, as that will make it easier to ensure that
the imported contents of a file aren’t executed by mistake as part of
the main program.</p>
<p>Care should be taken to ensure that a file does not end up depending
on itself, even if it is through other files, as this will result in an
infinite loop of imports (also known as a circular dependency). The
AssEmbly assembler will detect these and throw an error should one
occur.</p>
<p>An example of a circular dependency:</p>
<p><code>file_one.asm</code>:</p>
<pre class="text"><code>IMP &quot;file_two.asm&quot;</code></pre>
<p><code>file_two.asm</code>:</p>
<pre class="text"><code>IMP &quot;file_three.asm&quot;</code></pre>
<p><code>file_three.asm</code>:</p>
<pre class="text"><code>IMP &quot;file_one.asm&quot;</code></pre>
<p>Attempting to assemble any of these three files would result in the
assembler throwing an error, as each file ends up depending on itself as
it resolves its import.</p>
<h3 id="analyzer-toggling-assembler-warnings"><code>ANALYZER</code> —
Toggling Assembler Warnings</h3>
<p>The AssEmbly assembler checks for common issues with your source code
when you assemble it in order to alert you of potential issues and
improvements that can be made. There may be some situations, however,
where you want to suppress these issues from being detected. This can be
done within the source code using the <code>ANALYZER</code> directive.
The directive takes three operands: the severity of the warning (either
<code>error</code>, <code>warning</code>, or <code>suggestion</code>);
the numerical code for the warning (this is a 4-digit number printed
alongside the message); and whether to enable (<code>1</code>), disable
(<code>0</code>) or restore the warning to its state as it was at the
beginning of assembly (<code>r</code>).</p>
<p>After using the directive, its effect remains active until assembly
ends, or the same warning is toggled again with the directive further on
in the code.</p>
<p>For example:</p>
<pre class="text"><code>CMP rg0, 0  ; generates suggestion 0005

ANALYZER suggestion, 0005, 0
CMP rg0, 0  ; generates no suggestion
CMP rg0, 0  ; still generates no suggestion
ANALYZER suggestion, 0005, 1  ; &#39;r&#39; would also work if the suggestion isn&#39;t disabled via a CLI argument

CMP rg0, 0  ; generates suggestion 0005 again</code></pre>
<p>Be aware that some analyzers do not run until the end of the assembly
process and so cannot be re-enabled without inadvertently causing the
warning to re-appear. This can be overcome by placing the disabling
<code>ANALYZER</code> directive at the end of the base file for any
analyzers where this behaviour is an issue, or by simply not re-enabling
the analyzer.</p>
<h2 id="console-input-and-output">Console Input and Output</h2>
<p>AssEmbly has native support for reading and writing from the console.
There are four types of write that can be performed: 64-bit number in
decimal; byte in decimal; byte in hexadecimal; and a raw byte
(character). There is only a single type of read: a single raw byte.
There is no native support for reading numbers in any base, nor is there
support for reading or writing multiple numbers/bytes at once.</p>
<p>Writing can be done from registers, literals, labels, and pointers;
reading must be done to a register. As with the move instructions, if a
byte write instruction is used on a register or literal, only the lowest
byte will be considered. If one is used on a label or a pointer, only a
single byte of memory will be read, as an opposed to the 8 bytes that
are read when writing a 64-bit number.</p>
<p>An example of each type of write:</p>
<pre class="text"><code>MVQ rg0, 0xFF0062

WCN rg0  ; Write a 64-bit number to the console in decimal
; &quot;16711778&quot; (0xFF0062) is written to the console

WCC 10  ; Write a newline character

WCB rg0  ; Write a single byte to the console in decimal
; &quot;98&quot; (0x62) is written to the console

WCC 10  ; Write a newline character

WCX rg0  ; Write a single byte to the console in hexadecimal
; &quot;62&quot; is written to the console

WCC 10  ; Write a newline character

WCC rg0  ; Write a single byte to the console as a character
; &quot;b&quot; (0x62) is written to the console

WCC 10  ; Write a newline character</code></pre>
<p>Keep in mind that newlines are not automatically written after each
write instruction, you will need to manually write the raw byte
<code>10</code> (a newline character) to start writing on a new line.
See the ASCII table at the end of the document for other common
character codes.</p>
<p>An example of reading a byte:</p>
<pre class="text"><code>RCC rg0  ; Read a byte from the console and save the byte code to rg0</code></pre>
<p>When an <code>RCC</code> instruction is reached, the program will
pause execution and wait for the user to input a character to the
console. Once a character has been inputted, the corresponding byte
value of the character will be copied to the given register. In this
example, if the user types a lowercase “b”, <code>0x62</code> would be
copied to <code>rg0</code>.</p>
<p>Be aware that if the user types a character that requires multiple
bytes to represent in UTF-8, <code>RCC</code> will still only retrieve a
single byte. You will have to use <code>RCC</code> multiple times to get
all of the bytes needed to represent the character. <code>WCC</code>
will also only write a single byte at a time, though as long as the
console has UTF-8 support, simply writing each UTF-8 byte one after the
other will result in the correct character being displayed.</p>
<p>Note that the user does not need to press enter after inputting a
character, execution will resume immediately after a single character is
typed. If you wish to wait for the user to press enter, compare the
inputted character to <code>10</code> (the code for a newline
character). The example program <code>input.ext.asm</code> contains a
subroutine which does this. The user pressing the enter key will always
give a single <code>10</code> byte, regardless of platform.</p>
<h2 id="file-handling">File Handling</h2>
<p>As well as interfacing with the console, AssEmbly also has native
support for handling files.</p>
<h3 id="opening-and-closing">Opening and Closing</h3>
<p>Files must be explicitly opened with the <code>OFL</code> instruction
before they can read or written to, and only one file can be open at a
time. You should close the currently open file with the <code>CFL</code>
instruction when you have finished operating on it.</p>
<p>Filepaths given to <code>OFL</code> to be opened should be strings of
UTF-8 character bytes in memory, ending with at least one <code>0</code>
byte. An example static filepath definition is as follows:</p>
<pre class="text"><code>:FILE_PATH
DAT &quot;file.txt\0&quot;</code></pre>
<p>This would normally be placed after all program code and a
<code>HLT</code> instruction to prevent it accidentally being executed
as if it were part of the program. The file can be opened with the
following line anywhere in the program:</p>
<pre class="text"><code>OFL :FILE_PATH
...
CFL</code></pre>
<p>You could also use a pointer if you wish:</p>
<pre class="text"><code>MVQ rg0, :&amp;FILE_PATH
OFL *rg0
...
CFL</code></pre>
<p><code>CFL</code> will close whatever file is currently open, so does
not require any operands. If a file at the specified path does not exist
when it is opened, an empty one will be created.</p>
<h3 id="reading-and-writing">Reading and Writing</h3>
<p>Reading and writing from files is almost identical to how it is done
from the console. Registers, literals, labels, and pointers can all be
written, and reading must be done to a register. When using byte writing
instructions, only the lower byte of registers and literals is
considered, and only a single byte of memory is read for labels and
pointers. An open file can be both read from and written to while it is
open, though changes written to the file will not be reflected in either
the current AssEmbly program or other applications until the file is
closed. If a file already has data in it when it is written to, the new
data will start overwriting from the first byte in the file. Any
remaining data that does not get overwritten will remain unchanged, and
the size of the file will not change unless more bytes are written than
were originally in the file. To clear a file before writing it, use the
<code>DFL</code> instruction to delete the file beforehand.</p>
<p>An example of writing to a file:</p>
<pre class="text"><code>MVQ rg0, 0xFF0062
OFL :FILE_PATH  ; Open file with the 0-terminated string at :FILE_PATH

WFN rg0  ; Write a 64-bit number to the file in decimal
; &quot;16711778&quot; (0xFF0062) is appended to the file

WFC 10  ; Write a newline character

WFB rg0  ; Write a single byte to the file in decimal
; &quot;98&quot; (0x62) is appended to the file

WFC 10  ; Write a newline character

WFX rg0  ; Write a single byte to the file in hexadecimal
; &quot;62&quot; is appended to the file

WFC 10  ; Write a newline character

WFC rg0  ; Write a single byte to the file as a character
; &quot;b&quot; (0x62) is appended to the file

WFC 10  ; Write a newline character
CFL  ; Close the file, saving newly written contents

HLT  ; Prevent executing into string data

:FILE_PATH
DAT &quot;file.txt\0&quot;</code></pre>
<p>Executing this program will create a file called
<code>file.txt</code> with the following contents:</p>
<pre class="text"><code>16711778
98
62
b
</code></pre>
<p>File contents can be read with the <code>RFC</code> instruction,
taking a single register as an operand. The next unread byte from the
file will be stored in the specified register. Text files are not
treated specially, <code>RFC</code> will simply retrieve the characters
1 byte at a time as they are encoded in the file. If the end of the file
has been reached after reading, the file end flag will be set to
<code>1</code>. The only way to reset the current reading position in a
file is to close and reopen the file.</p>
<p>To read all bytes until the end of a file, you will need to
continually read single bytes from the file, testing the file end flag
after every read, stopping as soon as it becomes set. The example
program <code>read_file.asm</code> has an example of this, as well as
this example from the bit testing section:</p>
<pre class="text"><code>:READ
RFC rg0  ; Read the next byte from the open file to rg0
TST rsf, 0b100  ; Check if the third bit is set
JZO :READ  ; If it isn&#39;t set (i.e. it is equal to 0), jump back to READ</code></pre>
<h3 id="other-operations">Other Operations</h3>
<p>As well as reading and writing, there are also instructions for
checking whether a file exists (<code>FEX</code>), getting the size of a
file (<code>FSZ</code>), and deleting a file (<code>DFL</code>). They
all take a path in the same way <code>OFL</code> does. <code>DFL</code>
has no effect other than deleting the file. <code>FEX</code> and
<code>FSZ</code> first take a register operand to store their result in,
then the path to the file as the second operand. <code>FEX</code> stores
<code>1</code> in the register if the file exists, <code>0</code> if
not. <code>FSZ</code> stores the total size of the file in bytes.</p>
<h2 id="the-stack">The Stack</h2>
<p>The stack is a section of memory most often used in conjunction with
subroutines, explained in the subsequent section. It starts at the very
end of available memory, and dynamically grows backwards as more items
are added (<strong>pushed</strong>) to it. The stack contains
exclusively 64-bit (8 byte) values. Registers, literals, labels, and
pointers can all be given as operands to the push (<code>PSH</code>)
instruction.</p>
<p>Once items have been pushed to the stack, they can be removed
(<strong>popped</strong>), starting with the most recently pushed item.
As with most other instructions with a destination, items from the stack
must be popped into registers with the <code>POP</code> instruction.
Once an item is removed from the stack, the effective size of the stack
shrinks back down, and the popped item will no longer be considered part
of the stack until and unless it is pushed again.</p>
<p>The <code>rso</code> register contains the address of the first byte
of the top item in the stack. Its value will get <strong>lower</strong>
as items are <strong>pushed</strong>, and <strong>greater</strong> as
items are <strong>popped</strong>. More info on the <code>rso</code>
register’s behaviour can be found in the registers section.</p>
<p>Take this visual example, assuming memory is 2046 bytes in size
(making 2045 the maximum address):</p>
<pre class="text"><code>; rso = 2046
; | Addresses |    2022..2029    |    2030..2037    |    2038..2045    ||
; |   Value   | ???????????????? | ???????????????? | ???????????????? ||

PSH 0xDEADBEEF  ; Push 0xDEADBEEF (3735928559) to the stack

; rso = 2038
; | Addresses |    2022..2029    |    2030..2037    ||    2038..2045    |
; |   Value   | ???????????????? | ???????????????? || 00000000EFBEADDE |

PSH 0xCAFEB0BA  ; Push 0xCAFEB0BA (3405689018) to the stack

; rso = 2030
; | Addresses |    2022..2029    ||    2030..2037    |    2038..2045    |
; |   Value   | ???????????????? || 00000000BAB0FECA | 00000000EFBEADDE |

PSH 0xD00D2BAD  ; Push 0xD00D2BAD (3490524077) to the stack

; rso = 2022
; | Addresses ||    2022..2029    |    2030..2037    |    2038..2045    |
; |   Value   || 00000000AD2B0DD0 | 00000000BAB0FECA | 00000000EFBEADDE |

POP rg0  ; Pop the most recent non-popped item from the stack into rg0

; rso = 2030
; | Addresses |    2022..2029    ||    2030..2037    |    2038..2045    |
; |   Value   | ???????????????? || 00000000BAB0FECA | 00000000EFBEADDE |
; rg0 = 0xD00D2BAD

POP rg0  ; Pop the most recent non-popped item from the stack into rg0

; rso = 2038
; | Addresses |    2022..2029    |    2030..2037    ||    2038..2045    |
; |   Value   | ???????????????? | ???????????????? || 00000000EFBEADDE |
; rg0 = 0xCAFEB0BA</code></pre>
<h3 id="using-the-stack-to-preserve-registers">Using the Stack to
Preserve Registers</h3>
<p>A common use of the stack is to store the value of a register, use
the register for a purpose that differs from its original one, then
restore the register to the stored value. This is particularly useful in
sections of reusable code (such as subroutines) where you cannot
guarantee whether a register will be in use or not.</p>
<p>An example of this is as follows:</p>
<pre class="text"><code>MVQ rg0, 45
ADD rg0, 20
; rg0 is 65

PSH rg0  ; Push the current value of rg0 to the stack
MVQ rg0, 200
MUL rg0, 10
; rg0 is 2000

POP rg0  ; Pop the old rg0 back into rg0
; rg0 is back to 65</code></pre>
<h2 id="subroutines">Subroutines</h2>
<p>A subroutine is a section of a program that can be specially jumped
to (<strong>called</strong>) from multiple different points in a
program. They differ from a standard jump in that the position in the
program that a subroutine is called from is stored automatically, so can
be <strong>returned</strong> to at any point with ease. This makes
reusing the same section of code across different parts of a program, or
even across different programs, much easier.</p>
<p>Subroutines are defined with a label as with any other form of jump
destination — to call one, use the <code>CAL</code> instruction with
either the label or a pointer to that label. Once you are within a
subroutine, you can return to the calling location with the
<code>RET</code> instruction, no operands required.</p>
<p>An example of a simple subroutine:</p>
<pre class="text"><code>MVQ rg0, 5
CAL :ADD_TO_RG0
; rg0 is now 15

MVQ rg1, :&amp;ADD_TO_RG0
MVQ rg0, 46
CAL *rg1
; rg0 is now 56

HLT

:ADD_TO_RG0
ADD rg0, 10
RET</code></pre>
<p>Specifically, <code>RET</code> will cause <code>rpo</code> to be
updated to the address storing the opcode directly after the
<code>CAL</code> instruction that was used to call the subroutine.
Unless they are halting the program, subroutines should always exit with
a <code>RET</code> instruction and nothing else.</p>
<h3 id="fast-calling">Fast Calling</h3>
<p>The <code>CAL</code> instruction can also take an optional second
operand: a value to pass to the subroutine. This is called <strong>fast
calling</strong> or <strong>fast passing</strong>; the passed value gets
stored in <code>rfp</code> and can be any one of a register, literal,
label, or pointer. More info on the behaviour of the register itself and
how it should be used can be found in its part of the registers section.
Parameters are always 64-bit values, so when passing a label or a
register, 8 bytes of memory will always be read.</p>
<p>An example of subroutines utilising fast calling:</p>
<pre class="text"><code>:SUBROUTINE_ONE
ADD rfp, 1
MVQ rg0, rfp
RET

:SUBROUTINE_TWO
ADD rfp, 2
MVQ rg0, rfp
RET

CAL :SUBROUTINE_ONE, 4  ; This will implicitly set rfp to 4
; rg0 is now 5
CAL :SUBROUTINE_TWO, 6  ; This will implicitly set rfp to 6
; rg0 is now 8</code></pre>
<h3 id="return-values">Return Values</h3>
<p>The <code>RET</code> instruction can also take an optional operand to
return a value. Return values can be registers, literals, labels, or
pointers, and are stored in <code>rrv</code>. As with fast pass
parameters, return values are always 64-bits/8 bytes. The exact
behaviour and usage of the register can be found in its part of the
registers section.</p>
<p>Here is the above example for fast calling adapted to use return
values:</p>
<pre class="text"><code>:SUBROUTINE_ONE
ADD rfp, 1
RET rfp  ; Return, setting rrv to the value of rfp

:SUBROUTINE_TWO
ADD rfp, 2
RET rfp  ; Return, setting rrv to the value of rfp

CAL :SUBROUTINE_ONE, 4
; rrv is now 5
CAL :SUBROUTINE_TWO, 6
; rrv is now 8</code></pre>
<h3 id="subroutines-and-the-stack">Subroutines and the Stack</h3>
<p>In order to store the address to return to when using subroutines,
the stack is utilised. Every time the <code>CAL</code> instruction is
used, the address of the next opcode, and the current value of
<code>rsb</code>, are pushed to the stack in that order.
<code>rsb</code> and <code>rso</code> will then be updated to the new
address of the top of the stack (the address where <code>rsb</code> was
pushed to). <code>rsb</code> will continue to point here (the
<strong>base</strong>) until another subroutine is called or the
subroutine is returned from. <code>rso</code> will continue to update as
normal as items are popped to and pushed from the stack, always pointing
to the top of it. The area from the current <strong>base</strong>
(<code>rsb</code>) to the top of the stack (<code>rso</code>) is called
the current <strong>stack frame</strong>. Multiple stack frames can be
stacked on top of each other if a subroutine is called from another
subroutine.</p>
<p>When returning from a subroutine, the opposite is performed.
<code>rsb</code>, and <code>rpo</code> are popped off the top of the
stack, thereby continuing execution as it was before the subroutine was
called. All values apart from these two must be popped off the stack
before using the <code>RET</code> instruction (you can ensure this by
moving the value of <code>rsb</code> into <code>rso</code>). After
returning <code>rso</code> will point to the same address as when the
function was called.</p>
<p>If you utilise registers in a subroutine, you should use the stack to
ensure that the value of each modified register is returned to its
initial value before returning from the subroutine. See the above
section on using the stack to preserve registers for info on how to do
this.</p>
<h3 id="passing-multiple-parameters">Passing Multiple Parameters</h3>
<p>The <code>CAL</code> instruction can only take a single data
parameter, however, there may be situations where multiple values need
to be passed to a subroutine; it is best to use the stack in situations
such as these. Before calling the subroutine, push any values you want
to act as parameters to the subroutine, to the stack. Once the
subroutine has been called, you can use <code>rsb</code> to calculate
the address that each parameter will be stored at. To access the first
parameter (the last one pushed before calling), you need to account for
the two automatically pushed values first. These, along with every other
value in the stack, are all 8 bytes long, so adding <code>16</code>
(<code>8 * 2</code>) to <code>rsb</code> will get you the address of
this parameter (you should do this in another register, <code>rsb</code>
should be left unmodified). To access any subsequent parameters, simply
add another <code>8</code> on top of this.</p>
<p>For example:</p>
<pre class="text"><code>PSH 4  ; Parameter D
PSH 3  ; Parameter C
PSH 2  ; Parameter B
CAL :SUBROUTINE, 1  ; Parameter A (rfp)
; rrv is now 10

:SUBROUTINE
PSH rg0  ; Preserve the value of rg0

MVQ rg0, rsb
ADD rg0, 16  ; Parameter B
ADD rfp, *rg0
; rfp is now 3
ADD rg0, 8  ; Parameter C
ADD rfp, *rg0
; rfp is now 6
ADD rg0, 8  ; Parameter D
ADD rfp, *rg0
; rfp is now 10

POP rg0  ; Restore rg0 to its original value
RET rfp</code></pre>
<h2 id="text-encoding">Text Encoding</h2>
<p>All text in AssEmbly (input from/output to the console; strings
inserted by <code>DAT</code>; strings given to <code>OFL</code>,
<code>DFL</code>, <code>FEX</code>, etc.) is encoded in UTF-8. This
means that all characters that are a part of the ASCII character set
only take up a single byte, though some characters may take as many as 4
bytes to store fully.</p>
<p>Be aware that when working with characters that require multiple
bytes, instructions like <code>RCC</code>, <code>RFC</code>,
<code>WCC</code>, and <code>WFC</code> still only work on single bytes
at a time. As long as you read/write all of the UTF-8 bytes in the
correct order, they should be stored and displayed correctly.</p>
<p>Text bytes read from files <strong>will not</strong> be automatically
converted to UTF-8 if the file was saved with another encoding.</p>
<h2 id="instruction-data-type-acceptance">Instruction Data Type
Acceptance</h2>
<p>The following is a table of which types of numeric data can be given
to each instruction and have them function as expected. AssEmbly
<strong>does not</strong> keep track of data types, it is your
responsibility to do so. If you use the wrong instruction for the type
of data you have, it is unlikely you will receive an error - you will
most likely simply get an unexpected answer, as the processor is
interpreting the data as a valid, but different, numeric value in a
different format.</p>
<p>If an instruction supports signed integers but not unsigned integers,
the instruction <em>will</em> still accept positive values, but those
positive values must be below the signed limit
(<code>9,223,372,036,854,775,807</code>), or they will be erroneously
interpreted as negative.</p>
<ul>
<li><code>O</code> = Instruction accepts the data type</li>
<li><code>X</code> = Instruction does not accept the data type</li>
<li><code>(...)</code> = Instruction accepts the data type, but see the
numbered footnote below the table for additional information to keep in
mind</li>
</ul>
<p>Instructions that don’t take any data or are otherwise not applicable
have been omitted.</p>
<table>
<thead>
<tr class="header">
<th>Instruction</th>
<th>Unsigned Integer</th>
<th>Signed Integer</th>
<th>Floating Point</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ADD</code></td>
<td>O</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>ICR</code></td>
<td>O</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>SUB</code></td>
<td>O</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>DCR</code></td>
<td>O</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>MUL</code></td>
<td>O</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>DIV</code></td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>DVR</code></td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>REM</code></td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>SHL</code></td>
<td>O</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>SHR</code></td>
<td>O</td>
<td>(1)</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>AND</code></td>
<td>O</td>
<td>(2)</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>ORR</code></td>
<td>O</td>
<td>(2)</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>XOR</code></td>
<td>O</td>
<td>(2)</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>NOT</code></td>
<td>O</td>
<td>(2)</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>TST</code></td>
<td>O</td>
<td>(2)</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>CMP</code></td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>MVB</code></td>
<td>O</td>
<td>(3)</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>MVW</code></td>
<td>O</td>
<td>(3)</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>MVD</code></td>
<td>O</td>
<td>(3)</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>MVQ</code></td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr>
<tr class="odd">
<td><code>PSH</code></td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr>
<tr class="even">
<td><code>CAL</code></td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr>
<tr class="odd">
<td><code>RET</code></td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr>
<tr class="even">
<td><code>WCN</code></td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>WCB</code></td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>WCX</code></td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>WCC</code></td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>WFN</code></td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>WFB</code></td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>WFX</code></td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>WFC</code></td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>SIGN_DIV</code></td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>SIGN_DVR</code></td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>SIGN_REM</code></td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>SIGN_SHR</code></td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>SIGN_MVB</code></td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>SIGN_MVW</code></td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>SIGN_MVD</code></td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>SIGN_WCN</code></td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>SIGN_WCB</code></td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>SIGN_WFN</code></td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>SIGN_WFB</code></td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>SIGN_EXB</code></td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>SIGN_EXW</code></td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>SIGN_EXD</code></td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>SIGN_NEG</code></td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>FLPT_ADD</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="even">
<td><code>FLPT_SUB</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="odd">
<td><code>FLPT_MUL</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="even">
<td><code>FLPT_DIV</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="odd">
<td><code>FLPT_DVR</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="even">
<td><code>FLPT_REM</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="odd">
<td><code>FLPT_SIN</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="even">
<td><code>FLPT_ASN</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="odd">
<td><code>FLPT_COS</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="even">
<td><code>FLPT_ACS</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="odd">
<td><code>FLPT_TAN</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="even">
<td><code>FLPT_ATN</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="odd">
<td><code>FLPT_PTN</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="even">
<td><code>FLPT_POW</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="odd">
<td><code>FLPT_LOG</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="even">
<td><code>FLPT_WCN</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="odd">
<td><code>FLPT_WFN</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="even">
<td><code>FLPT_EXH</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="odd">
<td><code>FLPT_EXS</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="even">
<td><code>FLPT_SHS</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="odd">
<td><code>FLPT_SHH</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="even">
<td><code>FLPT_NEG</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="odd">
<td><code>FLPT_UTF</code></td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>FLPT_STF</code></td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>FLPT_FTS</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="even">
<td><code>FLPT_FCS</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="odd">
<td><code>FLPT_FFS</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="even">
<td><code>FLPT_FNS</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr class="odd">
<td><code>FLPT_CMP</code></td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>Signed integers <em>can</em> still be used with <code>SHR</code>,
though it will perform a logical shift, not an arithmetic one, which may
or may not be what you desire. See the section on Arithmetic Right
Shifting for the difference.</li>
<li>Bitwise operations on signed integers will treat the sign bit like
any other, there is no special logic involving it.</li>
<li>Using smaller-than-64-bit move instructions on signed integers if
the target is a label or pointer will work as expected, truncating the
upper bits. If the target is a register, however, you may wish to use
the signed versions to automatically extend the smaller integer to a
signed 64-bit one so it is correctly interpreted by other
instructions.</li>
</ol>
<h2 id="status-flag-behaviour">Status Flag Behaviour</h2>
<ul>
<li><code>0</code> = Instruction always unsets flag</li>
<li><code>1</code> = Instruction always sets flag</li>
<li><code>(...)</code> = Instruction sets flag if the given condition is
satisfied, otherwise it unsets it</li>
<li><code>[...]</code> = Instruction sets flag if the given condition is
satisfied, otherwise it maintains its current value</li>
<li><code>{...}</code> = Instruction unsets flag if the given condition
is satisfied, otherwise it maintains its current value</li>
<li><code>X</code> = Instruction does not affect flag</li>
<li><code>STD</code> = Instruction uses standard behaviour for flag
according to result, unaffected by operands. They are as follows:
<ul>
<li>For zero flag, set if the result is equal to 0, otherwise unset (for
floating point operations, <code>-0</code> is considered equal to
<code>0</code> and will set the zero flag)</li>
<li>For sign flag, set if the most significant bit of the result is set,
otherwise unset</li>
</ul></li>
</ul>
<table style="width:100%;">
<colgroup>
<col style="width: 9%" />
<col style="width: 3%" />
<col style="width: 37%" />
<col style="width: 20%" />
<col style="width: 3%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>Instruction</th>
<th>Zero</th>
<th>Carry</th>
<th>File End</th>
<th>Sign</th>
<th>Overflow</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>HLT</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>NOP</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>JMP</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>JEQ</code> / <code>JZO</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>JNE</code> / <code>JNZ</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>JLT</code> / <code>JCA</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>JLE</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>JGT</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>JGE</code> / <code>JNC</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>ADD</code></td>
<td>STD</td>
<td>(Result is unrepresentable as unsigned)</td>
<td>X</td>
<td>STD</td>
<td>(Result is unrepresentable as signed)</td>
</tr>
<tr class="odd">
<td><code>ICR</code></td>
<td>STD</td>
<td>(Result is unrepresentable as unsigned)</td>
<td>X</td>
<td>STD</td>
<td>(Result is unrepresentable as signed)</td>
</tr>
<tr class="even">
<td><code>SUB</code></td>
<td>STD</td>
<td>(Result is unrepresentable as unsigned)</td>
<td>X</td>
<td>STD</td>
<td>(Result is unrepresentable as signed)</td>
</tr>
<tr class="odd">
<td><code>DCR</code></td>
<td>STD</td>
<td>(Result is unrepresentable as unsigned)</td>
<td>X</td>
<td>STD</td>
<td>(Result is unrepresentable as signed)</td>
</tr>
<tr class="even">
<td><code>MUL</code></td>
<td>STD</td>
<td>(Result is unrepresentable as unsigned)</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>DIV</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>DVR</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>REM</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>SHL</code></td>
<td>STD</td>
<td>(Any <code>1</code> bit was shifted past MSB)</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>SHR</code></td>
<td>STD</td>
<td>(Any <code>1</code> bit was shifted past LSB)</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>AND</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>ORR</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>XOR</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>NOT</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>RNG</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>TST</code></td>
<td>STD</td>
<td>X</td>
<td>X</td>
<td>STD</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>CMP</code></td>
<td>STD</td>
<td>(Result is unrepresentable as unsigned)</td>
<td>X</td>
<td>STD</td>
<td>(Result is unrepresentable as signed)</td>
</tr>
<tr class="odd">
<td><code>MVB</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>MVW</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>MVD</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>MVQ</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>PSH</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>POP</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>CAL</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>RET</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>WCN</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>WCB</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>WCX</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>WCC</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>WFN</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>WFB</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>WFX</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>WFC</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>OFL</code></td>
<td>X</td>
<td>X</td>
<td>(File is empty)</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>CFL</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>DFL</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>FEX</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>FSZ</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>RCC</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>RFC</code></td>
<td>X</td>
<td>X</td>
<td>[No more unread bytes in file]</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>SIGN_JLT</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>SIGN_JLE</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>SIGN_JGT</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>SIGN_JGE</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>SIGN_JSI</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>SIGN_JNS</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>SIGN_JOV</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>SIGN_JNO</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>SIGN_DIV</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>SIGN_DVR</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>SIGN_REM</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>SIGN_SHR</code></td>
<td>STD</td>
<td>(Any bit not equal to the sign bit was shifted past LSB)</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>SIGN_MVB</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>SIGN_MVW</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>SIGN_MVD</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>SIGN_WCN</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>SIGN_WCB</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>SIGN_WFN</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>SIGN_WFB</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>SIGN_EXB</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>SIGN_EXW</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>SIGN_EXD</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>SIGN_NEG</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>FLPT_ADD</code></td>
<td>STD</td>
<td>(Result is less than the initial value)</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>FLPT_SUB</code></td>
<td>STD</td>
<td>(Result is greater than the initial value)</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>FLPT_MUL</code></td>
<td>STD</td>
<td>(Result is less than the initial value)</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>FLPT_DIV</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>FLPT_DVR</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>FLPT_REM</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>FLPT_SIN</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>FLPT_ASN</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>FLPT_COS</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>FLPT_ACS</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>FLPT_TAN</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>FLPT_ATN</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>FLPT_PTN</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>FLPT_POW</code></td>
<td>STD</td>
<td>(Result is less than the initial value)</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>FLPT_LOG</code></td>
<td>STD</td>
<td>(Result is greater than the initial value)</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>FLPT_WCN</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td><code>FLPT_WFN</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><code>FLPT_EXH</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>FLPT_EXS</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>FLPT_SHS</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>FLPT_SHH</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>FLPT_NEG</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>FLPT_UTF</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>FLPT_STF</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>FLPT_FTS</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>FLPT_FCS</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>FLPT_FFS</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>FLPT_FNS</code></td>
<td>STD</td>
<td>0</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="odd">
<td><code>FLPT_CMP</code></td>
<td>STD</td>
<td>(Value of first operand is less than second)</td>
<td>X</td>
<td>STD</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>EXTD_BSW</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
</tbody>
</table>
<h2 id="full-instruction-reference">Full Instruction Reference</h2>
<h3 id="base-instruction-set">Base Instruction Set</h3>
<p>Extension set number <code>0x00</code>, opcodes start with
<code>0xFF, 0x00</code>.</p>
<p>Note that for the base instruction set (number <code>0x00</code>)
<em>only</em>, the leading <code>0xFF, 0x00</code> to specify the
extension set can be omitted, as the processor will automatically treat
opcodes not starting with <code>0xFF</code> as base instruction set
opcodes.</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 18%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>Mnemonic</th>
<th>Full Name</th>
<th>Operands</th>
<th>Function</th>
<th>Instruction Code</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Control</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>HLT</code></td>
<td>Halt</td>
<td>-</td>
<td>Stops the processor from executing the program</td>
<td><code>0x00</code></td>
</tr>
<tr class="odd">
<td><code>NOP</code></td>
<td>No Operation</td>
<td>-</td>
<td>Do nothing</td>
<td><code>0x01</code></td>
</tr>
<tr class="even">
<td><strong>Jumping</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>JMP</code></td>
<td>Jump</td>
<td>Address</td>
<td>Jump unconditionally to an address in a label</td>
<td><code>0x02</code></td>
</tr>
<tr class="even">
<td><code>JMP</code></td>
<td>Jump</td>
<td>Pointer</td>
<td>Jump unconditionally to an address in a register</td>
<td><code>0x03</code></td>
</tr>
<tr class="odd">
<td><code>JEQ</code> / <code>JZO</code></td>
<td>Jump if Equal / Jump if Zero</td>
<td>Address</td>
<td>Jump to an address in a label only if the zero status flag is
set</td>
<td><code>0x04</code></td>
</tr>
<tr class="even">
<td><code>JEQ</code> / <code>JZO</code></td>
<td>Jump if Equal / Jump if Zero</td>
<td>Pointer</td>
<td>Jump to an address in a register only if the zero status flag is
set</td>
<td><code>0x05</code></td>
</tr>
<tr class="odd">
<td><code>JNE</code> / <code>JNZ</code></td>
<td>Jump if not Equal / Jump if not Zero</td>
<td>Address</td>
<td>Jump to an address in a label only if the zero status flag is
unset</td>
<td><code>0x06</code></td>
</tr>
<tr class="even">
<td><code>JNE</code> / <code>JNZ</code></td>
<td>Jump if not Equal / Jump if not Zero</td>
<td>Pointer</td>
<td>Jump to an address in a register only if the zero status flag is
unset</td>
<td><code>0x07</code></td>
</tr>
<tr class="odd">
<td><code>JLT</code> / <code>JCA</code></td>
<td>Jump if Less Than / Jump if Carry</td>
<td>Address</td>
<td>Jump to an address in a label only if the carry status flag is
set</td>
<td><code>0x08</code></td>
</tr>
<tr class="even">
<td><code>JLT</code> / <code>JCA</code></td>
<td>Jump if Less Than / Jump if Carry</td>
<td>Pointer</td>
<td>Jump to an address in a register only if the carry status flag is
set</td>
<td><code>0x09</code></td>
</tr>
<tr class="odd">
<td><code>JLE</code></td>
<td>Jump if Less Than or Equal To</td>
<td>Address</td>
<td>Jump to an address in a label only if either the carry or zero flags
are set</td>
<td><code>0x0A</code></td>
</tr>
<tr class="even">
<td><code>JLE</code></td>
<td>Jump if Less Than or Equal To</td>
<td>Pointer</td>
<td>Jump to an address in a register only if either the carry or zero
flags are set</td>
<td><code>0x0B</code></td>
</tr>
<tr class="odd">
<td><code>JGT</code></td>
<td>Jump if Greater Than</td>
<td>Address</td>
<td>Jump to an address in a label only if both the carry and zero flags
are unset</td>
<td><code>0x0C</code></td>
</tr>
<tr class="even">
<td><code>JGT</code></td>
<td>Jump if Greater Than</td>
<td>Pointer</td>
<td>Jump to an address in a register only if both the carry and zero
flags are unset</td>
<td><code>0x0D</code></td>
</tr>
<tr class="odd">
<td><code>JGE</code> / <code>JNC</code></td>
<td>Jump if Greater Than or Equal To / Jump if no Carry</td>
<td>Address</td>
<td>Jump to an address in a label only if the carry status flag is
unset</td>
<td><code>0x0E</code></td>
</tr>
<tr class="even">
<td><code>JGE</code> / <code>JNC</code></td>
<td>Jump if Greater Than or Equal To / Jump if no Carry</td>
<td>Pointer</td>
<td>Jump to an address in a register only if the carry status flag is
unset</td>
<td><code>0x0F</code></td>
</tr>
<tr class="odd">
<td><strong>Math</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>ADD</code></td>
<td>Add</td>
<td>Register, Register</td>
<td>Add the contents of one register to another</td>
<td><code>0x10</code></td>
</tr>
<tr class="odd">
<td><code>ADD</code></td>
<td>Add</td>
<td>Register, Literal</td>
<td>Add a literal value to the contents of a register</td>
<td><code>0x11</code></td>
</tr>
<tr class="even">
<td><code>ADD</code></td>
<td>Add</td>
<td>Register, Address</td>
<td>Add the contents of memory at an address in a label to a
register</td>
<td><code>0x12</code></td>
</tr>
<tr class="odd">
<td><code>ADD</code></td>
<td>Add</td>
<td>Register, Pointer</td>
<td>Add the contents of memory at an address in a register to a
register</td>
<td><code>0x13</code></td>
</tr>
<tr class="even">
<td><code>ICR</code></td>
<td>Increment</td>
<td>Register</td>
<td>Increment the contents of a register by 1</td>
<td><code>0x14</code></td>
</tr>
<tr class="odd">
<td><code>SUB</code></td>
<td>Subtract</td>
<td>Register, Register</td>
<td>Subtract the contents of one register from another</td>
<td><code>0x20</code></td>
</tr>
<tr class="even">
<td><code>SUB</code></td>
<td>Subtract</td>
<td>Register, Literal</td>
<td>Subtract a literal value from the contents of a register</td>
<td><code>0x21</code></td>
</tr>
<tr class="odd">
<td><code>SUB</code></td>
<td>Subtract</td>
<td>Register, Address</td>
<td>Subtract the contents of memory at an address in a label from a
register</td>
<td><code>0x22</code></td>
</tr>
<tr class="even">
<td><code>SUB</code></td>
<td>Subtract</td>
<td>Register, Pointer</td>
<td>Subtract the contents of memory at an address in a register from a
register</td>
<td><code>0x23</code></td>
</tr>
<tr class="odd">
<td><code>DCR</code></td>
<td>Decrement</td>
<td>Register</td>
<td>Decrement the contents of a register by 1</td>
<td><code>0x24</code></td>
</tr>
<tr class="even">
<td><code>MUL</code></td>
<td>Multiply</td>
<td>Register, Register</td>
<td>Multiply the contents of one register by another</td>
<td><code>0x30</code></td>
</tr>
<tr class="odd">
<td><code>MUL</code></td>
<td>Multiply</td>
<td>Register, Literal</td>
<td>Multiply the contents of a register by a literal value</td>
<td><code>0x31</code></td>
</tr>
<tr class="even">
<td><code>MUL</code></td>
<td>Multiply</td>
<td>Register, Address</td>
<td>Multiply a register by the contents of memory at an address in a
label</td>
<td><code>0x32</code></td>
</tr>
<tr class="odd">
<td><code>MUL</code></td>
<td>Multiply</td>
<td>Register, Pointer</td>
<td>Multiply a register by the contents of memory at an address in a
register</td>
<td><code>0x33</code></td>
</tr>
<tr class="even">
<td><code>DIV</code></td>
<td>Integer Divide</td>
<td>Register, Register</td>
<td>Divide the contents of one register by another, discarding the
remainder</td>
<td><code>0x40</code></td>
</tr>
<tr class="odd">
<td><code>DIV</code></td>
<td>Integer Divide</td>
<td>Register, Literal</td>
<td>Divide the contents of a register by a literal value, discarding the
remainder</td>
<td><code>0x41</code></td>
</tr>
<tr class="even">
<td><code>DIV</code></td>
<td>Integer Divide</td>
<td>Register, Address</td>
<td>Divide a register by the contents of memory at an address in a
label, discarding the remainder</td>
<td><code>0x42</code></td>
</tr>
<tr class="odd">
<td><code>DIV</code></td>
<td>Integer Divide</td>
<td>Register, Pointer</td>
<td>Divide a register by the contents of memory at an address in a
register, discarding the remainder</td>
<td><code>0x43</code></td>
</tr>
<tr class="even">
<td><code>DVR</code></td>
<td>Divide With Remainder</td>
<td>Register, Register, Register</td>
<td>Divide the contents of one register by another, storing the
remainder</td>
<td><code>0x44</code></td>
</tr>
<tr class="odd">
<td><code>DVR</code></td>
<td>Divide With Remainder</td>
<td>Register, Register, Literal</td>
<td>Divide the contents of a register by a literal value, storing the
remainder</td>
<td><code>0x45</code></td>
</tr>
<tr class="even">
<td><code>DVR</code></td>
<td>Divide With Remainder</td>
<td>Register, Register, Address</td>
<td>Divide a register by the contents of memory at an address in a
label, storing the remainder</td>
<td><code>0x46</code></td>
</tr>
<tr class="odd">
<td><code>DVR</code></td>
<td>Divide With Remainder</td>
<td>Register, Register, Pointer</td>
<td>Divide a register by the contents of memory at an address in a
register, storing the remainder</td>
<td><code>0x47</code></td>
</tr>
<tr class="even">
<td><code>REM</code></td>
<td>Remainder Only</td>
<td>Register, Register</td>
<td>Divide the contents of one register by another, storing only the
remainder</td>
<td><code>0x48</code></td>
</tr>
<tr class="odd">
<td><code>REM</code></td>
<td>Remainder Only</td>
<td>Register, Literal</td>
<td>Divide the contents of a register by a literal value, storing only
the remainder</td>
<td><code>0x49</code></td>
</tr>
<tr class="even">
<td><code>REM</code></td>
<td>Remainder Only</td>
<td>Register, Address</td>
<td>Divide a register by the contents of memory at an address in a
label, storing only the remainder</td>
<td><code>0x4A</code></td>
</tr>
<tr class="odd">
<td><code>REM</code></td>
<td>Remainder Only</td>
<td>Register, Pointer</td>
<td>Divide a register by the contents of memory at an address in a
register, storing only the remainder</td>
<td><code>0x4B</code></td>
</tr>
<tr class="even">
<td><code>SHL</code></td>
<td>Shift Left</td>
<td>Register, Register</td>
<td>Shift the bits of one register left by another register</td>
<td><code>0x50</code></td>
</tr>
<tr class="odd">
<td><code>SHL</code></td>
<td>Shift Left</td>
<td>Register, Literal</td>
<td>Shift the bits of a register left by a literal value</td>
<td><code>0x51</code></td>
</tr>
<tr class="even">
<td><code>SHL</code></td>
<td>Shift Left</td>
<td>Register, Address</td>
<td>Shift the bits of a register left by the contents of memory at an
address in a label</td>
<td><code>0x52</code></td>
</tr>
<tr class="odd">
<td><code>SHL</code></td>
<td>Shift Left</td>
<td>Register, Pointer</td>
<td>Shift the bits of a register left by the contents of memory at an
address in a register</td>
<td><code>0x53</code></td>
</tr>
<tr class="even">
<td><code>SHR</code></td>
<td>Shift Right</td>
<td>Register, Register</td>
<td>Shift the bits of one register right by another register</td>
<td><code>0x54</code></td>
</tr>
<tr class="odd">
<td><code>SHR</code></td>
<td>Shift Right</td>
<td>Register, Literal</td>
<td>Shift the bits of a register right by a literal value</td>
<td><code>0x55</code></td>
</tr>
<tr class="even">
<td><code>SHR</code></td>
<td>Shift Right</td>
<td>Register, Address</td>
<td>Shift the bits of a register right by the contents of memory at an
address in a label</td>
<td><code>0x56</code></td>
</tr>
<tr class="odd">
<td><code>SHR</code></td>
<td>Shift Right</td>
<td>Register, Pointer</td>
<td>Shift the bits of a register right by the contents of memory at an
address in a register</td>
<td><code>0x57</code></td>
</tr>
<tr class="even">
<td><strong>Bitwise</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>AND</code></td>
<td>Bitwise And</td>
<td>Register, Register</td>
<td>Bitwise and one register by another</td>
<td><code>0x60</code></td>
</tr>
<tr class="even">
<td><code>AND</code></td>
<td>Bitwise And</td>
<td>Register, Literal</td>
<td>Bitwise and a register by a literal value</td>
<td><code>0x61</code></td>
</tr>
<tr class="odd">
<td><code>AND</code></td>
<td>Bitwise And</td>
<td>Register, Address</td>
<td>Bitwise and a register by the contents of memory at an address in a
label</td>
<td><code>0x62</code></td>
</tr>
<tr class="even">
<td><code>AND</code></td>
<td>Bitwise And</td>
<td>Register, Pointer</td>
<td>Bitwise and a register by the contents of memory at an address in a
register</td>
<td><code>0x63</code></td>
</tr>
<tr class="odd">
<td><code>ORR</code></td>
<td>Bitwise Or</td>
<td>Register, Register</td>
<td>Bitwise or one register by another</td>
<td><code>0x64</code></td>
</tr>
<tr class="even">
<td><code>ORR</code></td>
<td>Bitwise Or</td>
<td>Register, Literal</td>
<td>Bitwise or a register by a literal value</td>
<td><code>0x65</code></td>
</tr>
<tr class="odd">
<td><code>ORR</code></td>
<td>Bitwise Or</td>
<td>Register, Address</td>
<td>Bitwise or a register by the contents of memory at an address in a
label</td>
<td><code>0x66</code></td>
</tr>
<tr class="even">
<td><code>ORR</code></td>
<td>Bitwise Or</td>
<td>Register, Pointer</td>
<td>Bitwise or a register by the contents of memory at an address in a
register</td>
<td><code>0x67</code></td>
</tr>
<tr class="odd">
<td><code>XOR</code></td>
<td>Bitwise Exclusive Or</td>
<td>Register, Register</td>
<td>Bitwise exclusive or one register by another</td>
<td><code>0x68</code></td>
</tr>
<tr class="even">
<td><code>XOR</code></td>
<td>Bitwise Exclusive Or</td>
<td>Register, Literal</td>
<td>Bitwise exclusive or a register by a literal value</td>
<td><code>0x69</code></td>
</tr>
<tr class="odd">
<td><code>XOR</code></td>
<td>Bitwise Exclusive Or</td>
<td>Register, Address</td>
<td>Bitwise exclusive or a register by the contents of memory at an
address in a label</td>
<td><code>0x6A</code></td>
</tr>
<tr class="even">
<td><code>XOR</code></td>
<td>Bitwise Exclusive Or</td>
<td>Register, Pointer</td>
<td>Bitwise exclusive or a register by the contents of memory at an
address in a register</td>
<td><code>0x6B</code></td>
</tr>
<tr class="odd">
<td><code>NOT</code></td>
<td>Bitwise Not</td>
<td>Register</td>
<td>Invert each bit of a register</td>
<td><code>0x6C</code></td>
</tr>
<tr class="even">
<td><code>RNG</code></td>
<td>Random Number Generator</td>
<td>Register</td>
<td>Randomise each bit of a register</td>
<td><code>0x6D</code></td>
</tr>
<tr class="odd">
<td><strong>Comparison</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>TST</code></td>
<td>Test</td>
<td>Register, Register</td>
<td>Bitwise and two registers, discarding the result whilst still
updating status flags</td>
<td><code>0x70</code></td>
</tr>
<tr class="odd">
<td><code>TST</code></td>
<td>Test</td>
<td>Register, Literal</td>
<td>Bitwise and a register and a literal value, discarding the result
whilst still updating status flags</td>
<td><code>0x71</code></td>
</tr>
<tr class="even">
<td><code>TST</code></td>
<td>Test</td>
<td>Register, Address</td>
<td>Bitwise and a register and the contents of memory at an address in a
label, discarding the result whilst still updating status flags</td>
<td><code>0x72</code></td>
</tr>
<tr class="odd">
<td><code>TST</code></td>
<td>Test</td>
<td>Register, Pointer</td>
<td>Bitwise and a register and the contents of memory at an address in a
register, discarding the result whilst still updating status flags</td>
<td><code>0x73</code></td>
</tr>
<tr class="even">
<td><code>CMP</code></td>
<td>Compare</td>
<td>Register, Register</td>
<td>Subtract a register from another, discarding the result whilst still
updating status flags</td>
<td><code>0x74</code></td>
</tr>
<tr class="odd">
<td><code>CMP</code></td>
<td>Compare</td>
<td>Register, Literal</td>
<td>Subtract a literal value from a register, discarding the result
whilst still updating status flags</td>
<td><code>0x75</code></td>
</tr>
<tr class="even">
<td><code>CMP</code></td>
<td>Compare</td>
<td>Register, Address</td>
<td>Subtract the contents of memory at an address in a label from a
register, discarding the result whilst still updating status flags</td>
<td><code>0x76</code></td>
</tr>
<tr class="odd">
<td><code>CMP</code></td>
<td>Compare</td>
<td>Register, Pointer</td>
<td>Subtract the contents of memory at an address in a register from a
register, discarding the result whilst still updating status flags</td>
<td><code>0x77</code></td>
</tr>
<tr class="even">
<td><strong>Data Moving</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>MVB</code></td>
<td>Move Byte</td>
<td>Register, Register</td>
<td>Move the lower 8-bits of one register to another</td>
<td><code>0x80</code></td>
</tr>
<tr class="even">
<td><code>MVB</code></td>
<td>Move Byte</td>
<td>Register, Literal</td>
<td>Move the lower 8-bits of a literal value to a register</td>
<td><code>0x81</code></td>
</tr>
<tr class="odd">
<td><code>MVB</code></td>
<td>Move Byte</td>
<td>Register, Address</td>
<td>Move 8-bits of the contents of memory starting at an address in a
label to a register</td>
<td><code>0x82</code></td>
</tr>
<tr class="even">
<td><code>MVB</code></td>
<td>Move Byte</td>
<td>Register, Pointer</td>
<td>Move 8-bits of the contents of memory starting at an address in a
register to a register</td>
<td><code>0x83</code></td>
</tr>
<tr class="odd">
<td><code>MVB</code></td>
<td>Move Byte</td>
<td>Address, Register</td>
<td>Move the lower 8-bits of a register to the contents of memory at an
address in a label</td>
<td><code>0x84</code></td>
</tr>
<tr class="even">
<td><code>MVB</code></td>
<td>Move Byte</td>
<td>Address, Literal</td>
<td>Move the lower 8-bits of a literal to the contents of memory at an
address in a label</td>
<td><code>0x85</code></td>
</tr>
<tr class="odd">
<td><code>MVB</code></td>
<td>Move Byte</td>
<td>Pointer, Register</td>
<td>Move the lower 8-bits of a register to the contents of memory at an
address in a register</td>
<td><code>0x86</code></td>
</tr>
<tr class="even">
<td><code>MVB</code></td>
<td>Move Byte</td>
<td>Pointer, Literal</td>
<td>Move the lower 8-bits of a literal to the contents of memory at an
address in a register</td>
<td><code>0x87</code></td>
</tr>
<tr class="odd">
<td><code>MVW</code></td>
<td>Move Word</td>
<td>Register, Register</td>
<td>Move the lower 16-bits (2 bytes) of one register to another</td>
<td><code>0x88</code></td>
</tr>
<tr class="even">
<td><code>MVW</code></td>
<td>Move Word</td>
<td>Register, Literal</td>
<td>Move the lower 16-bits (2 bytes) of a literal value to a
register</td>
<td><code>0x89</code></td>
</tr>
<tr class="odd">
<td><code>MVW</code></td>
<td>Move Word</td>
<td>Register, Address</td>
<td>Move 16-bits (2 bytes) of the contents of memory starting at an
address in a label to a register</td>
<td><code>0x8A</code></td>
</tr>
<tr class="even">
<td><code>MVW</code></td>
<td>Move Word</td>
<td>Register, Pointer</td>
<td>Move 16-bits (2 bytes) of the contents of memory starting at an
address in a register to a register</td>
<td><code>0x8B</code></td>
</tr>
<tr class="odd">
<td><code>MVW</code></td>
<td>Move Word</td>
<td>Address, Register</td>
<td>Move the lower 16-bits (2 bytes) of a register to the contents of
memory at an address in a label</td>
<td><code>0x8C</code></td>
</tr>
<tr class="even">
<td><code>MVW</code></td>
<td>Move Word</td>
<td>Address, Literal</td>
<td>Move the lower 16-bits (2 bytes) of a literal to the contents of
memory at an address in a label</td>
<td><code>0x8D</code></td>
</tr>
<tr class="odd">
<td><code>MVW</code></td>
<td>Move Word</td>
<td>Pointer, Register</td>
<td>Move the lower 16-bits (2 bytes) of a register to the contents of
memory at an address in a register</td>
<td><code>0x8E</code></td>
</tr>
<tr class="even">
<td><code>MVW</code></td>
<td>Move Word</td>
<td>Pointer, Literal</td>
<td>Move the lower 16-bits (2 bytes) of a literal to the contents of
memory at an address in a register</td>
<td><code>0x8F</code></td>
</tr>
<tr class="odd">
<td><code>MVD</code></td>
<td>Move Double Word</td>
<td>Register, Register</td>
<td>Move the lower 32-bits (4 bytes) of one register to another</td>
<td><code>0x90</code></td>
</tr>
<tr class="even">
<td><code>MVD</code></td>
<td>Move Double Word</td>
<td>Register, Literal</td>
<td>Move the lower 32-bits (4 bytes) of a literal value to a
register</td>
<td><code>0x91</code></td>
</tr>
<tr class="odd">
<td><code>MVD</code></td>
<td>Move Double Word</td>
<td>Register, Address</td>
<td>Move 32-bits (4 bytes) of the contents of memory starting at an
address in a label to a register</td>
<td><code>0x92</code></td>
</tr>
<tr class="even">
<td><code>MVD</code></td>
<td>Move Double Word</td>
<td>Register, Pointer</td>
<td>Move 32-bits (4 bytes) of the contents of memory starting at an
address in a register to a register</td>
<td><code>0x93</code></td>
</tr>
<tr class="odd">
<td><code>MVD</code></td>
<td>Move Double Word</td>
<td>Address, Register</td>
<td>Move the lower 32-bits (4 bytes) of a register to the contents of
memory at an address in a label</td>
<td><code>0x94</code></td>
</tr>
<tr class="even">
<td><code>MVD</code></td>
<td>Move Double Word</td>
<td>Address, Literal</td>
<td>Move the lower 32-bits (4 bytes) of a literal to the contents of
memory at an address in a label</td>
<td><code>0x95</code></td>
</tr>
<tr class="odd">
<td><code>MVD</code></td>
<td>Move Double Word</td>
<td>Pointer, Register</td>
<td>Move the lower 32-bits (4 bytes) of a register to the contents of
memory at an address in a register</td>
<td><code>0x96</code></td>
</tr>
<tr class="even">
<td><code>MVD</code></td>
<td>Move Double Word</td>
<td>Pointer, Literal</td>
<td>Move the lower 32-bits (4 bytes) of a literal to the contents of
memory at an address in a register</td>
<td><code>0x97</code></td>
</tr>
<tr class="odd">
<td><code>MVQ</code></td>
<td>Move Quad Word</td>
<td>Register, Register</td>
<td>Move all 64-bits (8 bytes) of one register to another</td>
<td><code>0x98</code></td>
</tr>
<tr class="even">
<td><code>MVQ</code></td>
<td>Move Quad Word</td>
<td>Register, Literal</td>
<td>Move all 64-bits (8 bytes) of a literal value to a register</td>
<td><code>0x99</code></td>
</tr>
<tr class="odd">
<td><code>MVQ</code></td>
<td>Move Quad Word</td>
<td>Register, Address</td>
<td>Move 64-bits (8 bytes) of the contents of memory starting at an
address in a label to a register</td>
<td><code>0x9A</code></td>
</tr>
<tr class="even">
<td><code>MVQ</code></td>
<td>Move Quad Word</td>
<td>Register, Pointer</td>
<td>Move 64-bits (8 bytes) of the contents of memory starting at an
address in a register to a register</td>
<td><code>0x9B</code></td>
</tr>
<tr class="odd">
<td><code>MVQ</code></td>
<td>Move Quad Word</td>
<td>Address, Register</td>
<td>Move all 64-bits (8 bytes) of a register to the contents of memory
at an address in a label</td>
<td><code>0x9C</code></td>
</tr>
<tr class="even">
<td><code>MVQ</code></td>
<td>Move Quad Word</td>
<td>Address, Literal</td>
<td>Move all 64-bits (8 bytes) of a literal to the contents of memory at
an address in a label</td>
<td><code>0x9D</code></td>
</tr>
<tr class="odd">
<td><code>MVQ</code></td>
<td>Move Quad Word</td>
<td>Pointer, Register</td>
<td>Move all 64-bits (8 bytes) of a register to the contents of memory
at an address in a register</td>
<td><code>0x9E</code></td>
</tr>
<tr class="even">
<td><code>MVQ</code></td>
<td>Move Quad Word</td>
<td>Pointer, Literal</td>
<td>Move all 64-bits (8 bytes) of a literal to the contents of memory at
an address in a register</td>
<td><code>0x9F</code></td>
</tr>
<tr class="odd">
<td><strong>Stack</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>PSH</code></td>
<td>Push to Stack</td>
<td>Register</td>
<td>Insert the value in a register to the top of the stack</td>
<td><code>0xA0</code></td>
</tr>
<tr class="odd">
<td><code>PSH</code></td>
<td>Push to Stack</td>
<td>Literal</td>
<td>Insert a literal value to the top of the stack</td>
<td><code>0xA1</code></td>
</tr>
<tr class="even">
<td><code>PSH</code></td>
<td>Push to Stack</td>
<td>Address</td>
<td>Insert the contents of memory at an address in a label to the top of
the stack</td>
<td><code>0xA2</code></td>
</tr>
<tr class="odd">
<td><code>PSH</code></td>
<td>Push to Stack</td>
<td>Pointer</td>
<td>Insert the contents of memory at an address in a register to the top
of the stack</td>
<td><code>0xA3</code></td>
</tr>
<tr class="even">
<td><code>POP</code></td>
<td>Pop from Stack</td>
<td>Register</td>
<td>Remove the value from the top of the stack and store it in a
register</td>
<td><code>0xA4</code></td>
</tr>
<tr class="odd">
<td><strong>Subroutines</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Address</td>
<td>Call the subroutine at an address in a label, pushing
<code>rpo</code> and <code>rsb</code> to the stack</td>
<td><code>0xB0</code></td>
</tr>
<tr class="odd">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Pointer</td>
<td>Call the subroutine at an address in a register, pushing
<code>rpo</code> and <code>rsb</code> to the stack</td>
<td><code>0xB1</code></td>
</tr>
<tr class="even">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Address, Register</td>
<td>Call the subroutine at an address in a label, moving the value in a
register to <code>rfp</code></td>
<td><code>0xB2</code></td>
</tr>
<tr class="odd">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Address, Literal</td>
<td>Call the subroutine at an address in a label, moving a literal value
to <code>rfp</code></td>
<td><code>0xB3</code></td>
</tr>
<tr class="even">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Address, Address</td>
<td>Call the subroutine at an address in a label, moving the contents of
memory at an address in a label to <code>rfp</code></td>
<td><code>0xB4</code></td>
</tr>
<tr class="odd">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Address, Pointer</td>
<td>Call the subroutine at an address in a label, moving the contents of
memory at an address in a register to <code>rfp</code></td>
<td><code>0xB5</code></td>
</tr>
<tr class="even">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Pointer, Register</td>
<td>Call the subroutine at an address in a register, moving the value in
a register to <code>rfp</code></td>
<td><code>0xB6</code></td>
</tr>
<tr class="odd">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Pointer, Literal</td>
<td>Call the subroutine at an address in a register, moving a literal
value to <code>rfp</code></td>
<td><code>0xB7</code></td>
</tr>
<tr class="even">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Pointer, Address</td>
<td>Call the subroutine at an address in a register, moving the contents
of memory at an address in a label to <code>rfp</code></td>
<td><code>0xB8</code></td>
</tr>
<tr class="odd">
<td><code>CAL</code></td>
<td>Call Subroutine</td>
<td>Pointer, Pointer</td>
<td>Call the subroutine at an address in a register, moving the contents
of memory at an address in a register to <code>rfp</code></td>
<td><code>0xB9</code></td>
</tr>
<tr class="even">
<td><code>RET</code></td>
<td>Return from Subroutine</td>
<td>-</td>
<td>Pop the previous states of <code>rsb</code> and <code>rpo</code> off
the stack</td>
<td><code>0xBA</code></td>
</tr>
<tr class="odd">
<td><code>RET</code></td>
<td>Return from Subroutine</td>
<td>Register</td>
<td>Pop the previous states of <code>rsb</code> and <code>rpo</code> off
the stack, moving the value in a register to <code>rrv</code></td>
<td><code>0xBB</code></td>
</tr>
<tr class="even">
<td><code>RET</code></td>
<td>Return from Subroutine</td>
<td>Literal</td>
<td>Pop the previous states of <code>rsb</code> and <code>rpo</code> off
the stack, moving a literal value to <code>rrv</code></td>
<td><code>0xBC</code></td>
</tr>
<tr class="odd">
<td><code>RET</code></td>
<td>Return from Subroutine</td>
<td>Address</td>
<td>Pop the previous states off the stack, moving the contents of memory
at an address in a label to <code>rrv</code></td>
<td><code>0xBD</code></td>
</tr>
<tr class="even">
<td><code>RET</code></td>
<td>Return from Subroutine</td>
<td>Pointer</td>
<td>Pop the previous states off the stack, moving the contents of memory
at an address in a register to <code>rrv</code></td>
<td><code>0xBE</code></td>
</tr>
<tr class="odd">
<td><strong>Console Writing</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>WCN</code></td>
<td>Write Number to Console</td>
<td>Register</td>
<td>Write a register value as a decimal number to the console</td>
<td><code>0xC0</code></td>
</tr>
<tr class="odd">
<td><code>WCN</code></td>
<td>Write Number to Console</td>
<td>Literal</td>
<td>Write a literal value as a decimal number to the console</td>
<td><code>0xC1</code></td>
</tr>
<tr class="even">
<td><code>WCN</code></td>
<td>Write Number to Console</td>
<td>Address</td>
<td>Write 64-bits (4 bytes) of memory starting at the address in a label
as a decimal number to the console</td>
<td><code>0xC2</code></td>
</tr>
<tr class="odd">
<td><code>WCN</code></td>
<td>Write Number to Console</td>
<td>Pointer</td>
<td>Write 64-bits (4 bytes) of memory starting at the address in a
register as a decimal number to the console</td>
<td><code>0xC3</code></td>
</tr>
<tr class="even">
<td><code>WCB</code></td>
<td>Write Numeric Byte to Console</td>
<td>Register</td>
<td>Write the lower 8-bits of a register value as a decimal number to
the console</td>
<td><code>0xC4</code></td>
</tr>
<tr class="odd">
<td><code>WCB</code></td>
<td>Write Numeric Byte to Console</td>
<td>Literal</td>
<td>Write the lower 8-bits of a literal value as a decimal number to the
console</td>
<td><code>0xC5</code></td>
</tr>
<tr class="even">
<td><code>WCB</code></td>
<td>Write Numeric Byte to Console</td>
<td>Address</td>
<td>Write contents of memory at the address in a label as a decimal
number to the console</td>
<td><code>0xC6</code></td>
</tr>
<tr class="odd">
<td><code>WCB</code></td>
<td>Write Numeric Byte to Console</td>
<td>Pointer</td>
<td>Write contents of memory at the address in a register as a decimal
number to the console</td>
<td><code>0xC7</code></td>
</tr>
<tr class="even">
<td><code>WCX</code></td>
<td>Write Hexadecimal to Console</td>
<td>Register</td>
<td>Write the lower 8-bits of a register value as a hexadecimal number
to the console</td>
<td><code>0xC8</code></td>
</tr>
<tr class="odd">
<td><code>WCX</code></td>
<td>Write Hexadecimal to Console</td>
<td>Literal</td>
<td>Write the lower 8-bits of a literal value as a hexadecimal number to
the console</td>
<td><code>0xC9</code></td>
</tr>
<tr class="even">
<td><code>WCX</code></td>
<td>Write Hexadecimal to Console</td>
<td>Address</td>
<td>Write contents of memory at the address in a label as a hexadecimal
number to the console</td>
<td><code>0xCA</code></td>
</tr>
<tr class="odd">
<td><code>WCX</code></td>
<td>Write Hexadecimal to Console</td>
<td>Pointer</td>
<td>Write contents of memory at the address in a register as a
hexadecimal number to the console</td>
<td><code>0xCB</code></td>
</tr>
<tr class="even">
<td><code>WCC</code></td>
<td>Write Raw Byte to Console</td>
<td>Register</td>
<td>Write the lower 8-bits of a register value as a raw byte to the
console</td>
<td><code>0xCC</code></td>
</tr>
<tr class="odd">
<td><code>WCC</code></td>
<td>Write Raw Byte to Console</td>
<td>Literal</td>
<td>Write the lower 8-bits of a literal value as a raw byte to the
console</td>
<td><code>0xCD</code></td>
</tr>
<tr class="even">
<td><code>WCC</code></td>
<td>Write Raw Byte to Console</td>
<td>Address</td>
<td>Write contents of memory at the address in a label as a raw byte to
the console</td>
<td><code>0xCE</code></td>
</tr>
<tr class="odd">
<td><code>WCC</code></td>
<td>Write Raw Byte to Console</td>
<td>Pointer</td>
<td>Write contents of memory at the address in a register as a raw byte
to the console</td>
<td><code>0xCF</code></td>
</tr>
<tr class="even">
<td><strong>File Writing</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>WFN</code></td>
<td>Write Number to File</td>
<td>Register</td>
<td>Write a register value as a decimal number to the opened file</td>
<td><code>0xD0</code></td>
</tr>
<tr class="even">
<td><code>WFN</code></td>
<td>Write Number to File</td>
<td>Literal</td>
<td>Write a literal value as a decimal number to the opened file</td>
<td><code>0xD1</code></td>
</tr>
<tr class="odd">
<td><code>WFN</code></td>
<td>Write Number to File</td>
<td>Address</td>
<td>Write 64-bits (4 bytes) of memory starting at the address in a label
as a decimal number to the opened file</td>
<td><code>0xD2</code></td>
</tr>
<tr class="even">
<td><code>WFN</code></td>
<td>Write Number to File</td>
<td>Pointer</td>
<td>Write 64-bits (4 bytes) of memory starting at the address in a
register as a decimal number to the opened file</td>
<td><code>0xD3</code></td>
</tr>
<tr class="odd">
<td><code>WFB</code></td>
<td>Write Numeric Byte to File</td>
<td>Register</td>
<td>Write the lower 8-bits of a register value as a decimal number to
the opened file</td>
<td><code>0xD4</code></td>
</tr>
<tr class="even">
<td><code>WFB</code></td>
<td>Write Numeric Byte to File</td>
<td>Literal</td>
<td>Write the lower 8-bits of a literal value as a decimal number to the
opened file</td>
<td><code>0xD5</code></td>
</tr>
<tr class="odd">
<td><code>WFB</code></td>
<td>Write Numeric Byte to File</td>
<td>Address</td>
<td>Write contents of memory at the address in a label as a decimal
number to the opened file</td>
<td><code>0xD6</code></td>
</tr>
<tr class="even">
<td><code>WFB</code></td>
<td>Write Numeric Byte to File</td>
<td>Pointer</td>
<td>Write contents of memory at the address in a register as a decimal
number to the opened file</td>
<td><code>0xD7</code></td>
</tr>
<tr class="odd">
<td><code>WFX</code></td>
<td>Write Hexadecimal to File</td>
<td>Register</td>
<td>Write the lower 8-bits of a register value as a hexadecimal number
to the opened file</td>
<td><code>0xD8</code></td>
</tr>
<tr class="even">
<td><code>WFX</code></td>
<td>Write Hexadecimal to File</td>
<td>Literal</td>
<td>Write the lower 8-bits of a literal value as a hexadecimal number to
the opened file</td>
<td><code>0xD9</code></td>
</tr>
<tr class="odd">
<td><code>WFX</code></td>
<td>Write Hexadecimal to File</td>
<td>Address</td>
<td>Write contents of memory at the address in a label as a hexadecimal
number to the opened file</td>
<td><code>0xDA</code></td>
</tr>
<tr class="even">
<td><code>WFX</code></td>
<td>Write Hexadecimal to File</td>
<td>Pointer</td>
<td>Write contents of memory at the address in a register as a
hexadecimal number to the opened file</td>
<td><code>0xDB</code></td>
</tr>
<tr class="odd">
<td><code>WFC</code></td>
<td>Write Raw Byte to File</td>
<td>Register</td>
<td>Write the lower 8-bits of a register value as a raw byte to the
opened file</td>
<td><code>0xDC</code></td>
</tr>
<tr class="even">
<td><code>WFC</code></td>
<td>Write Raw Byte to File</td>
<td>Literal</td>
<td>Write the lower 8-bits of a literal value as a raw byte to the
opened file</td>
<td><code>0xDD</code></td>
</tr>
<tr class="odd">
<td><code>WFC</code></td>
<td>Write Raw Byte to File</td>
<td>Address</td>
<td>Write contents of memory at the address in a label as a raw byte to
the opened file</td>
<td><code>0xDE</code></td>
</tr>
<tr class="even">
<td><code>WFC</code></td>
<td>Write Raw Byte to File</td>
<td>Pointer</td>
<td>Write contents of memory at the address in a register as a raw byte
to the opened file</td>
<td><code>0xDF</code></td>
</tr>
<tr class="odd">
<td><strong>File Operations</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>OFL</code></td>
<td>Open File</td>
<td>Address</td>
<td>Open the file at the path specified by a <code>0x00</code>
terminated string in memory starting at an address in a label</td>
<td><code>0xE0</code></td>
</tr>
<tr class="odd">
<td><code>OFL</code></td>
<td>Open File</td>
<td>Pointer</td>
<td>Open the file at the path specified by a <code>0x00</code>
terminated string in memory starting at an address in a register</td>
<td><code>0xE1</code></td>
</tr>
<tr class="even">
<td><code>CFL</code></td>
<td>Close File</td>
<td>-</td>
<td>Close the currently open file</td>
<td><code>0xE2</code></td>
</tr>
<tr class="odd">
<td><code>DFL</code></td>
<td>Delete File</td>
<td>Address</td>
<td>Delete the file at the path specified by a <code>0x00</code>
terminated string in memory starting at an address in a label</td>
<td><code>0xE3</code></td>
</tr>
<tr class="even">
<td><code>DFL</code></td>
<td>Delete File</td>
<td>Pointer</td>
<td>Delete the file at the path specified by a <code>0x00</code>
terminated string in memory starting at an address in a register</td>
<td><code>0xE4</code></td>
</tr>
<tr class="odd">
<td><code>FEX</code></td>
<td>File Exists</td>
<td>Register, Address</td>
<td>Store <code>1</code> in a register if the filepath specified in
memory starting at an address in a label exists, else
<code>0</code></td>
<td><code>0xE5</code></td>
</tr>
<tr class="even">
<td><code>FEX</code></td>
<td>File Exists</td>
<td>Register, Pointer</td>
<td>Store <code>1</code> in a register if the filepath specified in
memory starting at an address in a register exists, else
<code>0</code></td>
<td><code>0xE6</code></td>
</tr>
<tr class="odd">
<td><code>FSZ</code></td>
<td>Get File Size</td>
<td>Register, Address</td>
<td>In a register, store the byte size of the file at the path specified
in memory starting at an address in a label</td>
<td><code>0xE7</code></td>
</tr>
<tr class="even">
<td><code>FSZ</code></td>
<td>Get File Size</td>
<td>Register, Pointer</td>
<td>In a register, store the byte size of the file at the path specified
in memory starting at an address in a register</td>
<td><code>0xE8</code></td>
</tr>
<tr class="odd">
<td><strong>Reading</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>RCC</code></td>
<td>Read Raw Byte from Console</td>
<td>Register</td>
<td>Read a raw byte from the console, storing it in a register</td>
<td><code>0xF0</code></td>
</tr>
<tr class="odd">
<td><code>RFC</code></td>
<td>Read Raw Byte from File</td>
<td>Register</td>
<td>Read the next byte from the currently open file, storing it in a
register</td>
<td><code>0xF1</code></td>
</tr>
</tbody>
</table>
<h3 id="signed-extension-set">Signed Extension Set</h3>
<p>Extension set number <code>0x01</code>, opcodes start with
<code>0xFF, 0x01</code>.</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 18%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>Mnemonic</th>
<th>Full Name</th>
<th>Operands</th>
<th>Function</th>
<th>Instruction Code</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Signed Conditional Jumps</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>SIGN_JLT</code></td>
<td>Jump if Less Than</td>
<td>Address</td>
<td>Jump to an address in a label only if the sign and overflow status
flags are different</td>
<td><code>0x00</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_JLT</code></td>
<td>Jump if Less Than</td>
<td>Pointer</td>
<td>Jump to an address in a register only if the sign and overflow
status flags are different</td>
<td><code>0x01</code></td>
</tr>
<tr class="even">
<td><code>SIGN_JLE</code></td>
<td>Jump if Less Than or Equal To</td>
<td>Address</td>
<td>Jump to an address in a label only if the sign and overflow status
flags are different or the zero status flag is set</td>
<td><code>0x02</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_JLE</code></td>
<td>Jump if Less Than or Equal To</td>
<td>Pointer</td>
<td>Jump to an address in a register only if the sign and overflow
status flags are different or the zero status flag is set</td>
<td><code>0x03</code></td>
</tr>
<tr class="even">
<td><code>SIGN_JGT</code></td>
<td>Jump if Greater Than</td>
<td>Address</td>
<td>Jump to an address in a label only if the sign and overflow status
flags are the same and the zero status flag is unset</td>
<td><code>0x04</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_JGT</code></td>
<td>Jump if Greater Than</td>
<td>Pointer</td>
<td>Jump to an address in a register only if the sign and overflow
status flags are the same and the zero status flag is unset</td>
<td><code>0x05</code></td>
</tr>
<tr class="even">
<td><code>SIGN_JGE</code></td>
<td>Jump if Greater Than or Equal To</td>
<td>Address</td>
<td>Jump to an address in a label only if the sign and overflow status
flags are the same</td>
<td><code>0x06</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_JGE</code></td>
<td>Jump if Greater Than or Equal To</td>
<td>Pointer</td>
<td>Jump to an address in a register only if the sign and overflow
status flags are the same</td>
<td><code>0x07</code></td>
</tr>
<tr class="even">
<td><code>SIGN_JSI</code></td>
<td>Jump if Signed</td>
<td>Address</td>
<td>Jump to an address in a label only if the sign status flag is
set</td>
<td><code>0x08</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_JSI</code></td>
<td>Jump if Signed</td>
<td>Pointer</td>
<td>Jump to an address in a register only if the sign status flag is
set</td>
<td><code>0x09</code></td>
</tr>
<tr class="even">
<td><code>SIGN_JNS</code></td>
<td>Jump if not Sign</td>
<td>Address</td>
<td>Jump to an address in a label only if the sign status flag is
unset</td>
<td><code>0x0A</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_JNS</code></td>
<td>Jump if not Sign</td>
<td>Pointer</td>
<td>Jump to an address in a register only the sign status flag is
unset</td>
<td><code>0x0B</code></td>
</tr>
<tr class="even">
<td><code>SIGN_JOV</code></td>
<td>Jump if Overflow</td>
<td>Address</td>
<td>Jump to an address in a label only if the overflow status flag is
set</td>
<td><code>0x0C</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_JOV</code></td>
<td>Jump if Overflow</td>
<td>Pointer</td>
<td>Jump to an address in a register only if the overflow status flag is
set</td>
<td><code>0x0D</code></td>
</tr>
<tr class="even">
<td><code>SIGN_JNO</code></td>
<td>Jump if not Overflow</td>
<td>Address</td>
<td>Jump to an address in a label only if the overflow status flag is
unset</td>
<td><code>0x0E</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_JNO</code></td>
<td>Jump if not Overflow</td>
<td>Pointer</td>
<td>Jump to an address in a register only if the overflow status flag is
unset</td>
<td><code>0x0F</code></td>
</tr>
<tr class="even">
<td><strong>Math</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>SIGN_DIV</code></td>
<td>Integer Divide</td>
<td>Register, Register</td>
<td>Divide the contents of one register by another, discarding the
remainder</td>
<td><code>0x10</code></td>
</tr>
<tr class="even">
<td><code>SIGN_DIV</code></td>
<td>Integer Divide</td>
<td>Register, Literal</td>
<td>Divide the contents of a register by a literal value, discarding the
remainder</td>
<td><code>0x11</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_DIV</code></td>
<td>Integer Divide</td>
<td>Register, Address</td>
<td>Divide a register by the contents of memory at an address in a
label, discarding the remainder</td>
<td><code>0x12</code></td>
</tr>
<tr class="even">
<td><code>SIGN_DIV</code></td>
<td>Integer Divide</td>
<td>Register, Pointer</td>
<td>Divide a register by the contents of memory at an address in a
register, discarding the remainder</td>
<td><code>0x13</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_DVR</code></td>
<td>Divide With Remainder</td>
<td>Register, Register, Register</td>
<td>Divide the contents of one register by another, storing the
remainder</td>
<td><code>0x14</code></td>
</tr>
<tr class="even">
<td><code>SIGN_DVR</code></td>
<td>Divide With Remainder</td>
<td>Register, Register, Literal</td>
<td>Divide the contents of a register by a literal value, storing the
remainder</td>
<td><code>0x15</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_DVR</code></td>
<td>Divide With Remainder</td>
<td>Register, Register, Address</td>
<td>Divide a register by the contents of memory at an address in a
label, storing the remainder</td>
<td><code>0x16</code></td>
</tr>
<tr class="even">
<td><code>SIGN_DVR</code></td>
<td>Divide With Remainder</td>
<td>Register, Register, Pointer</td>
<td>Divide a register by the contents of memory at an address in a
register, storing the remainder</td>
<td><code>0x17</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_REM</code></td>
<td>Remainder Only</td>
<td>Register, Register</td>
<td>Divide the contents of one register by another, storing only the
remainder</td>
<td><code>0x18</code></td>
</tr>
<tr class="even">
<td><code>SIGN_REM</code></td>
<td>Remainder Only</td>
<td>Register, Literal</td>
<td>Divide the contents of a register by a literal value, storing only
the remainder</td>
<td><code>0x19</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_REM</code></td>
<td>Remainder Only</td>
<td>Register, Address</td>
<td>Divide a register by the contents of memory at an address in a
label, storing only the remainder</td>
<td><code>0x1A</code></td>
</tr>
<tr class="even">
<td><code>SIGN_REM</code></td>
<td>Remainder Only</td>
<td>Register, Pointer</td>
<td>Divide a register by the contents of memory at an address in a
register, storing only the remainder</td>
<td><code>0x1B</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_SHR</code></td>
<td>Arithmetic Shift Right</td>
<td>Register, Register</td>
<td>Shift the bits of one register right by another register, preserving
the sign of the original value</td>
<td><code>0x20</code></td>
</tr>
<tr class="even">
<td><code>SIGN_SHR</code></td>
<td>Arithmetic Shift Right</td>
<td>Register, Literal</td>
<td>Shift the bits of a register right by a literal value, preserving
the sign of the original value</td>
<td><code>0x21</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_SHR</code></td>
<td>Arithmetic Shift Right</td>
<td>Register, Address</td>
<td>Shift the bits of a register right by the contents of memory at an
address in a label, preserving the sign of the original value</td>
<td><code>0x22</code></td>
</tr>
<tr class="even">
<td><code>SIGN_SHR</code></td>
<td>Arithmetic Shift Right</td>
<td>Register, Pointer</td>
<td>Shift the bits of a register right by the contents of memory at an
address in a register, preserving the sign of the original value</td>
<td><code>0x23</code></td>
</tr>
<tr class="odd">
<td><strong>Sign-Extending Data Moves</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>SIGN_MVB</code></td>
<td>Move Byte, Extend to Quad Word</td>
<td>Register, Register</td>
<td>Move the lower 8-bits of one register to another, extending the
resulting value to a signed 64-bit value</td>
<td><code>0x30</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_MVB</code></td>
<td>Move Byte, Extend to Quad Word</td>
<td>Register, Literal</td>
<td>Move the lower 8-bits of a literal value to a register, extending
the resulting value to a signed 64-bit value</td>
<td><code>0x31</code></td>
</tr>
<tr class="even">
<td><code>SIGN_MVB</code></td>
<td>Move Byte, Extend to Quad Word</td>
<td>Register, Address</td>
<td>Move 8-bits of the contents of memory starting at an address in a
label to a register, extending the resulting value to a signed 64-bit
value</td>
<td><code>0x32</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_MVB</code></td>
<td>Move Byte, Extend to Quad Word</td>
<td>Register, Pointer</td>
<td>Move 8-bits of the contents of memory starting at an address in a
register to a register, extending the resulting value to a signed 64-bit
value</td>
<td><code>0x33</code></td>
</tr>
<tr class="even">
<td><code>SIGN_MVW</code></td>
<td>Move Word, Extend to Quad Word</td>
<td>Register, Register</td>
<td>Move the lower 16-bits (2 bytes) of one register to another,
extending the resulting value to a signed 64-bit value</td>
<td><code>0x34</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_MVW</code></td>
<td>Move Word, Extend to Quad Word</td>
<td>Register, Literal</td>
<td>Move the lower 16-bits (2 bytes) of a literal value to a register,
extending the resulting value to a signed 64-bit value</td>
<td><code>0x35</code></td>
</tr>
<tr class="even">
<td><code>SIGN_MVW</code></td>
<td>Move Word, Extend to Quad Word</td>
<td>Register, Address</td>
<td>Move 16-bits (2 bytes) of the contents of memory starting at an
address in a label to a register, extending the resulting value to a
signed 64-bit value</td>
<td><code>0x36</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_MVW</code></td>
<td>Move Word, Extend to Quad Word</td>
<td>Register, Pointer</td>
<td>Move 16-bits (2 bytes) of the contents of memory starting at an
address in a register to a register, extending the resulting value to a
signed 64-bit value</td>
<td><code>0x37</code></td>
</tr>
<tr class="even">
<td><code>SIGN_MVD</code></td>
<td>Move Double Word, Extend to Quad Word</td>
<td>Register, Register</td>
<td>Move the lower 32-bits (4 bytes) of one register to another,
extending the resulting value to a signed 64-bit value</td>
<td><code>0x40</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_MVD</code></td>
<td>Move Double Word, Extend to Quad Word</td>
<td>Register, Literal</td>
<td>Move the lower 32-bits (4 bytes) of a literal value to a register,
extending the resulting value to a signed 64-bit value</td>
<td><code>0x41</code></td>
</tr>
<tr class="even">
<td><code>SIGN_MVD</code></td>
<td>Move Double Word, Extend to Quad Word</td>
<td>Register, Address</td>
<td>Move 32-bits (4 bytes) of the contents of memory starting at an
address in a label to a register, extending the resulting value to a
signed 64-bit value</td>
<td><code>0x42</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_MVD</code></td>
<td>Move Double Word, Extend to Quad Word</td>
<td>Register, Pointer</td>
<td>Move 32-bits (4 bytes) of the contents of memory starting at an
address in a register to a register, extending the resulting value to a
signed 64-bit value</td>
<td><code>0x43</code></td>
</tr>
<tr class="even">
<td><strong>Console Writing</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>SIGN_WCN</code></td>
<td>Write Number to Console</td>
<td>Register</td>
<td>Write a register value as a signed decimal number to the
console</td>
<td><code>0x50</code></td>
</tr>
<tr class="even">
<td><code>SIGN_WCN</code></td>
<td>Write Number to Console</td>
<td>Literal</td>
<td>Write a literal value as a signed decimal number to the console</td>
<td><code>0x51</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_WCN</code></td>
<td>Write Number to Console</td>
<td>Address</td>
<td>Write 64-bits (4 bytes) of memory starting at the address in a label
as a signed decimal number to the console</td>
<td><code>0x52</code></td>
</tr>
<tr class="even">
<td><code>SIGN_WCN</code></td>
<td>Write Number to Console</td>
<td>Pointer</td>
<td>Write 64-bits (4 bytes) of memory starting at the address in a
register as a signed decimal number to the console</td>
<td><code>0x53</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_WCB</code></td>
<td>Write Numeric Byte to Console</td>
<td>Register</td>
<td>Write the lower 8-bits of a register value as a signed decimal
number to the console</td>
<td><code>0x54</code></td>
</tr>
<tr class="even">
<td><code>SIGN_WCB</code></td>
<td>Write Numeric Byte to Console</td>
<td>Literal</td>
<td>Write the lower 8-bits of a literal value as a signed decimal number
to the console</td>
<td><code>0x55</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_WCB</code></td>
<td>Write Numeric Byte to Console</td>
<td>Address</td>
<td>Write contents of memory at the address in a label as a signed
decimal number to the console</td>
<td><code>0x56</code></td>
</tr>
<tr class="even">
<td><code>SIGN_WCB</code></td>
<td>Write Numeric Byte to Console</td>
<td>Pointer</td>
<td>Write contents of memory at the address in a register as a signed
decimal number to the console</td>
<td><code>0x57</code></td>
</tr>
<tr class="odd">
<td><strong>File Writing</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>SIGN_WFN</code></td>
<td>Write Number to File</td>
<td>Register</td>
<td>Write a register value as a signed decimal number to the opened
file</td>
<td><code>0x60</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_WFN</code></td>
<td>Write Number to File</td>
<td>Literal</td>
<td>Write a literal value as a signed decimal number to the opened
file</td>
<td><code>0x61</code></td>
</tr>
<tr class="even">
<td><code>SIGN_WFN</code></td>
<td>Write Number to File</td>
<td>Address</td>
<td>Write 64-bits (4 bytes) of memory starting at the address in a label
as a signed decimal number to the opened file</td>
<td><code>0x62</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_WFN</code></td>
<td>Write Number to File</td>
<td>Pointer</td>
<td>Write 64-bits (4 bytes) of memory starting at the address in a
register as a signed decimal number to the opened file</td>
<td><code>0x63</code></td>
</tr>
<tr class="even">
<td><code>SIGN_WFB</code></td>
<td>Write Numeric Byte to File</td>
<td>Register</td>
<td>Write the lower 8-bits of a register value as a signed decimal
number to the opened file</td>
<td><code>0x64</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_WFB</code></td>
<td>Write Numeric Byte to File</td>
<td>Literal</td>
<td>Write the lower 8-bits of a literal value as a signed decimal number
to the opened file</td>
<td><code>0x65</code></td>
</tr>
<tr class="even">
<td><code>SIGN_WFB</code></td>
<td>Write Numeric Byte to File</td>
<td>Address</td>
<td>Write contents of memory at the address in a label as a signed
decimal number to the opened file</td>
<td><code>0x66</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_WFB</code></td>
<td>Write Numeric Byte to File</td>
<td>Pointer</td>
<td>Write contents of memory at the address in a register as a signed
decimal number to the opened file</td>
<td><code>0x67</code></td>
</tr>
<tr class="even">
<td><strong>Sign Extension</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>SIGN_EXB</code></td>
<td>Extend Signed Byte to Signed Quad Word</td>
<td>Register</td>
<td>Convert the signed value in the lower 8-bits of a register to its
equivalent representation as a signed 64-bit number</td>
<td><code>0x70</code></td>
</tr>
<tr class="even">
<td><code>SIGN_EXW</code></td>
<td>Extend Signed Word to Signed Quad Word</td>
<td>Register</td>
<td>Convert the signed value in the lower 16-bits of a register to its
equivalent representation as a signed 64-bit number</td>
<td><code>0x71</code></td>
</tr>
<tr class="odd">
<td><code>SIGN_EXD</code></td>
<td>Extend Signed Double Word to Signed Quad Word</td>
<td>Register</td>
<td>Convert the signed value in the lower 32-bits of a register to its
equivalent representation as a signed 64-bit number</td>
<td><code>0x72</code></td>
</tr>
<tr class="even">
<td><strong>Negation</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>SIGN_NEG</code></td>
<td>Two’s Complement Negation</td>
<td>Register</td>
<td>Replace the value in a register with its two’s complement, thereby
flipping the sign of the value.</td>
<td><code>0x80</code></td>
</tr>
</tbody>
</table>
<h3 id="floating-point-extension-set">Floating Point Extension Set</h3>
<p>Extension set number <code>0x02</code>, opcodes start with
<code>0xFF, 0x02</code>.</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 18%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>Mnemonic</th>
<th>Full Name</th>
<th>Operands</th>
<th>Function</th>
<th>Instruction Code</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Math</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>FLPT_ADD</code></td>
<td>Add</td>
<td>Register, Register</td>
<td>Add the contents of one register to another</td>
<td><code>0x00</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_ADD</code></td>
<td>Add</td>
<td>Register, Literal</td>
<td>Add a literal value to the contents of a register</td>
<td><code>0x01</code></td>
</tr>
<tr class="even">
<td><code>FLPT_ADD</code></td>
<td>Add</td>
<td>Register, Address</td>
<td>Add the contents of memory at an address in a label to a
register</td>
<td><code>0x02</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_ADD</code></td>
<td>Add</td>
<td>Register, Pointer</td>
<td>Add the contents of memory at an address in a register to a
register</td>
<td><code>0x03</code></td>
</tr>
<tr class="even">
<td><code>FLPT_SUB</code></td>
<td>Subtract</td>
<td>Register, Register</td>
<td>Subtract the contents of one register from another</td>
<td><code>0x10</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_SUB</code></td>
<td>Subtract</td>
<td>Register, Literal</td>
<td>Subtract a literal value from the contents of a register</td>
<td><code>0x11</code></td>
</tr>
<tr class="even">
<td><code>FLPT_SUB</code></td>
<td>Subtract</td>
<td>Register, Address</td>
<td>Subtract the contents of memory at an address in a label from a
register</td>
<td><code>0x12</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_SUB</code></td>
<td>Subtract</td>
<td>Register, Pointer</td>
<td>Subtract the contents of memory at an address in a register from a
register</td>
<td><code>0x13</code></td>
</tr>
<tr class="even">
<td><code>FLPT_MUL</code></td>
<td>Multiply</td>
<td>Register, Register</td>
<td>Multiply the contents of one register by another</td>
<td><code>0x20</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_MUL</code></td>
<td>Multiply</td>
<td>Register, Literal</td>
<td>Multiply the contents of a register by a literal value</td>
<td><code>0x21</code></td>
</tr>
<tr class="even">
<td><code>FLPT_MUL</code></td>
<td>Multiply</td>
<td>Register, Address</td>
<td>Multiply a register by the contents of memory at an address in a
label</td>
<td><code>0x22</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_MUL</code></td>
<td>Multiply</td>
<td>Register, Pointer</td>
<td>Multiply a register by the contents of memory at an address in a
register</td>
<td><code>0x23</code></td>
</tr>
<tr class="even">
<td><code>FLPT_DIV</code></td>
<td>Integer Divide</td>
<td>Register, Register</td>
<td>Divide the contents of one register by another, discarding the
remainder</td>
<td><code>0x30</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_DIV</code></td>
<td>Integer Divide</td>
<td>Register, Literal</td>
<td>Divide the contents of a register by a literal value, discarding the
remainder</td>
<td><code>0x31</code></td>
</tr>
<tr class="even">
<td><code>FLPT_DIV</code></td>
<td>Integer Divide</td>
<td>Register, Address</td>
<td>Divide a register by the contents of memory at an address in a
label, discarding the remainder</td>
<td><code>0x32</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_DIV</code></td>
<td>Integer Divide</td>
<td>Register, Pointer</td>
<td>Divide a register by the contents of memory at an address in a
register, discarding the remainder</td>
<td><code>0x33</code></td>
</tr>
<tr class="even">
<td><code>FLPT_DVR</code></td>
<td>Divide With Remainder</td>
<td>Register, Register, Register</td>
<td>Divide the contents of one register by another, storing the
remainder</td>
<td><code>0x34</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_DVR</code></td>
<td>Divide With Remainder</td>
<td>Register, Register, Literal</td>
<td>Divide the contents of a register by a literal value, storing the
remainder</td>
<td><code>0x35</code></td>
</tr>
<tr class="even">
<td><code>FLPT_DVR</code></td>
<td>Divide With Remainder</td>
<td>Register, Register, Address</td>
<td>Divide a register by the contents of memory at an address in a
label, storing the remainder</td>
<td><code>0x36</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_DVR</code></td>
<td>Divide With Remainder</td>
<td>Register, Register, Pointer</td>
<td>Divide a register by the contents of memory at an address in a
register, storing the remainder</td>
<td><code>0x37</code></td>
</tr>
<tr class="even">
<td><code>FLPT_REM</code></td>
<td>Remainder Only</td>
<td>Register, Register</td>
<td>Divide the contents of one register by another, storing only the
remainder</td>
<td><code>0x38</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_REM</code></td>
<td>Remainder Only</td>
<td>Register, Literal</td>
<td>Divide the contents of a register by a literal value, storing only
the remainder</td>
<td><code>0x39</code></td>
</tr>
<tr class="even">
<td><code>FLPT_REM</code></td>
<td>Remainder Only</td>
<td>Register, Address</td>
<td>Divide a register by the contents of memory at an address in a
label, storing only the remainder</td>
<td><code>0x3A</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_REM</code></td>
<td>Remainder Only</td>
<td>Register, Pointer</td>
<td>Divide a register by the contents of memory at an address in a
register, storing only the remainder</td>
<td><code>0x3B</code></td>
</tr>
<tr class="even">
<td><code>FLPT_SIN</code></td>
<td>Sine</td>
<td>Register</td>
<td>Calculate the sine of the value in a register in radians</td>
<td><code>0x40</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_ASN</code></td>
<td>Inverse Sine</td>
<td>Register</td>
<td>Calculate the inverse sine of the value in a register in
radians</td>
<td><code>0x41</code></td>
</tr>
<tr class="even">
<td><code>FLPT_COS</code></td>
<td>Cosine</td>
<td>Register</td>
<td>Calculate the cosine of the value in a register in radians</td>
<td><code>0x42</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_ACS</code></td>
<td>Inverse Cosine</td>
<td>Register</td>
<td>Calculate the inverse cosine of the value in a register in
radians</td>
<td><code>0x43</code></td>
</tr>
<tr class="even">
<td><code>FLPT_TAN</code></td>
<td>Tangent</td>
<td>Register</td>
<td>Calculate the tangent of the value in a register in radians</td>
<td><code>0x44</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_ATN</code></td>
<td>Inverse Tangent</td>
<td>Register</td>
<td>Calculate the inverse tangent of the value in a register in
radians</td>
<td><code>0x45</code></td>
</tr>
<tr class="even">
<td><code>FLPT_PTN</code></td>
<td>2 Argument Inverse Tangent</td>
<td>Register, Register</td>
<td>Calculate the 2 argument inverse tangent between 2 registers in the
order y, x</td>
<td><code>0x46</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_PTN</code></td>
<td>2 Argument Inverse Tangent</td>
<td>Register, Literal</td>
<td>Calculate the 2 argument inverse tangent between a register and a
literal in the order y, x</td>
<td><code>0x47</code></td>
</tr>
<tr class="even">
<td><code>FLPT_PTN</code></td>
<td>2 Argument Inverse Tangent</td>
<td>Register, Address</td>
<td>Calculate the 2 argument inverse tangent between a register and the
contents of memory at an address in a label in the order y, x</td>
<td><code>0x48</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_PTN</code></td>
<td>2 Argument Inverse Tangent</td>
<td>Register, Pointer</td>
<td>Calculate the 2 argument inverse tangent between a register and the
contents of memory at an address in a register in the order y, x</td>
<td><code>0x49</code></td>
</tr>
<tr class="even">
<td><code>FLPT_POW</code></td>
<td>Exponentiation</td>
<td>Register, Register</td>
<td>Calculate the value of a register raised to the power of another
register</td>
<td><code>0x50</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_POW</code></td>
<td>Exponentiation</td>
<td>Register, Literal</td>
<td>Calculate the value of a register raised to the power of a
literal</td>
<td><code>0x51</code></td>
</tr>
<tr class="even">
<td><code>FLPT_POW</code></td>
<td>Exponentiation</td>
<td>Register, Address</td>
<td>Calculate the value of a register raised to the power of the
contents of memory at an address in a label</td>
<td><code>0x52</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_POW</code></td>
<td>Exponentiation</td>
<td>Register, Pointer</td>
<td>Calculate the value of a register raised to the power of the
contents of memory at an address in a register</td>
<td><code>0x53</code></td>
</tr>
<tr class="even">
<td><code>FLPT_LOG</code></td>
<td>Logarithm</td>
<td>Register, Register</td>
<td>Calculate the logarithm of a register with the base from another
register</td>
<td><code>0x50</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_LOG</code></td>
<td>Logarithm</td>
<td>Register, Literal</td>
<td>Calculate the logarithm of a register with the base from a
literal</td>
<td><code>0x51</code></td>
</tr>
<tr class="even">
<td><code>FLPT_LOG</code></td>
<td>Logarithm</td>
<td>Register, Address</td>
<td>Calculate the logarithm of a register with the base from the
contents of memory at an address in a label</td>
<td><code>0x52</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_LOG</code></td>
<td>Logarithm</td>
<td>Register, Pointer</td>
<td>Calculate the logarithm of a register with the base from the
contents of memory at an address in a register</td>
<td><code>0x53</code></td>
</tr>
<tr class="even">
<td><strong>Console Writing</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>FLPT_WCN</code></td>
<td>Write Number to Console</td>
<td>Register</td>
<td>Write a register value as a signed decimal number to the
console</td>
<td><code>0x70</code></td>
</tr>
<tr class="even">
<td><code>FLPT_WCN</code></td>
<td>Write Number to Console</td>
<td>Literal</td>
<td>Write a literal value as a signed decimal number to the console</td>
<td><code>0x71</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_WCN</code></td>
<td>Write Number to Console</td>
<td>Address</td>
<td>Write 64-bits (4 bytes) of memory starting at the address in a label
as a signed decimal number to the console</td>
<td><code>0x72</code></td>
</tr>
<tr class="even">
<td><code>FLPT_WCN</code></td>
<td>Write Number to Console</td>
<td>Pointer</td>
<td>Write 64-bits (4 bytes) of memory starting at the address in a
register as a signed decimal number to the console</td>
<td><code>0x73</code></td>
</tr>
<tr class="odd">
<td><strong>File Writing</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>FLPT_WFN</code></td>
<td>Write Number to File</td>
<td>Register</td>
<td>Write a register value as a floating point decimal number to the
opened file</td>
<td><code>0x80</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_WFN</code></td>
<td>Write Number to File</td>
<td>Literal</td>
<td>Write a literal value as a floating point decimal number to the
opened file</td>
<td><code>0x81</code></td>
</tr>
<tr class="even">
<td><code>FLPT_WFN</code></td>
<td>Write Number to File</td>
<td>Address</td>
<td>Write 64-bits (4 bytes) of memory starting at the address in a label
as a floating point decimal number to the opened file</td>
<td><code>0x82</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_WFN</code></td>
<td>Write Number to File</td>
<td>Pointer</td>
<td>Write 64-bits (4 bytes) of memory starting at the address in a
register as a floating point decimal number to the opened file</td>
<td><code>0x83</code></td>
</tr>
<tr class="even">
<td><strong>Conversions</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>FLPT_EXH</code></td>
<td>Extend Half Precision Float to Double Precision Float</td>
<td>Register</td>
<td>Convert the value in a register from a half-precision float
(16-bits) to a double-precision float (64-bits)</td>
<td><code>0x90</code></td>
</tr>
<tr class="even">
<td><code>FLPT_EXS</code></td>
<td>Extend Single Precision Float to Double Precision Float</td>
<td>Register</td>
<td>Convert the value in a register from a single-precision float
(32-bits) to a double-precision float (64-bits)</td>
<td><code>0x91</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_SHS</code></td>
<td>Shrink Double Precision Float to Single Precision Float</td>
<td>Register</td>
<td>Convert the value in a register from a double-precision float
(64-bits) to a single-precision float (32-bits)</td>
<td><code>0x92</code></td>
</tr>
<tr class="even">
<td><code>FLPT_SHH</code></td>
<td>Shrink Double Precision Float to Half Precision Float</td>
<td>Register</td>
<td>Convert the value in a register from a double-precision float
(64-bits) to a half-precision float (16-bits)</td>
<td><code>0x93</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_NEG</code></td>
<td>Negation</td>
<td>Register</td>
<td>Reverse the sign of the floating point number in a register,
equivalent to flipping the sign bit.</td>
<td><code>0xA0</code></td>
</tr>
<tr class="even">
<td><code>FLPT_UTF</code></td>
<td>Convert Unsigned Quad Word to Double Precision Float</td>
<td>Register</td>
<td>Convert the unsigned value in a register to a double-precision float
(64-bits)</td>
<td><code>0xB0</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_STF</code></td>
<td>Convert Signed Quad Word to Double Precision Float</td>
<td>Register</td>
<td>Convert the signed value in a register to a double-precision float
(64-bits)</td>
<td><code>0xB1</code></td>
</tr>
<tr class="even">
<td><code>FLPT_FTS</code></td>
<td>Convert Double Precision Float to Signed Quad Word through
Truncation</td>
<td>Register</td>
<td>Convert the double-precision float (64-bits) value in a register to
a signed 64-bit integer by rounding toward 0</td>
<td><code>0xC0</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_FCS</code></td>
<td>Convert Double Precision Float to Signed Quad Word through Ceiling
Rounding</td>
<td>Register</td>
<td>Convert the double-precision float (64-bits) value in a register to
a signed 64-bit integer by rounding to the greater integer</td>
<td><code>0xC1</code></td>
</tr>
<tr class="even">
<td><code>FLPT_FFS</code></td>
<td>Convert Double Precision Float to Signed Quad Word through Floor
Rounding</td>
<td>Register</td>
<td>Convert the double-precision float (64-bits) value in a register to
a signed 64-bit integer by rounding to the lesser integer</td>
<td><code>0xC2</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_FNS</code></td>
<td>Convert Double Precision Float to Signed Quad Word through Nearest
Rounding</td>
<td>Register</td>
<td>Convert the double-precision float (64-bits) value in a register to
the nearest signed 64-bit integer, rounding midpoints to the nearest
even number</td>
<td><code>0xC3</code></td>
</tr>
<tr class="even">
<td><strong>Comparison</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>FLPT_CMP</code></td>
<td>Compare</td>
<td>Register, Register</td>
<td>Subtract a register from another, discarding the result whilst still
updating status flags</td>
<td><code>0xD0</code></td>
</tr>
<tr class="even">
<td><code>FLPT_CMP</code></td>
<td>Compare</td>
<td>Register, Literal</td>
<td>Subtract a literal value from a register, discarding the result
whilst still updating status flags</td>
<td><code>0xD1</code></td>
</tr>
<tr class="odd">
<td><code>FLPT_CMP</code></td>
<td>Compare</td>
<td>Register, Address</td>
<td>Subtract the contents of memory at an address in a label from a
register, discarding the result whilst still updating status flags</td>
<td><code>0xD2</code></td>
</tr>
<tr class="even">
<td><code>FLPT_CMP</code></td>
<td>Compare</td>
<td>Register, Pointer</td>
<td>Subtract the contents of memory at an address in a register from a
register, discarding the result whilst still updating status flags</td>
<td><code>0xD3</code></td>
</tr>
</tbody>
</table>
<h3 id="extended-base-set">Extended Base Set</h3>
<p>Extension set number <code>0x03</code>, opcodes start with
<code>0xFF, 0x03</code>.</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 18%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>Mnemonic</th>
<th>Full Name</th>
<th>Operands</th>
<th>Function</th>
<th>Instruction Code</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Byte Operations</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>EXTD_BSW</code></td>
<td>Reverse Byte Order</td>
<td>Register</td>
<td>Reverse the byte order of a register, thereby converting little
endian to big endian and vice versa</td>
<td><code>0x00</code></td>
</tr>
</tbody>
</table>
<h2 id="ascii-table">ASCII Table</h2>
<p>The following is a list of common characters and their corresponding
byte value in decimal.</p>
<table>
<thead>
<tr class="header">
<th>Code</th>
<th>Character</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>10</td>
<td>LF (line feed, new line)</td>
</tr>
<tr class="even">
<td>13</td>
<td>CR (carriage return)</td>
</tr>
<tr class="odd">
<td>32</td>
<td>SPACE</td>
</tr>
<tr class="even">
<td>33</td>
<td>!</td>
</tr>
<tr class="odd">
<td>34</td>
<td>”</td>
</tr>
<tr class="even">
<td>35</td>
<td>#</td>
</tr>
<tr class="odd">
<td>36</td>
<td>$</td>
</tr>
<tr class="even">
<td>37</td>
<td>%</td>
</tr>
<tr class="odd">
<td>38</td>
<td>&amp;</td>
</tr>
<tr class="even">
<td>39</td>
<td>’</td>
</tr>
<tr class="odd">
<td>40</td>
<td>(</td>
</tr>
<tr class="even">
<td>41</td>
<td>)</td>
</tr>
<tr class="odd">
<td>42</td>
<td>*</td>
</tr>
<tr class="even">
<td>43</td>
<td>+</td>
</tr>
<tr class="odd">
<td>44</td>
<td>,</td>
</tr>
<tr class="even">
<td>45</td>
<td>-</td>
</tr>
<tr class="odd">
<td>46</td>
<td>.</td>
</tr>
<tr class="even">
<td>47</td>
<td>/</td>
</tr>
<tr class="odd">
<td>48</td>
<td>0</td>
</tr>
<tr class="even">
<td>49</td>
<td>1</td>
</tr>
<tr class="odd">
<td>50</td>
<td>2</td>
</tr>
<tr class="even">
<td>51</td>
<td>3</td>
</tr>
<tr class="odd">
<td>52</td>
<td>4</td>
</tr>
<tr class="even">
<td>53</td>
<td>5</td>
</tr>
<tr class="odd">
<td>54</td>
<td>6</td>
</tr>
<tr class="even">
<td>55</td>
<td>7</td>
</tr>
<tr class="odd">
<td>56</td>
<td>8</td>
</tr>
<tr class="even">
<td>57</td>
<td>9</td>
</tr>
<tr class="odd">
<td>58</td>
<td>:</td>
</tr>
<tr class="even">
<td>59</td>
<td>;</td>
</tr>
<tr class="odd">
<td>60</td>
<td>&lt;</td>
</tr>
<tr class="even">
<td>61</td>
<td>=</td>
</tr>
<tr class="odd">
<td>62</td>
<td>&gt;</td>
</tr>
<tr class="even">
<td>63</td>
<td>?</td>
</tr>
<tr class="odd">
<td>64</td>
<td>@</td>
</tr>
<tr class="even">
<td>65</td>
<td>A</td>
</tr>
<tr class="odd">
<td>66</td>
<td>B</td>
</tr>
<tr class="even">
<td>67</td>
<td>C</td>
</tr>
<tr class="odd">
<td>68</td>
<td>D</td>
</tr>
<tr class="even">
<td>69</td>
<td>E</td>
</tr>
<tr class="odd">
<td>70</td>
<td>F</td>
</tr>
<tr class="even">
<td>71</td>
<td>G</td>
</tr>
<tr class="odd">
<td>72</td>
<td>H</td>
</tr>
<tr class="even">
<td>73</td>
<td>I</td>
</tr>
<tr class="odd">
<td>74</td>
<td>J</td>
</tr>
<tr class="even">
<td>75</td>
<td>K</td>
</tr>
<tr class="odd">
<td>76</td>
<td>L</td>
</tr>
<tr class="even">
<td>77</td>
<td>M</td>
</tr>
<tr class="odd">
<td>78</td>
<td>N</td>
</tr>
<tr class="even">
<td>79</td>
<td>O</td>
</tr>
<tr class="odd">
<td>80</td>
<td>P</td>
</tr>
<tr class="even">
<td>81</td>
<td>Q</td>
</tr>
<tr class="odd">
<td>82</td>
<td>R</td>
</tr>
<tr class="even">
<td>83</td>
<td>S</td>
</tr>
<tr class="odd">
<td>84</td>
<td>T</td>
</tr>
<tr class="even">
<td>85</td>
<td>U</td>
</tr>
<tr class="odd">
<td>86</td>
<td>V</td>
</tr>
<tr class="even">
<td>87</td>
<td>W</td>
</tr>
<tr class="odd">
<td>88</td>
<td>X</td>
</tr>
<tr class="even">
<td>89</td>
<td>Y</td>
</tr>
<tr class="odd">
<td>90</td>
<td>Z</td>
</tr>
<tr class="even">
<td>91</td>
<td>[</td>
</tr>
<tr class="odd">
<td>92</td>
<td>\</td>
</tr>
<tr class="even">
<td>93</td>
<td>]</td>
</tr>
<tr class="odd">
<td>94</td>
<td>^</td>
</tr>
<tr class="even">
<td>95</td>
<td>_</td>
</tr>
<tr class="odd">
<td>96</td>
<td>`</td>
</tr>
<tr class="even">
<td>97</td>
<td>a</td>
</tr>
<tr class="odd">
<td>98</td>
<td>b</td>
</tr>
<tr class="even">
<td>99</td>
<td>c</td>
</tr>
<tr class="odd">
<td>100</td>
<td>d</td>
</tr>
<tr class="even">
<td>101</td>
<td>e</td>
</tr>
<tr class="odd">
<td>102</td>
<td>f</td>
</tr>
<tr class="even">
<td>103</td>
<td>g</td>
</tr>
<tr class="odd">
<td>104</td>
<td>h</td>
</tr>
<tr class="even">
<td>105</td>
<td>i</td>
</tr>
<tr class="odd">
<td>106</td>
<td>j</td>
</tr>
<tr class="even">
<td>107</td>
<td>k</td>
</tr>
<tr class="odd">
<td>108</td>
<td>l</td>
</tr>
<tr class="even">
<td>109</td>
<td>m</td>
</tr>
<tr class="odd">
<td>110</td>
<td>n</td>
</tr>
<tr class="even">
<td>111</td>
<td>o</td>
</tr>
<tr class="odd">
<td>112</td>
<td>p</td>
</tr>
<tr class="even">
<td>113</td>
<td>q</td>
</tr>
<tr class="odd">
<td>114</td>
<td>r</td>
</tr>
<tr class="even">
<td>115</td>
<td>s</td>
</tr>
<tr class="odd">
<td>116</td>
<td>t</td>
</tr>
<tr class="even">
<td>117</td>
<td>u</td>
</tr>
<tr class="odd">
<td>118</td>
<td>v</td>
</tr>
<tr class="even">
<td>119</td>
<td>w</td>
</tr>
<tr class="odd">
<td>120</td>
<td>x</td>
</tr>
<tr class="even">
<td>121</td>
<td>y</td>
</tr>
<tr class="odd">
<td>122</td>
<td>z</td>
</tr>
<tr class="even">
<td>123</td>
<td>{</td>
</tr>
<tr class="odd">
<td>124</td>
<td>|</td>
</tr>
<tr class="even">
<td>125</td>
<td>}</td>
</tr>
<tr class="odd">
<td>126</td>
<td>~</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>Copyright © 2022–2023 Ptolemy Hill</strong></p>
</body>
</html>
