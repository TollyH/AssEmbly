"""
This script converts a program written in the whitespace esoteric programming
language to an equivalent AssEmbly program.

Usage: whitespace_to_assembly.py <file_path>
"""
import os
import sys

from whitespace import whitespace
SPACE, TAB, LINE_FEED = whitespace.SPACE, whitespace.TAB, whitespace.LINE_FEED

# Because whitespace has a separate value stack and call stack,
# whereas AssEmbly only has one, there needs to be a limit on value stack size
# so the call stack can be placed before it, but after the heap.
MAX_STACK_VALUES = 128
MAX_STACK_SIZE = MAX_STACK_VALUES * 8

# Change the location to input.ext.asm if it is different
INPUT_FILE_PATH = os.path.join(
    sys.path[0], "..", "Example Programs", "input.ext.asm"
)
with open(INPUT_FILE_PATH, encoding="utf8") as input_file:
    INPUT_FUNCTION = (
        input_file.read().replace("%ASM_ONCE", "").strip().splitlines()
    )

PROGRAM_START = [
    "; Generated by Whitespace to AssEmbly converter",
    "; rg0, rg1 - temporary holding",
    "; rg9 - call stack pointer",
    "MVQ rg9, rsb",
    f"SUB rg9, {MAX_STACK_SIZE}",
    "",
    "%ANALYZER warning, 0008, 0",
    "",
]

PROGRAM_END = [
    "",
    "; Imported contents of input function file",
    *INPUT_FUNCTION,
    "; End of input function file",
    "",
    ":FUNC_WHITESPACE_NUMBER_INPUT",
    "CAL :FUNC_INPUT, :&WHITESPACE_NUMBER_INPUT_BUFFER",
    "MVQ rg0, :&WHITESPACE_NUMBER_INPUT_BUFFER",
    "XOR rg1, rg1",
    "XOR rg3, rg3",
    ":FUNC_WHITESPACE_NUMBER_INPUT_LOOP",
    "MVB rg2, *rg0",
    "TST rg2, rg2",
    "JZO :FUNC_WHITESPACE_NUMBER_INPUT_LOOP_END",
    "CMP rg2, '-'",
    "JNE :FUNC_WHITESPACE_NUMBER_INPUT_ADD_DIGIT",
    "ICR rg3",
    "JMP :FUNC_WHITESPACE_NUMBER_INPUT_ICR",
    ":FUNC_WHITESPACE_NUMBER_INPUT_ADD_DIGIT",
    "SUB rg2, '0'",
    "MUL rg1, 10",
    "ADD rg1, rg2",
    ":FUNC_WHITESPACE_NUMBER_INPUT_ICR",
    "ICR rg0",
    "JMP :FUNC_WHITESPACE_NUMBER_INPUT_LOOP",
    ":FUNC_WHITESPACE_NUMBER_INPUT_LOOP_END",
    "TST rg3, rg3",
    "JZO :FUNC_WHITESPACE_NUMBER_INPUT_RETURN",
    "SIGN_NEG rg1",
    ":FUNC_WHITESPACE_NUMBER_INPUT_RETURN",
    "RET rg1",
    "",
    ":WHITESPACE_NUMBER_INPUT_BUFFER",
    "%PAD 24",
    "",
    ":WHITESPACE_HEAP_START",
]

CONVERSION_MAP = {
    SPACE + SPACE: [
        "; Stack Manipulation: Push a number onto the stack",
        "PSH {number}",
    ],
    SPACE + LINE_FEED + SPACE: [
        "; Stack Manipulation: Duplicate the top item on the stack",
        "PSH *rso",
    ],
    SPACE + TAB + SPACE: [
        "; Stack Manipulation: Copy the nth item on the stack onto the top of the stack",
        "MVQ rg0, {number}",
        "MUL rg0, 8",
        "ADD rg0, rso",
        "PSH *rg0",
    ],
    SPACE + LINE_FEED + TAB: [
        "; Stack Manipulation: Swap the top two items on the stack",
        "POP rg0",
        "POP rg1",
        "PSH rg0",
        "PSH rg1",
    ],
    SPACE + LINE_FEED + LINE_FEED: [
        "; Stack Manipulation: Discard the top item on the stack",
        "POP rg0",
    ],
    SPACE + TAB + LINE_FEED: [
        "; Stack Manipulation: Slide n items off the stack, keeping the top item",
        "POP rg0",
        "MVQ rg1, {number}",
        "MUL rg1, 8",
        "ADD rso, rg1",
        "PSH rg0",
    ],
    TAB + SPACE + SPACE + SPACE: [
        "; Arithmetic: Addition",
        "POP rg0",
        "POP rg1",
        "ADD rg1, rg0",
        "PSH rg1",
    ],
    TAB + SPACE + SPACE + TAB: [
        "; Arithmetic: Subtraction",
        "POP rg0",
        "POP rg1",
        "SUB rg1, rg0",
        "PSH rg1",
    ],
    TAB + SPACE + SPACE + LINE_FEED: [
        "; Arithmetic: Multiplication",
        "POP rg0",
        "POP rg1",
        "MUL rg1, rg0",
        "PSH rg1",
    ],
    TAB + SPACE + TAB + SPACE: [
        "; Arithmetic: Integer Division",
        "POP rg0",
        "POP rg1",
        "DIV rg1, rg0",
        "PSH rg1",
    ],
    TAB + SPACE + TAB + TAB: [
        "; Arithmetic: Modulo",
        "POP rg0",
        "POP rg1",
        "REM rg1, rg0",
        "PSH rg1",
    ],
    TAB + TAB + SPACE: [
        "; Heap Access: Store",
        "POP rg0",
        "POP rg1",
        "MUL rg1, 8",
        "ADD rg1, :&WHITESPACE_HEAP_START",
        "MVQ *rg1, rg0",
    ],
    TAB + TAB + TAB: [
        "; Heap Access: Retrieve",
        "POP rg0",
        "MUL rg0, 8",
        "ADD rg0, :&WHITESPACE_HEAP_START",
        "PSH *rg0",
    ],
    LINE_FEED + SPACE + SPACE: [
        "; Flow Control: Mark a location in the program",
        ":{label}",
    ],
    LINE_FEED + SPACE + TAB: [
        "; Flow Control: Call a subroutine",
        "SUB rg9, 8",
        "MVQ rg0, rpo",
        "ADD rg0, 24",
        "MVQ *rg9, rg0",
        "JMP :{label}",
    ],
    LINE_FEED + SPACE + LINE_FEED: [
        "; Flow Control: Jump unconditionally to a label",
        "JMP :{label}",
    ],
    LINE_FEED + TAB + SPACE: [
        "; Flow Control: Jump to a label if the top of the stack is zero",
        "POP rg0",
        "TST rg0, rg0",
        "JZO :{label}",
    ],
    LINE_FEED + TAB + TAB: [
        "; Flow Control: Jump to a label if the top of the stack is negative",
        "POP rg0",
        "TST rg0, rg0",
        "SIGN_JSI :{label}",
    ],
    LINE_FEED + TAB + LINE_FEED: [
        "; Flow Control: End a subroutine and transfer control back to the caller",
        "MVQ rg0, *rg9",
        "ADD rg9, 8",
        "JMP *rg0"
    ],
    LINE_FEED + LINE_FEED + LINE_FEED: [
        "; Flow Control: End the program",
        "HLT",
    ],
    TAB + LINE_FEED + SPACE + SPACE: [
        "; I/O: Output the character at the top of the stack",
        "POP rg0",
        "WCC rg0",
    ],
    TAB + LINE_FEED + SPACE + TAB: [
        "; I/O: Output the number at the top of the stack",
        "POP rg0",
        "WCN rg0",
    ],
    TAB + LINE_FEED + TAB + SPACE: [
        "; I/O: Read a character and place it in the location given by the top of the stack",
        "RCC rg0",
        "WCC rg0",
        "POP rg1",
        "MUL rg1, 8",
        "ADD rg1, :&WHITESPACE_HEAP_START",
        "MVQ *rg1, rg0",
    ],
    TAB + LINE_FEED + TAB + TAB: [
        "; I/O: Read a number and place it in the location given by the top of the stack",
        "CAL :FUNC_WHITESPACE_NUMBER_INPUT",
        "POP rg1",
        "MUL rg1, 8",
        "ADD rg1, :&WHITESPACE_HEAP_START",
        "MVQ *rg1, rrv",
    ],
}


def whitespace_label_to_assembly_label(label: str) -> str:
    """
    Convert a whitespace label name (i.e. SPACE and TAB characters only)
    to a valid AssEmbly label name.
    """
    return (
        "WHITESPACE_LABEL_"
        + label.replace(SPACE, '0').replace(TAB, '1').strip()
    )


def split_whitespace_token(token: str) -> tuple[str, str]:
    """
    Split a token of whitespace into the instruction and parameter parts.
    Parameters string may be empty if there are none.
    """
    i = 0
    while token[:i + 1] not in CONVERSION_MAP:
        i += 1
        if i >= len(token):
            raise SyntaxError("Token is not a valid whitespace instruction")
    return (token[:i + 1], token[i + 1:])


def whitespace_to_assembly(program: str) -> list[str]:
    """
    Convert a program written in the whitespace esoteric programming language
    to an equivalent AssEmbly program.
    """
    program = whitespace.ws_remove_comments(program)
    labels: dict[str, int] = {}
    tokens = whitespace.ws_tokenize(program, labels)

    converted_program: list[str] = []
    converted_program += PROGRAM_START

    for token in tokens:
        instruction, parameter = split_whitespace_token(token)
        new_lines = CONVERSION_MAP[instruction]
        if len(parameter) > 0:
            label = whitespace_label_to_assembly_label(parameter)
            number = str(whitespace.ws_number(parameter))
            for line in new_lines:
                converted_program.append(
                    line.replace("{label}", label).replace("{number}", number)
                )
        else:
            converted_program += new_lines

    converted_program += PROGRAM_END
    return converted_program


def main():
    if len(sys.argv) != 2:
        print("Usage: whitespace_to_assembly.py <file_path>")
        sys.exit(1)

    with open(sys.argv[1], encoding='utf8') as file:
        program = file.read()
    print('\n'.join(whitespace_to_assembly(program)))


if __name__ == "__main__":
    main()
